{"version":3,"names":["_promises","require","_nodePath","_errors","_diffUtils","_realityScore","_debugLogger","fileEditAttempts","Map","MAX_EDIT_ATTEMPTS_PER_FILE","EDIT_ATTEMPT_RESET_MS","createEditTools","workingDir","name","description","parameters","type","properties","file_path","old_string","new_string","default","replace_all","required","additionalProperties","handler","args","performSurgicalEdit","pathArg","oldString","newStringRaw","replaceAll","replacementString","trim","undefined","filePath","resolveFilePath","fileExists","stat","dir","dirname","mkdir","recursive","writeFile","relativePath","relative","displayPath","startsWith","lineCount","split","length","diffSegments","buildDiffSegmentsFast","addedLines","filter","s","MAX_DIFF_LINES","truncatedSegments","slice","diffLines","formatDiffLines","push","diffBlock","join","currentContent","readFile","targetString","matchNote","includes","unescaped","unescapeLiteral","flexibleMatch","matchWithFlexibleWhitespace","firstLine","suggestions","findSimilarLinesWithSuggestion","aiGuidance","buildAIRecoveryGuidance","JSON","stringify","substring","hints","actionable","adjusted","alignIndentation","occurrences","countOccurrences","realityScore","scoreEditReality","newString","logDebug","total","confidence","REALITY_THRESHOLDS","REJECT","warnings","map","w","failed","f","realityWarning","REVIEW","newContent","replace","diffResult","buildDiffWithContext","now","Date","attempts","get","lastTimestamp","set","count","lastContent","Promise","resolve","setTimeout","verifyContent","editAttempts","additions","removals","occurrencesText","noteText","segments","formatDiffClaudeStyle","remainingChanges","additionText","removalText","summaryParts","summaryText","realityNote","recordSuccessfulEdit","Boolean","error","buildError","old_string_length","new_string_length","path","normalized","text","search","position","indexOf","value","content","normalizedPattern","buildWhitespaceFlexiblePattern","regex","RegExp","match","escaped","lines","flexibleLines","line","target","replacement","targetLines","replacementLines","idx","targetLine","targetIndent","lineIndent","missing","trimStart","searchFirstLine","_fullSearchText","similarInfo","findSimilarLines","lineMatch","lineNum","parseInt","action","Math","max","_filePath","searchNormalized","toLowerCase","matches","searchWords","i","lineNormalized","hasTabs","leadingDiff","issue","similarity","matchingWords","sort","a","b","topMatches","m","truncated","issueNote","whitespaceMatch","find","searchText","fileContent","guidance","hasMultipleLines","hasLeadingWhitespace","test","searchLen","fileLen"],"sources":["editTools.ts"],"sourcesContent":["import { readFile, writeFile, stat, mkdir } from 'node:fs/promises';\nimport { join, relative, dirname } from 'node:path';\nimport type { ToolDefinition } from '../core/toolRuntime.js';\nimport { buildError } from '../core/errors.js';\nimport { buildDiffSegmentsFast, formatDiffLines, buildDiffWithContext, formatDiffClaudeStyle } from './diffUtils.js';\nimport { scoreEditReality, recordSuccessfulEdit, recordFailedEdit, REALITY_THRESHOLDS, type RealityScore } from '../core/realityScore.js';\nimport { logDebug } from '../utils/debugLogger.js';\n\n/**\n * Track edit attempts per file to detect when edits keep being reverted (e.g., by linters/hooks)\n */\nconst fileEditAttempts = new Map<string, { count: number; lastContent: string; lastTimestamp: number }>();\nconst MAX_EDIT_ATTEMPTS_PER_FILE = 3;\nconst EDIT_ATTEMPT_RESET_MS = 60000; // Reset counter after 1 minute of no edits\n\n/**\n * Creates the Edit tool for surgical file modifications using exact string replacement.\n *\n * This tool performs string-based edits without requiring full file rewrites,\n * making it ideal for targeted changes while preserving exact formatting and indentation.\n *\n * Features:\n * - Exact string matching (preserves indentation)\n * - Replace all occurrences or enforce uniqueness\n * - Unified diff preview\n * - Validation before writing\n *\n * @param workingDir - The working directory for resolving relative paths\n * @returns Array containing the Edit tool definition\n */\nexport function createEditTools(workingDir: string): ToolDefinition[] {\n  return [\n    {\n      name: 'Edit',\n      description:\n        'Performs exact string replacements in files. CRITICAL: For existing files, you MUST use the Read tool FIRST to get the exact text including whitespace and indentation, then copy it into old_string. The edit will FAIL if old_string is not unique unless replace_all is true. To CREATE a new file, use empty old_string (no prior read needed). To DELETE text, use empty new_string.',\n      parameters: {\n        type: 'object',\n        properties: {\n          file_path: {\n            type: 'string',\n            description: 'The absolute path to the file to modify or create',\n          },\n          old_string: {\n            type: 'string',\n            description: 'The exact text to replace (must match precisely including whitespace and indentation). For existing files, use read_file FIRST, then copy the exact text from its output (excluding line numbers). Use empty string \"\" to create a new file without needing a prior read.',\n          },\n          new_string: {\n            type: 'string',\n            default: '',\n            description:\n              'The text to replace it with. Use empty string \"\" to delete the old_string. For new files, this is the full content. Defaults to \"\" when omitted.',\n          },\n          replace_all: {\n            type: 'boolean',\n            description:\n              'Replace all occurrences of old_string (default false). When false, the edit fails if old_string appears multiple times.',\n          },\n        },\n        required: ['file_path', 'old_string'],\n        additionalProperties: false,\n      },\n      handler: async (args) => performSurgicalEdit(workingDir, args),\n    },\n  ];\n}\n\nexport interface EditArguments {\n  file_path?: unknown;\n  old_string?: unknown;\n  new_string?: unknown;\n  replace_all?: unknown;\n}\n\n/**\n * Shared edit executor used by both legacy and unified tool flows.\n * Provides consistent validation, creation/deletion handling, and diff output.\n */\nexport async function performSurgicalEdit(\n  workingDir: string,\n  args: EditArguments | Record<string, unknown>\n): Promise<string> {\n  const pathArg = (args as EditArguments)['file_path'];\n  const oldString = (args as EditArguments)['old_string'];\n  const newStringRaw = (args as EditArguments)['new_string'];\n  const replaceAll = (args as EditArguments)['replace_all'] === true;\n  let replacementString = typeof newStringRaw === 'string' ? newStringRaw : '';\n\n  // Validate inputs\n  if (typeof pathArg !== 'string' || !pathArg.trim()) {\n    return 'Error: file_path must be a non-empty string.';\n  }\n  if (typeof oldString !== 'string') {\n    return 'Error: old_string must be a string (use \"\" for empty).';\n  }\n  if (newStringRaw !== undefined && typeof newStringRaw !== 'string') {\n    return 'Error: new_string must be a string (use \"\" for empty).';\n  }\n  // Only error if both are identical AND non-empty (no-op edit)\n  // Allow: empty old + content = create, content + empty new = delete\n  if (oldString === replacementString && oldString !== '') {\n    return 'Error: old_string and new_string are identical. No changes would be made.';\n  }\n  // Both empty is also a no-op\n  if (oldString === '' && replacementString === '') {\n    return 'Error: Both old_string and new_string are empty. Provide content to create a file or text to replace.';\n  }\n\n  try {\n    const filePath = resolveFilePath(workingDir, pathArg);\n\n    // Check if file exists\n    let fileExists = false;\n    try {\n      await stat(filePath);\n      fileExists = true;\n    } catch {\n      fileExists = false;\n    }\n\n    // Handle file creation mode (empty old_string)\n    if (oldString === '') {\n      if (fileExists) {\n        return `Error: File already exists: ${filePath}\\nTo modify an existing file, provide the exact text to replace in old_string.`;\n      }\n\n      // Create parent directories if needed\n      const dir = dirname(filePath);\n      await mkdir(dir, { recursive: true });\n\n      // Write new file\n      await writeFile(filePath, replacementString, 'utf-8');\n\n      const relativePath = relative(workingDir, filePath);\n      const displayPath = relativePath && !relativePath.startsWith('..') ? relativePath : filePath;\n      const lineCount = replacementString.split('\\n').length;\n      const diffSegments = buildDiffSegmentsFast('', replacementString);\n      const addedLines = diffSegments.filter((s) => s.type === 'added').length;\n      // Limit to 5 diff lines for concise output\n      const MAX_DIFF_LINES = 5;\n      const truncatedSegments = diffSegments.slice(0, MAX_DIFF_LINES);\n      const diffLines = formatDiffLines(truncatedSegments, true);\n      if (diffSegments.length > MAX_DIFF_LINES) {\n        diffLines.push(`      ... +${diffSegments.length - MAX_DIFF_LINES} more lines`);\n      }\n      const diffBlock =\n        diffLines.length > 0 ? diffLines.join('\\n') : '(No visual diff - whitespace or formatting changes only)';\n\n      return [\n        `⏺ Create(${displayPath})`,\n        `  ⎿  Created ${displayPath} with ${addedLines} additions`,\n        `     ${lineCount} line${lineCount === 1 ? '' : 's'} written`,\n        diffBlock,\n      ].join('\\n');\n    }\n\n    // For modifications, file must exist\n    if (!fileExists) {\n      return `Error: File not found: ${filePath}\\nTo create a new file, use empty old_string (\"\").`;\n    }\n\n    // Read current content (async for speed)\n    const currentContent = await readFile(filePath, 'utf-8');\n\n    // Normalize escaped literals and whitespace differences to reduce mismatch errors\n    let targetString = oldString;\n    let matchNote: string | null = null;\n    if (!currentContent.includes(targetString)) {\n      const unescaped = unescapeLiteral(oldString);\n      if (unescaped !== oldString && currentContent.includes(unescaped)) {\n        targetString = unescaped;\n        matchNote = 'normalized escaped old_string';\n      }\n    }\n\n    if (!currentContent.includes(targetString)) {\n      const flexibleMatch = matchWithFlexibleWhitespace(currentContent, targetString);\n      if (flexibleMatch) {\n        targetString = flexibleMatch;\n        matchNote = matchNote ? matchNote : 'normalized whitespace in old_string';\n      }\n    }\n\n    // Check if old_string exists in file\n    if (!currentContent.includes(targetString)) {\n      // Provide helpful debugging info when match fails\n      const firstLine = oldString.split('\\n')[0] || '';\n      const suggestions = findSimilarLinesWithSuggestion(currentContent, firstLine, oldString, filePath, workingDir);\n\n      // AI Flow Design: Provide structured guidance for self-correction\n      const aiGuidance = buildAIRecoveryGuidance(oldString, currentContent);\n\n      return [\n        'Error: old_string not found in file.',\n        '',\n        `File: ${filePath}`,\n        `Searching for: ${JSON.stringify(firstLine.substring(0, 80))}${firstLine.length > 80 ? '...' : ''}`,\n        '',\n        suggestions.hints,\n        '',\n        suggestions.actionable ? 'RECOMMENDED ACTION:' : 'Guidance:',\n        suggestions.actionable ? suggestions.actionable : '- Ensure exact whitespace/indentation matches\\n- Copy text directly from Read output\\n- Check for tabs vs spaces',\n        '',\n        '---',\n        'AI SELF-CORRECTION GUIDANCE:',\n        aiGuidance,\n      ].join('\\n');\n    }\n\n    // Count occurrences\n    // Preserve indentation when we had to normalize whitespace to find the match\n    if (matchNote === 'normalized whitespace in old_string') {\n      const adjusted = alignIndentation(targetString, replacementString);\n      if (adjusted !== replacementString) {\n        replacementString = adjusted;\n      }\n    }\n\n    const occurrences = countOccurrences(currentContent, targetString);\n\n    if (!replaceAll && occurrences > 1) {\n      return `Error: old_string appears ${occurrences} times in the file. Either:\\n1. Provide a larger unique string that includes more context\\n2. Set replace_all: true to replace all ${occurrences} occurrences\\n\\nFile: ${filePath}`;\n    }\n\n    // Reality Score Check - detect potential hallucinations before applying edit\n    const realityScore = scoreEditReality({\n      filePath,\n      oldString: targetString,\n      newString: replacementString,\n      replaceAll,\n    });\n\n    // Log reality score for debugging/learning\n    logDebug(`Edit reality score for ${filePath}: ${realityScore.total}/100 (${realityScore.confidence})`);\n\n    // Block edits with very low reality scores (likely hallucinations)\n    if (realityScore.total < REALITY_THRESHOLDS.REJECT) {\n      const warnings = realityScore.warnings.length > 0\n        ? `\\nWarnings:\\n${realityScore.warnings.map(w => `  ⚠ ${w}`).join('\\n')}`\n        : '';\n      const failed = realityScore.failed.length > 0\n        ? `\\nFailed checks:\\n${realityScore.failed.map(f => `  ✗ ${f}`).join('\\n')}`\n        : '';\n\n      return [\n        `⚠ Edit blocked - Low reality score: ${realityScore.total}/100`,\n        '',\n        'This edit appears to reference content that may not exist.',\n        'Please verify:',\n        '1. The old_string text actually exists in the file',\n        '2. The imports/dependencies in new_string are valid',\n        '3. The syntax in new_string is correct',\n        warnings,\n        failed,\n        '',\n        `File: ${filePath}`,\n      ].join('\\n');\n    }\n\n    // Warn on medium-low scores but allow the edit\n    let realityWarning = '';\n    if (realityScore.total < REALITY_THRESHOLDS.REVIEW && realityScore.warnings.length > 0) {\n      realityWarning = `\\n⚠ Reality score: ${realityScore.total}/100 - ${realityScore.warnings[0]}`;\n    }\n\n    // Perform replacement\n    const newContent = replaceAll\n      ? currentContent.split(targetString).join(replacementString)\n      : currentContent.replace(targetString, replacementString);\n\n    // Generate diff with context lines (AGI CLI style)\n    const diffResult = buildDiffWithContext(currentContent, newContent, 2);\n\n    // Check for repeated edit attempts on same file (detect linter/hook reversion loops)\n    const now = Date.now();\n    const attempts = fileEditAttempts.get(filePath);\n    if (attempts) {\n      // Reset if enough time has passed\n      if (now - attempts.lastTimestamp > EDIT_ATTEMPT_RESET_MS) {\n        fileEditAttempts.set(filePath, { count: 1, lastContent: newContent, lastTimestamp: now });\n      } else if (attempts.lastContent === newContent) {\n        // Same exact edit being attempted again - likely in a loop\n        attempts.count++;\n        attempts.lastTimestamp = now;\n        if (attempts.count > MAX_EDIT_ATTEMPTS_PER_FILE) {\n          return [\n            `Error: Edit loop detected on ${filePath}`,\n            '',\n            `This edit has been attempted ${attempts.count} times in quick succession.`,\n            'The file may be getting reverted by a linter, formatter, or pre-commit hook.',\n            '',\n            'To resolve:',\n            '1. Check for active file watchers or formatters',\n            '2. Disable auto-formatting temporarily',\n            '3. Or accept the current file state and move on',\n            '',\n            'STOPPING to prevent infinite loop.',\n          ].join('\\n');\n        }\n      } else {\n        // Different edit - reset counter but track the new content\n        fileEditAttempts.set(filePath, { count: 1, lastContent: newContent, lastTimestamp: now });\n      }\n    } else {\n      fileEditAttempts.set(filePath, { count: 1, lastContent: newContent, lastTimestamp: now });\n    }\n\n    // Write file (async for speed)\n    await writeFile(filePath, newContent, 'utf-8');\n\n    // Verify the edit persisted (detect immediate reversion by hooks/watchers)\n    // Small delay to allow any file watchers to trigger\n    await new Promise(resolve => setTimeout(resolve, 50));\n    const verifyContent = await readFile(filePath, 'utf-8');\n    if (verifyContent !== newContent) {\n      // File was modified after our write - likely by a linter/formatter\n      const editAttempts = fileEditAttempts.get(filePath);\n      if (editAttempts) {\n        editAttempts.count++;\n      }\n      return [\n        `Warning: Edit was immediately modified by an external process.`,\n        '',\n        `File: ${filePath}`,\n        'The edit was written but the file content changed immediately after.',\n        'This is likely caused by a linter, formatter, or file watcher.',\n        '',\n        'The current file state may differ from the intended edit.',\n        'Consider disabling auto-formatting or accepting the modified result.',\n      ].join('\\n');\n    }\n\n    // Build summary (AGI CLI style)\n    const relativePath = relative(workingDir, filePath);\n    const displayPath = relativePath && !relativePath.startsWith('..') ? relativePath : filePath;\n    const { additions, removals } = diffResult;\n    const occurrencesText = replaceAll ? ` (${occurrences} occurrence${occurrences > 1 ? 's' : ''})` : '';\n    const noteText = matchNote ? ` [${matchNote}]` : '';\n\n    // Format diff with colors for terminal display (AGI CLI style)\n    // Limit to 5 diff lines to keep output concise\n    const MAX_DIFF_LINES = 5;\n    const truncatedSegments = diffResult.segments.slice(0, MAX_DIFF_LINES);\n    const diffLines = formatDiffClaudeStyle(truncatedSegments, true);\n    const remainingChanges = diffResult.segments.length - MAX_DIFF_LINES;\n    if (remainingChanges > 0) {\n      diffLines.push(`      ... +${remainingChanges} more changes`);\n    }\n    const diffBlock =\n      diffLines.length > 0 ? diffLines.join('\\n') : '      (No visual diff - whitespace or formatting changes only)';\n\n    // Build AGI CLI style output:\n    // ⏺ Update(filepath)\n    //   ⎿  Updated filepath with N additions and M removals\n    //       41    }\n    //       42 +   new line\n    const additionText = additions === 1 ? '1 addition' : `${additions} additions`;\n    const removalText = removals === 1 ? '1 removal' : `${removals} removals`;\n    const summaryParts = [];\n    if (additions > 0) summaryParts.push(additionText);\n    if (removals > 0) summaryParts.push(removalText);\n    const summaryText = summaryParts.length > 0 ? summaryParts.join(' and ') : 'no changes';\n\n    // Include reality score in output for high-confidence edits\n    const realityNote = realityScore.confidence === 'high'\n      ? ''\n      : realityWarning;\n\n    // Record successful edit for RL learning\n    recordSuccessfulEdit(filePath, realityScore);\n\n    return [\n      `⏺ Update(${displayPath})${occurrencesText}${noteText}`,\n      `  ⎿  Updated ${displayPath} with ${summaryText}`,\n      diffBlock,\n      realityNote,\n    ].filter(Boolean).join('\\n');\n  } catch (error: unknown) {\n    return buildError('editing file', error, {\n      file_path: typeof pathArg === 'string' ? pathArg : '',\n      old_string_length: typeof oldString === 'string' ? oldString.length : 0,\n      new_string_length: typeof replacementString === 'string' ? replacementString.length : 0,\n    });\n  }\n}\n\nfunction resolveFilePath(workingDir: string, path: string): string {\n  const normalized = path.trim();\n  return normalized.startsWith('/') ? normalized : join(workingDir, normalized);\n}\n\nfunction countOccurrences(text: string, search: string): number {\n  if (!search) return 0;\n  let count = 0;\n  let position = 0;\n\n  while ((position = text.indexOf(search, position)) !== -1) {\n    count++;\n    position += search.length;\n  }\n\n  return count;\n}\n\n/**\n * Convert common escaped sequences (\\\\n, \\\\r, \\\\t, \\\\\\\\) into their literal forms.\n */\nfunction unescapeLiteral(value: string): string {\n  if (!value.includes('\\\\')) return value;\n  return value\n    .replace(/\\\\\\\\/g, '\\\\')\n    .replace(/\\\\n/g, '\\n')\n    .replace(/\\\\r/g, '\\r')\n    .replace(/\\\\t/g, '\\t');\n}\n\n/**\n * Try to locate the search string allowing whitespace differences (indentation, spacing).\n * Returns the exact substring from the original content when matched.\n */\nfunction matchWithFlexibleWhitespace(content: string, search: string): string | null {\n  const normalizedPattern = buildWhitespaceFlexiblePattern(search);\n  if (!normalizedPattern) {\n    return null;\n  }\n  const regex = new RegExp(normalizedPattern, 's');\n  const match = content.match(regex);\n  return match ? match[0] : null;\n}\n\nfunction buildWhitespaceFlexiblePattern(search: string): string | null {\n  if (!search.trim()) {\n    return null;\n  }\n  // Escape regex metacharacters\n  const escaped = search.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  // Only allow flexible whitespace WITHIN lines, not across lines\n  // This prevents matching across completely different code structures\n  // Split by newlines, make each line flexible, then require exact newline boundaries\n  const lines = escaped.split(/\\\\n|\\n/);\n  const flexibleLines = lines.map(line => line.replace(/[ \\t]+/g, '[ \\\\t]+'));\n  // Rejoin with flexible newline matching (allows \\r\\n or \\n)\n  return flexibleLines.join('\\\\r?\\\\n');\n}\n\n/**\n * When whitespace normalization is used, keep the replacement aligned with the matched indentation.\n * If a line in the replacement has no indentation, inherit indentation from the matched line.\n */\nfunction alignIndentation(target: string, replacement: string): string {\n  const targetLines = target.split('\\n');\n  const replacementLines = replacement.split('\\n');\n  if (targetLines.length !== replacementLines.length) {\n    return replacement;\n  }\n\n  const adjusted = replacementLines.map((line, idx) => {\n    const targetLine = targetLines[idx] ?? '';\n    const targetIndent = targetLine.match(/^\\s*/)?.[0] ?? '';\n    if (!line.trim()) {\n      return targetIndent;\n    }\n    const lineIndent = line.match(/^\\s*/)?.[0] ?? '';\n    if (lineIndent.length < targetIndent.length) {\n      const missing = targetIndent.slice(lineIndent.length);\n      return `${lineIndent}${missing}${line.trimStart()}`;\n    }\n    return line;\n  });\n\n  return adjusted.join('\\n');\n}\n\n/**\n * Enhanced similar line finder with actionable suggestions for AI.\n * Provides exact text to use in old_string and clear next steps.\n */\nfunction findSimilarLinesWithSuggestion(\n  content: string,\n  searchFirstLine: string,\n  _fullSearchText: string,\n  filePath: string,\n  workingDir: string\n): { hints: string; actionable: string | null } {\n  const similarInfo = findSimilarLines(content, searchFirstLine, filePath);\n\n  // Extract line numbers from similar lines\n  const lineMatch = similarInfo.match(/Line (\\d+)/);\n  if (lineMatch && lineMatch[1]) {\n    const lineNum = parseInt(lineMatch[1], 10);\n    const relativePath = relative(workingDir, filePath);\n    const displayPath = relativePath && !relativePath.startsWith('..') ? relativePath : filePath;\n\n    // Provide concrete action: Read the file to get exact text\n    const action = [\n      `1. Use Read tool to view ${displayPath} starting at line ${Math.max(1, lineNum - 5)}`,\n      `2. Copy the EXACT text from the Read output (including all indentation)`,\n      `3. Use that exact text as old_string in your Edit call`,\n      `4. Ensure you copy multiple lines if needed for uniqueness`,\n    ].join('\\n   ');\n\n    return { hints: similarInfo, actionable: action };\n  }\n\n  // No similar lines found - suggest reading entire file\n  const relativePath = relative(workingDir, filePath);\n  const displayPath = relativePath && !relativePath.startsWith('..') ? relativePath : filePath;\n  const action = [\n    `1. Use Read tool to view the entire file: ${displayPath}`,\n    `2. Locate the text you want to change`,\n    `3. Copy the EXACT text including whitespace`,\n    `4. Paste it as old_string in your Edit call`,\n  ].join('\\n   ');\n\n  return { hints: similarInfo, actionable: action };\n}\n\n/**\n * Find lines in the file that are similar to the search text.\n * Enhanced with whitespace detection and auto-correction suggestions.\n */\nfunction findSimilarLines(content: string, searchFirstLine: string, _filePath: string): string {\n  if (!searchFirstLine.trim()) {\n    return 'The search string starts with an empty line.';\n  }\n\n  const lines = content.split('\\n');\n  const searchNormalized = searchFirstLine.trim().toLowerCase();\n  const matches: Array<{ lineNum: number; line: string; similarity: number; issue?: string }> = [];\n\n  // Find lines that contain key words from the search\n  const searchWords = searchNormalized.split(/\\s+/).filter((w) => w.length > 2);\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i] || '';\n    const lineNormalized = line.trim().toLowerCase();\n\n    // Check for exact match with different whitespace\n    if (lineNormalized === searchNormalized && line !== searchFirstLine) {\n      const hasTabs = line.includes('\\t') !== searchFirstLine.includes('\\t');\n      const leadingDiff = line.match(/^\\s*/)?.[0]?.length !== searchFirstLine.match(/^\\s*/)?.[0]?.length;\n      const issue = hasTabs ? 'tabs vs spaces' : leadingDiff ? 'different indentation' : 'whitespace difference';\n      matches.push({ lineNum: i + 1, line, similarity: 0.99, issue });\n      continue;\n    }\n\n    // Check for partial match (contains significant portion of the search)\n    if (lineNormalized.includes(searchNormalized.substring(0, 20))) {\n      matches.push({ lineNum: i + 1, line, similarity: 1.0 });\n      continue;\n    }\n\n    // Check for word overlap\n    if (searchWords.length > 0) {\n      const matchingWords = searchWords.filter((w) => lineNormalized.includes(w));\n      const similarity = matchingWords.length / searchWords.length;\n      if (similarity >= 0.5) {\n        matches.push({ lineNum: i + 1, line, similarity });\n      }\n    }\n  }\n\n  if (matches.length === 0) {\n    return 'No similar lines found. The text may not exist in this file.';\n  }\n\n  // Sort by similarity and take top 3\n  matches.sort((a, b) => b.similarity - a.similarity);\n  const topMatches = matches.slice(0, 3);\n\n  const suggestions = topMatches.map((m) => {\n    const truncated = m.line.length > 80 ? `${m.line.substring(0, 77)  }...` : m.line;\n    const issueNote = m.issue ? ` (${m.issue})` : '';\n    return `  Line ${m.lineNum}${issueNote}: ${JSON.stringify(truncated)}`;\n  });\n\n  // Add auto-correction hint for whitespace issues\n  const whitespaceMatch = topMatches.find((m) => m.issue);\n  if (whitespaceMatch) {\n    return `Similar lines found (possible whitespace mismatch):\\n${suggestions.join('\\n')}\\n\\nCopy the exact text from Read output including indentation.`;\n  }\n\n  return `Similar lines found:\\n${suggestions.join('\\n')}`;\n}\n\n/**\n * Build AI-specific recovery guidance based on the failure pattern.\n * This function implements AI flow design principles for self-correction.\n */\nfunction buildAIRecoveryGuidance(searchText: string, fileContent: string): string {\n  const guidance: string[] = [];\n\n  // Analyze the failure pattern\n  const hasMultipleLines = searchText.includes('\\n');\n  const hasLeadingWhitespace = /^\\s/.test(searchText);\n  const searchLen = searchText.length;\n  const fileLen = fileContent.length;\n\n  // PATTERN: Single line search in multi-line file\n  if (!hasMultipleLines && fileLen > 1000) {\n    guidance.push(\n      '• PATTERN DETECTED: Single-line search in large file',\n      '  → Include 2-3 surrounding lines for uniqueness',\n      '  → Use Read tool with specific line offset to get exact context'\n    );\n  }\n\n  // PATTERN: Missing leading whitespace\n  if (!hasLeadingWhitespace && fileContent.includes('  ')) {\n    guidance.push(\n      '• PATTERN DETECTED: Search text may be missing indentation',\n      '  → File uses indentation, but old_string starts without whitespace',\n      '  → Copy exact text from Read output including leading spaces/tabs'\n    );\n  }\n\n  // PATTERN: Very short search\n  if (searchLen < 30) {\n    guidance.push(\n      '• PATTERN DETECTED: Search text is very short (<30 chars)',\n      '  → Short strings are prone to false negatives due to whitespace',\n      '  → Include more context: function body, surrounding statements'\n    );\n  }\n\n  // PATTERN: Potential escape sequence issues\n  if (searchText.includes('\\\\n') || searchText.includes('\\\\t')) {\n    guidance.push(\n      '• PATTERN DETECTED: Escaped characters in search text',\n      '  → old_string contains \\\\n or \\\\t as literal strings',\n      '  → Use actual newlines/tabs, not escaped versions'\n    );\n  }\n\n  // PATTERN: Function/class definition\n  if (/^(function|class|def |const |let |var |export )/.test(searchText.trim())) {\n    guidance.push(\n      '• PATTERN DETECTED: Function/class definition search',\n      '  → Definitions often have complex indentation',\n      '  → Read the exact definition including all decorators/comments above'\n    );\n  }\n\n  // Default guidance if no specific pattern detected\n  if (guidance.length === 0) {\n    guidance.push(\n      '• GENERAL GUIDANCE:',\n      '  1. Use Read tool to view file around expected location',\n      '  2. Copy exact text from Read output (including all whitespace)',\n      '  3. Verify the text exists in file before Edit call',\n      '  4. Include more context lines if text appears multiple times'\n    );\n  }\n\n  // Always add the critical reminder\n  guidance.push(\n    '',\n    'CRITICAL: Always Read → Copy → Edit. Never guess file content.'\n  );\n\n  return guidance.join('\\n');\n}\n"],"mappings":"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","ignoreList":[]}