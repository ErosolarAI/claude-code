{"version":3,"names":["_contextWindow","require","SUMMARIZATION_PROMPT","exports","DEFAULT_AI_FLOW_PATTERNS","patternId","description","toolSequence","contextImpact","compactionOpportunity","preservationPriority","ContextManager","config","sessionStartTime","Date","now","toolCallHistory","constructor","maxTokens","targetTokens","maxToolOutputLength","preserveRecentMessages","estimatedCharsPerToken","recordToolCall","toolName","push","length","shift","truncateToolOutput","output","_args","originalLength","content","wasTruncated","truncatedLength","truncated","intelligentTruncate","maxLength","truncateFileOutput","truncateSearchOutput","truncateBashOutput","truncateDefault","lines","split","keepLines","Math","floor","headLines","slice","tailLines","truncatedCount","join","keepChars","prefixChars","prefix","suffix","truncatedChars","estimateTokens","message","charCount","role","toolCalls","call","name","JSON","stringify","arguments","ceil","detectContextOverflowRisk","recentTools","broadSearches","filter","tool","includes","fileReads","contextSnapshots","estimateTotalTokens","messages","reduce","sum","msg","pruneMessages","totalTokens","pruned","removed","firstMessage","systemMessage","conversationMessages","turns","currentTurn","recentTurns","exchangeCount","i","turn","unshift","startIndex","firstTurn","assistantMsg","toolCallIds","map","tc","id","presentToolResultIds","Set","m","toolCallId","allPresent","has","validTurns","recentMessages","flat","removedCount","pruneMessagesWithSummary","options","force","summarized","summarizationCallback","useLLMSummarization","result","keepTurnCount","summarizeTurns","toSummarize","summary","trim","error","isApproachingLimit","getWarningLevel","percentage","getWarningMessage","stats","getStats","warningLevel","round","isOverLimit","updateConfig","DEFAULT_TASK_BOUNDARY_PATTERNS","TOPIC_SHIFT_PATTERNS","USER_PIVOT_PATTERNS","analyzeCompactionPoints","signals","tokenPercentage","compactionThreshold","minConfidence","minSignalConfidence","shouldCompact","recommendedCompactionPoint","urgency","preserveFromIndex","taskBoundary","detectTaskBoundary","confidence","topicShift","detectTopicShift","userPivot","detectUserPivot","saturation","detectContextSaturation","milestone","detectMilestone","calculateUrgency","recommendedPoint","findBestCompactionPoint","findSafePreservePoint","index","patterns","taskBoundaryPatterns","p","RegExp","matchCount","reasons","pattern","test","source","min","looksLikeConclusion","nextUserMsg","find","isNewTopic","type","messageIndex","reason","sensitivity","topicShiftSensitivity","prevMessages","max","prevContent","windowStart","windowEnd","window","toolCount","totalToolSize","lastToolIndex","_messages","milestonePatterns","conclusionPatterns","some","newContent","extractTerms","text","words","toLowerCase","replace","w","prevTerms","newTerms","size","overlap","term","overlapRatio","typePriority","task_boundary","user_pivot","ai_flow_pattern","topic_shift","context_saturation","urgencyDepth","none","low","medium","high","critical","maxDepth","minIndex","bestSignal","bestScore","signal","score","compactionPoint","intelligentCompact","analysis","compacted","toPreserve","shouldTriggerCompaction","enableIntelligentCompaction","topSignal","sort","a","b","createDefaultContextManager","overrides","model","thresholds","calculateContextThresholds","warningTokens","criticalTokens","formatMessagesForSummary","toolNames","createSummarizationCallback","provider","conversationText","prompt","response","generate"],"sources":["contextManager.ts"],"sourcesContent":["/**\n * ContextManager - Manages conversation context to prevent token limit leaks\n *\n * Responsibilities:\n * - Truncate tool outputs intelligently\n * - Prune old conversation history with LLM summarization\n * - Track and estimate token usage\n * - Keep conversation within budget based on model context windows\n * - Proactively shrink context before hitting limits\n */\n\nimport type { ConversationMessage } from './types.js';\nimport { calculateContextThresholds } from './contextWindow.js';\n\n/**\n * Callback for LLM-based summarization of conversation history\n * Takes messages to summarize and returns a concise summary string\n */\nexport type SummarizationCallback = (\n  messages: ConversationMessage[]\n) => Promise<string>;\n\n/**\n * Signals that indicate a good compaction point in the conversation\n */\nexport interface CompactionSignal {\n  type: 'task_boundary' | 'topic_shift' | 'milestone' | 'context_saturation' | 'user_pivot' | 'ai_flow_pattern';\n  confidence: number; // 0-1\n  messageIndex: number;\n  reason: string;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * AI Flow Patterns for intelligent context management\n */\nexport interface AIFlowPattern {\n  patternId: string;\n  description: string;\n  toolSequence: string[];\n  contextImpact: number; // Estimated token impact\n  compactionOpportunity: boolean;\n  preservationPriority: number; // 1-10, higher = preserve more\n}\n\n/**\n * Enhanced compaction analysis with AI flow awareness\n */\nexport interface EnhancedCompactionAnalysis {\n  shouldCompact: boolean;\n  signals: CompactionSignal[];\n  recommendedCompactionPoint: number | null;\n  urgency: 'none' | 'low' | 'medium' | 'high' | 'critical';\n  preserveFromIndex: number;\n  aiFlowPatterns: AIFlowPattern[];\n  estimatedTokenSavings: number;\n  riskAssessment: {\n    informationLossRisk: 'low' | 'medium' | 'high';\n    continuityRisk: 'low' | 'medium' | 'high';\n    recoveryDifficulty: 'easy' | 'moderate' | 'hard';\n  };\n}\n\n/**\n * Result of intelligent compaction analysis\n */\nexport interface CompactionAnalysis {\n  shouldCompact: boolean;\n  signals: CompactionSignal[];\n  recommendedCompactionPoint: number | null;\n  urgency: 'none' | 'low' | 'medium' | 'high' | 'critical';\n  preserveFromIndex: number;\n}\n\n/**\n * Summarization prompt template\n */\nexport const SUMMARIZATION_PROMPT = `Create a compact but reliable summary of the earlier conversation.\n\nKeep:\n- Decisions, preferences, and open questions\n- File paths, function/class names, APIs, and error messages with fixes\n- What was completed vs. still pending (tests, TODOs)\n\nFormat:\n## Key Context\n- ...\n## Work Completed\n- ...\n## Open Items\n- ...\n\nConversation:\n{conversation}`;\n\nexport interface ContextManagerConfig {\n  maxTokens: number; // Maximum tokens allowed in conversation\n  targetTokens: number; // Target to stay under (70% of max - triggers pruning)\n  warningTokens?: number; // Show warning threshold (60% of max)\n  criticalTokens?: number; // Critical warning threshold (85% of max)\n  maxToolOutputLength: number; // Max characters for tool outputs\n  preserveRecentMessages: number; // Number of recent exchanges to always keep\n  estimatedCharsPerToken: number; // Rough estimation (usually ~4 for English)\n  useLLMSummarization?: boolean; // Whether to use LLM-based summarization (default: true if callback provided)\n  summarizationCallback?: SummarizationCallback; // Optional LLM summarization callback\n  model?: string; // Current model name for context window lookup\n  // Intelligent compaction settings\n  enableIntelligentCompaction?: boolean; // Auto-detect optimal compaction points (default: true)\n  compactionThreshold?: number; // Token % to start looking for compaction points (default: 0.5)\n  minSignalConfidence?: number; // Minimum confidence to trigger compaction (default: 0.6)\n  taskBoundaryPatterns?: string[]; // Custom patterns indicating task completion\n  topicShiftSensitivity?: number; // 0-1, how sensitive to topic changes (default: 0.7)\n  // AI Flow Pattern Detection\n  enableAIFlowPatternDetection?: boolean; // Detect AI software engineering patterns (default: true)\n  aiFlowPatterns?: AIFlowPattern[]; // Custom AI flow patterns for context optimization\n}\n\n/**\n * Pre-defined AI Flow Patterns for intelligent context management\n */\nexport const DEFAULT_AI_FLOW_PATTERNS: AIFlowPattern[] = [\n  {\n    patternId: 'read_edit_workflow',\n    description: 'Standard file modification workflow',\n    toolSequence: ['read', 'edit'],\n    contextImpact: 1500,\n    compactionOpportunity: true,\n    preservationPriority: 8,\n  },\n  {\n    patternId: 'analysis_phase',\n    description: 'Code analysis and exploration phase',\n    toolSequence: ['read', 'grep', 'glob', 'search'],\n    contextImpact: 3000,\n    compactionOpportunity: true,\n    preservationPriority: 6,\n  },\n  {\n    patternId: 'implementation_phase',\n    description: 'Active code implementation phase',\n    toolSequence: ['edit', 'write'],\n    contextImpact: 2000,\n    compactionOpportunity: false, // Preserve implementation context\n    preservationPriority: 9,\n  },\n  {\n    patternId: 'validation_phase',\n    description: 'Code validation and testing phase',\n    toolSequence: ['run_tests', 'run_build', 'run_repo_checks'],\n    contextImpact: 1000,\n    compactionOpportunity: true,\n    preservationPriority: 5,\n  },\n  {\n    patternId: 'parallel_execution',\n    description: 'Efficient parallel tool usage',\n    toolSequence: ['read', 'read', 'read'], // Multiple parallel reads\n    contextImpact: 2500,\n    compactionOpportunity: true,\n    preservationPriority: 7,\n  },\n  {\n    patternId: 'git_workflow',\n    description: 'Git operations workflow',\n    toolSequence: ['git_smart_commit', 'git_sync', 'git_create_pr'],\n    contextImpact: 1200,\n    compactionOpportunity: true,\n    preservationPriority: 6,\n  },\n];\n\nexport interface TruncationResult {\n  content: string;\n  wasTruncated: boolean;\n  originalLength: number;\n  truncatedLength: number;\n}\n\nexport class ContextManager {\n  private config: ContextManagerConfig;\n\n  private sessionStartTime: number = Date.now();\n  private toolCallHistory: string[] = [];\n\n  constructor(config: Partial<ContextManagerConfig> = {}) {\n    this.config = {\n      maxTokens: 130000, // Leave room below 131072 limit\n      targetTokens: 100000, // Target to trigger pruning\n      maxToolOutputLength: 10000, // 10k chars max per tool output\n      preserveRecentMessages: 10, // Keep last 10 user/assistant exchanges\n      estimatedCharsPerToken: 4,\n      ...config,\n    };\n  }\n\n  /**\n   * Record a tool call for context-aware summarization\n   */\n  recordToolCall(toolName: string): void {\n    this.toolCallHistory.push(toolName);\n    // Keep only recent history\n    if (this.toolCallHistory.length > 50) {\n      this.toolCallHistory.shift();\n    }\n  }\n\n  /**\n   * Truncate tool output intelligently using the smart summarizer\n   */\n  truncateToolOutput(output: string, toolName: string, _args?: Record<string, unknown>): TruncationResult {\n    const originalLength = output.length;\n\n    // First check if we even need to truncate\n    if (originalLength <= this.config.maxToolOutputLength) {\n      return {\n        content: output,\n        wasTruncated: false,\n        originalLength,\n        truncatedLength: originalLength,\n      };\n    }\n\n    // Intelligent truncation based on tool type\n    const truncated = this.intelligentTruncate(output, toolName);\n    const truncatedLength = truncated.length;\n\n    return {\n      content: truncated,\n      wasTruncated: true,\n      originalLength,\n      truncatedLength,\n    };\n  }\n\n  /**\n   * Intelligent truncation based on tool type\n   */\n  private intelligentTruncate(output: string, toolName: string): string {\n    const maxLength = this.config.maxToolOutputLength;\n\n    // For file reads, show beginning and end\n    if (toolName === 'Read' || toolName === 'read_file') {\n      return this.truncateFileOutput(output, maxLength);\n    }\n\n    // For search results, keep first N results\n    if (toolName === 'Grep' || toolName === 'grep_search' || toolName === 'Glob') {\n      return this.truncateSearchOutput(output, maxLength);\n    }\n\n    // For bash/command output, keep end (usually most relevant)\n    if (toolName === 'Bash' || toolName === 'bash' || toolName === 'execute_bash') {\n      return this.truncateBashOutput(output, maxLength);\n    }\n\n    // Default: show beginning with truncation notice\n    return this.truncateDefault(output, maxLength);\n  }\n\n  private truncateFileOutput(output: string, maxLength: number): string {\n    const lines = output.split('\\n');\n    if (lines.length <= 100) {\n      // For small files, just truncate text\n      return this.truncateDefault(output, maxLength);\n    }\n\n    // Show first 50 and last 50 lines\n    const keepLines = Math.floor(maxLength / 100); // Rough estimate\n    const headLines = lines.slice(0, keepLines);\n    const tailLines = lines.slice(-keepLines);\n\n    const truncatedCount = lines.length - (keepLines * 2);\n\n    return [\n      ...headLines,\n      `\\n... [${truncatedCount} lines truncated for context management] ...\\n`,\n      ...tailLines,\n    ].join('\\n');\n  }\n\n  private truncateSearchOutput(output: string, maxLength: number): string {\n    const lines = output.split('\\n');\n    const keepLines = Math.floor(maxLength / 80); // Rough average line length\n\n    if (lines.length <= keepLines) {\n      return output;\n    }\n\n    const truncatedCount = lines.length - keepLines;\n    return [\n      ...lines.slice(0, keepLines),\n      `\\n... [${truncatedCount} more results truncated for context management] ...`,\n    ].join('\\n');\n  }\n\n  private truncateBashOutput(output: string, maxLength: number): string {\n    if (output.length <= maxLength) {\n      return output;\n    }\n\n    // For command output, the end is usually most important (errors, final status)\n    const keepChars = Math.floor(maxLength * 0.8); // 80% at end\n    const prefixChars = maxLength - keepChars - 100; // Small prefix\n\n    const prefix = output.slice(0, prefixChars);\n    const suffix = output.slice(-keepChars);\n    const truncatedChars = output.length - prefixChars - keepChars;\n\n    return `${prefix}\\n\\n... [${truncatedChars} characters truncated for context management] ...\\n\\n${suffix}`;\n  }\n\n  private truncateDefault(output: string, maxLength: number): string {\n    if (output.length <= maxLength) {\n      return output;\n    }\n\n    const truncatedChars = output.length - maxLength + 100; // Account for notice\n    return `${output.slice(0, maxLength - 100)}\\n\\n... [${truncatedChars} characters truncated for context management] ...`;\n  }\n\n  /**\n   * Estimate tokens in a message\n   */\n  estimateTokens(message: ConversationMessage): number {\n    let charCount = 0;\n\n    if (message.content) {\n      charCount += message.content.length;\n    }\n\n    if (message.role === 'assistant' && message.toolCalls) {\n      // Tool calls add overhead\n      for (const call of message.toolCalls) {\n        charCount += call.name.length;\n        charCount += JSON.stringify(call.arguments).length;\n      }\n    }\n\n    return Math.ceil(charCount / this.config.estimatedCharsPerToken);\n  }\n\n  /**\n   * Detect context overflow risk from recent tool usage patterns\n   */\n  detectContextOverflowRisk(toolCalls: string[]): boolean {\n    const recentTools = toolCalls.slice(-10); // Last 10 tools\n    \n    // Check for broad search patterns without limits\n    const broadSearches = recentTools.filter(tool => \n      tool.includes('Glob') && !tool.includes('head_limit')\n    );\n    \n    // Check for multiple large file reads\n    const fileReads = recentTools.filter(tool => \n      tool.includes('Read') || tool.includes('read_file')\n    );\n    \n    // Check for redundant context_snapshot calls\n    const contextSnapshots = recentTools.filter(tool => \n      tool.includes('context_snapshot')\n    );\n    \n    // Risk threshold: 2+ broad searches OR 5+ file reads OR 1+ context_snapshot\n    return broadSearches.length >= 2 || \n           fileReads.length >= 5 || \n           contextSnapshots.length >= 1;\n  }\n\n  /**\n   * Estimate total tokens in conversation\n   */\n  estimateTotalTokens(messages: ConversationMessage[]): number {\n    return messages.reduce((sum, msg) => sum + this.estimateTokens(msg), 0);\n  }\n\n  /**\n   * Prune old messages when approaching limit\n   *\n   * Synchronously removes old messages to stay within budget.\n   * If LLM summarization is available and enabled, this method will be async.\n   */\n  pruneMessages(messages: ConversationMessage[]): {\n    pruned: ConversationMessage[];\n    removed: number;\n  } {\n    const totalTokens = this.estimateTotalTokens(messages);\n\n    // Only prune if we're above target\n    if (totalTokens < this.config.targetTokens) {\n      return { pruned: messages, removed: 0 };\n    }\n\n    // Always keep system message (first)\n    const firstMessage = messages[0];\n    const systemMessage = firstMessage?.role === 'system' ? firstMessage : null;\n    const conversationMessages = systemMessage ? messages.slice(1) : messages;\n\n    // Group messages into \"turns\" to maintain tool call/result pairing\n    // A turn is: [user] or [assistant + all its tool results]\n    const turns: ConversationMessage[][] = [];\n    let currentTurn: ConversationMessage[] = [];\n\n    for (const msg of conversationMessages) {\n      if (msg.role === 'user') {\n        if (currentTurn.length > 0) {\n          turns.push(currentTurn);\n        }\n        currentTurn = [msg];\n      } else if (msg.role === 'assistant') {\n        if (currentTurn.length > 0) {\n          turns.push(currentTurn);\n        }\n        currentTurn = [msg];\n      } else if (msg.role === 'tool') {\n        // Tool results belong with the current assistant turn\n        currentTurn.push(msg);\n      }\n    }\n    if (currentTurn.length > 0) {\n      turns.push(currentTurn);\n    }\n\n    // Keep recent turns based on preserveRecentMessages (count user turns)\n    const recentTurns: ConversationMessage[][] = [];\n    let exchangeCount = 0;\n\n    for (let i = turns.length - 1; i >= 0; i--) {\n      const turn = turns[i];\n      if (!turn || turn.length === 0) continue;\n\n      recentTurns.unshift(turn);\n\n      // Count user messages as exchanges\n      if (turn[0]?.role === 'user') {\n        exchangeCount++;\n        if (exchangeCount >= this.config.preserveRecentMessages) {\n          break;\n        }\n      }\n    }\n\n    // IMPORTANT: Ensure we don't start with orphaned tool messages\n    // The first kept turn must start with user or assistant (not tool)\n    let startIndex = 0;\n    while (startIndex < recentTurns.length) {\n      const firstTurn = recentTurns[startIndex];\n      if (firstTurn && firstTurn.length > 0 && firstTurn[0]?.role === 'tool') {\n        startIndex++;\n        continue;\n      }\n      // Also check for assistant turns with missing tool results\n      if (firstTurn && firstTurn[0]?.role === 'assistant') {\n        const assistantMsg = firstTurn[0];\n        if (assistantMsg.toolCalls && assistantMsg.toolCalls.length > 0) {\n          // PERF: Pre-compute tool call IDs once, use direct Set lookup\n          const toolCallIds = assistantMsg.toolCalls.map(tc => tc.id);\n          const presentToolResultIds = new Set(\n            firstTurn.filter(m => m.role === 'tool').map(m => (m as { toolCallId?: string }).toolCallId)\n          );\n          // If NOT all tool calls have results, skip this turn\n          // PERF: Direct has() calls instead of spread + every()\n          let allPresent = true;\n          for (const id of toolCallIds) {\n            if (!presentToolResultIds.has(id)) {\n              allPresent = false;\n              break;\n            }\n          }\n          if (!allPresent) {\n            startIndex++;\n            continue;\n          }\n        }\n      }\n      break;\n    }\n\n    const validTurns = recentTurns.slice(startIndex);\n\n    // Flatten turns back to messages\n    const recentMessages = validTurns.flat();\n\n    // Build pruned message list\n    const pruned: ConversationMessage[] = [];\n    if (systemMessage) {\n      pruned.push(systemMessage);\n    }\n\n    // Add a context summary message if we removed messages\n    const removedCount = conversationMessages.length - recentMessages.length;\n    if (removedCount > 0) {\n      pruned.push({\n        role: 'system',\n        content: `[Context Manager: Removed ${removedCount} old messages to stay within token budget. Recent conversation history preserved.]`,\n      });\n    }\n\n    pruned.push(...recentMessages);\n\n    return {\n      pruned,\n      removed: removedCount,\n    };\n  }\n\n  /**\n   * Prune messages with LLM-based summarization\n   *\n   * This is an async version that uses the LLM to create intelligent summaries\n   * instead of just removing old messages. Should be called BEFORE generation.\n   */\n  async pruneMessagesWithSummary(\n    messages: ConversationMessage[],\n    options?: { force?: boolean }\n  ): Promise<{\n    pruned: ConversationMessage[];\n    removed: number;\n    summarized: boolean;\n  }> {\n    const totalTokens = this.estimateTotalTokens(messages);\n\n    // Only prune if we're above target\n    if (!options?.force && totalTokens < this.config.targetTokens) {\n      return { pruned: messages, removed: 0, summarized: false };\n    }\n\n    // If no summarization callback or disabled, fall back to simple pruning\n    if (!this.config.summarizationCallback || !this.config.useLLMSummarization) {\n      const result = this.pruneMessages(messages);\n      return { ...result, summarized: false };\n    }\n\n    // Partition messages\n    const firstMessage = messages[0];\n    const systemMessage = firstMessage?.role === 'system' ? firstMessage : null;\n    const conversationMessages = systemMessage ? messages.slice(1) : messages;\n\n    // Group messages into \"turns\" to maintain tool call/result pairing\n    const turns: ConversationMessage[][] = [];\n    let currentTurn: ConversationMessage[] = [];\n\n    for (const msg of conversationMessages) {\n      if (msg.role === 'user') {\n        if (currentTurn.length > 0) {\n          turns.push(currentTurn);\n        }\n        currentTurn = [msg];\n      } else if (msg.role === 'assistant') {\n        if (currentTurn.length > 0) {\n          turns.push(currentTurn);\n        }\n        currentTurn = [msg];\n      } else if (msg.role === 'tool') {\n        currentTurn.push(msg);\n      }\n    }\n    if (currentTurn.length > 0) {\n      turns.push(currentTurn);\n    }\n\n    // Keep recent turns based on preserveRecentMessages\n    const recentTurns: ConversationMessage[][] = [];\n    let exchangeCount = 0;\n\n    for (let i = turns.length - 1; i >= 0; i--) {\n      const turn = turns[i];\n      if (!turn || turn.length === 0) continue;\n\n      recentTurns.unshift(turn);\n\n      if (turn[0]?.role === 'user') {\n        exchangeCount++;\n        if (exchangeCount >= this.config.preserveRecentMessages) {\n          break;\n        }\n      }\n    }\n\n    // Ensure we don't start with orphaned tool messages\n    let startIndex = 0;\n    while (startIndex < recentTurns.length) {\n      const firstTurn = recentTurns[startIndex];\n      if (firstTurn && firstTurn.length > 0 && firstTurn[0]?.role === 'tool') {\n        startIndex++;\n        continue;\n      }\n      if (firstTurn && firstTurn[0]?.role === 'assistant') {\n        const assistantMsg = firstTurn[0];\n        if (assistantMsg.toolCalls && assistantMsg.toolCalls.length > 0) {\n          // PERF: Pre-compute tool call IDs once, use direct Set lookup\n          const toolCallIds = assistantMsg.toolCalls.map(tc => tc.id);\n          const presentToolResultIds = new Set(\n            firstTurn.filter(m => m.role === 'tool').map(m => (m as { toolCallId?: string }).toolCallId)\n          );\n          // PERF: Direct has() calls instead of spread + every()\n          let allPresent = true;\n          for (const id of toolCallIds) {\n            if (!presentToolResultIds.has(id)) {\n              allPresent = false;\n              break;\n            }\n          }\n          if (!allPresent) {\n            startIndex++;\n            continue;\n          }\n        }\n      }\n      break;\n    }\n\n    const validTurns = recentTurns.slice(startIndex);\n    const recentMessages = validTurns.flat();\n\n    // Determine which turns to summarize\n    const keepTurnCount = validTurns.length;\n    const summarizeTurns = turns.slice(0, turns.length - keepTurnCount - startIndex);\n    const toSummarize = summarizeTurns.flat();\n\n    // If nothing to summarize, return as-is\n    if (toSummarize.length === 0) {\n      return { pruned: messages, removed: 0, summarized: false };\n    }\n\n    try {\n      // Call the LLM to summarize old messages\n      const summary = await this.config.summarizationCallback(toSummarize);\n\n      // Build pruned message list with summary\n      const pruned: ConversationMessage[] = [];\n      if (systemMessage) {\n        pruned.push(systemMessage);\n      }\n\n      // Add intelligent summary\n      pruned.push({\n        role: 'system',\n        content: [\n          '=== Context Summary (Auto-generated) ===',\n          summary.trim(),\n          '',\n          `[Summarized ${toSummarize.length} earlier messages. Recent ${recentMessages.length} messages preserved below.]`,\n        ].join('\\n'),\n      });\n\n      pruned.push(...recentMessages);\n\n      return {\n        pruned,\n        removed: toSummarize.length,\n        summarized: true,\n      };\n    } catch (error) {\n      // If summarization fails, fall back to simple pruning\n      const result = this.pruneMessages(messages);\n      return { ...result, summarized: false };\n    }\n  }\n\n  /**\n   * Check if we're approaching the limit\n   */\n  isApproachingLimit(messages: ConversationMessage[]): boolean {\n    const totalTokens = this.estimateTotalTokens(messages);\n    return totalTokens >= this.config.targetTokens;\n  }\n\n  /**\n   * Get warning level for current context usage\n   * Returns: null (no warning), 'info' (<70%), 'warning' (70-90%), 'danger' (>90%)\n   */\n  getWarningLevel(messages: ConversationMessage[]): 'info' | 'warning' | 'danger' | null {\n    const totalTokens = this.estimateTotalTokens(messages);\n    const percentage = (totalTokens / this.config.maxTokens) * 100;\n\n    if (percentage > 90) {\n      return 'danger';\n    } else if (percentage > 70) {\n      return 'warning';\n    } else if (percentage > 50) {\n      return 'info';\n    }\n\n    return null;\n  }\n\n  /**\n   * Get a human-readable warning message\n   */\n  getWarningMessage(messages: ConversationMessage[]): string | null {\n    const stats = this.getStats(messages);\n    const warningLevel = this.getWarningLevel(messages);\n\n    if (warningLevel === 'danger') {\n      return `⚠️ Context usage critical (${stats.percentage}%). Consider starting a new session or the next request may fail.`;\n    } else if (warningLevel === 'warning') {\n      return `Context usage high (${stats.percentage}%). Automatic cleanup will occur soon.`;\n    }\n\n    return null;\n  }\n\n  /**\n   * Get context stats\n   */\n  getStats(messages: ConversationMessage[]): {\n    totalTokens: number;\n    percentage: number;\n    isOverLimit: boolean;\n    isApproachingLimit: boolean;\n  } {\n    const totalTokens = this.estimateTotalTokens(messages);\n    const percentage = Math.round((totalTokens / this.config.maxTokens) * 100);\n\n    return {\n      totalTokens,\n      percentage,\n      isOverLimit: totalTokens >= this.config.maxTokens,\n      isApproachingLimit: totalTokens >= this.config.targetTokens,\n    };\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(config: Partial<ContextManagerConfig>): void {\n    this.config = { ...this.config, ...config };\n  }\n\n  // ============================================================================\n  // INTELLIGENT COMPACTION SYSTEM\n  // Automatically detects optimal points for conversation compaction\n  // ============================================================================\n\n  /**\n   * Default patterns that indicate task boundaries\n   */\n  private static readonly DEFAULT_TASK_BOUNDARY_PATTERNS = [\n    // Completion indicators\n    /\\b(done|completed|finished|fixed|resolved|implemented|added|created|updated)\\b/i,\n    /\\b(all\\s+(?:tests?\\s+)?pass(?:ing|ed)?)\\b/i,\n    /\\b(successfully|works?\\s+(?:now|correctly))\\b/i,\n    // Transition indicators\n    /\\b(next|now\\s+(?:let's|we\\s+can)|moving\\s+on)\\b/i,\n    /\\b(that's\\s+(?:it|all|done))\\b/i,\n    // Acknowledgment patterns\n    /^(?:great|perfect|thanks|thank\\s+you|got\\s+it|understood)\\b/i,\n  ];\n\n  /**\n   * Patterns indicating topic/task shifts\n   */\n  private static readonly TOPIC_SHIFT_PATTERNS = [\n    /\\b(different|another|new|separate|unrelated)\\s+(?:task|thing|topic|issue|question)\\b/i,\n    /\\b(can\\s+you|could\\s+you|please|now|let's)\\s+(?:also|help|do|make|create|fix|add)\\b/i,\n    /\\b(switching|changing|moving)\\s+to\\b/i,\n    /\\b(forget|ignore|never\\s*mind)\\s+(?:that|the|about)\\b/i,\n    /^(?:ok|okay|alright|anyway|so)\\s*[,.]?\\s*(?:can|could|now|let|please)/i,\n  ];\n\n  /**\n   * Patterns indicating user pivots (abandoning current direction)\n   */\n  private static readonly USER_PIVOT_PATTERNS = [\n    /\\b(actually|wait|hold\\s+on|stop|cancel|scratch\\s+that)\\b/i,\n    /\\b(let's\\s+(?:try|do)\\s+(?:something|it)\\s+(?:else|differently))\\b/i,\n    /\\b(go\\s+back|revert|undo|start\\s+over)\\b/i,\n    /\\b(wrong|not\\s+(?:what|right)|that's\\s+not)\\b/i,\n  ];\n\n  /**\n   * Analyze the conversation to detect intelligent compaction points\n   */\n  analyzeCompactionPoints(messages: ConversationMessage[]): CompactionAnalysis {\n    const signals: CompactionSignal[] = [];\n    const totalTokens = this.estimateTotalTokens(messages);\n    const tokenPercentage = totalTokens / this.config.maxTokens;\n    const compactionThreshold = this.config.compactionThreshold ?? 0.5;\n    const minConfidence = this.config.minSignalConfidence ?? 0.6;\n\n    // Don't analyze if below threshold\n    if (tokenPercentage < compactionThreshold) {\n      return {\n        shouldCompact: false,\n        signals: [],\n        recommendedCompactionPoint: null,\n        urgency: 'none',\n        preserveFromIndex: 0,\n      };\n    }\n\n    // Analyze each message for compaction signals\n    for (let i = 0; i < messages.length; i++) {\n      const msg = messages[i];\n      if (!msg) continue;\n\n      // Detect task boundaries\n      const taskBoundary = this.detectTaskBoundary(msg, i, messages);\n      if (taskBoundary && taskBoundary.confidence >= minConfidence) {\n        signals.push(taskBoundary);\n      }\n\n      // Detect topic shifts\n      const topicShift = this.detectTopicShift(msg, i, messages);\n      if (topicShift && topicShift.confidence >= minConfidence) {\n        signals.push(topicShift);\n      }\n\n      // Detect user pivots\n      const userPivot = this.detectUserPivot(msg, i);\n      if (userPivot && userPivot.confidence >= minConfidence) {\n        signals.push(userPivot);\n      }\n\n      // Detect context saturation (tool output heavy regions)\n      const saturation = this.detectContextSaturation(msg, i, messages);\n      if (saturation && saturation.confidence >= minConfidence) {\n        signals.push(saturation);\n      }\n\n      // Detect milestones\n      const milestone = this.detectMilestone(msg, i, messages);\n      if (milestone && milestone.confidence >= minConfidence) {\n        signals.push(milestone);\n      }\n    }\n\n    // Determine urgency based on token percentage\n    const urgency = this.calculateUrgency(tokenPercentage);\n\n    // Find the best compaction point\n    const recommendedPoint = this.findBestCompactionPoint(signals, messages, urgency);\n\n    // Calculate preserve index (everything after this should be kept)\n    const preserveFromIndex = recommendedPoint !== null\n      ? this.findSafePreservePoint(recommendedPoint, messages)\n      : messages.length;\n\n    return {\n      shouldCompact: signals.length > 0 && urgency !== 'none',\n      signals,\n      recommendedCompactionPoint: recommendedPoint,\n      urgency,\n      preserveFromIndex,\n    };\n  }\n\n  /**\n   * Detect task boundary signals\n   */\n  private detectTaskBoundary(\n    msg: ConversationMessage,\n    index: number,\n    messages: ConversationMessage[]\n  ): CompactionSignal | null {\n    if (msg.role !== 'user' && msg.role !== 'assistant') return null;\n\n    const content = msg.content || '';\n    const patterns = this.config.taskBoundaryPatterns\n      ? this.config.taskBoundaryPatterns.map(p => new RegExp(p, 'i'))\n      : ContextManager.DEFAULT_TASK_BOUNDARY_PATTERNS;\n\n    let matchCount = 0;\n    const reasons: string[] = [];\n\n    for (const pattern of patterns) {\n      if (pattern.test(content)) {\n        matchCount++;\n        reasons.push(pattern.source.slice(0, 30));\n      }\n    }\n\n    if (matchCount === 0) return null;\n\n    // Higher confidence if followed by a new user message with different intent\n    let confidence = Math.min(0.4 + matchCount * 0.2, 0.9);\n\n    // Boost confidence if this looks like a conclusion\n    if (msg.role === 'assistant' && this.looksLikeConclusion(content)) {\n      confidence = Math.min(confidence + 0.2, 0.95);\n    }\n\n    // Boost if next user message starts a new topic\n    const nextUserMsg = messages.slice(index + 1).find(m => m.role === 'user');\n    if (nextUserMsg && this.isNewTopic(content, nextUserMsg.content || '')) {\n      confidence = Math.min(confidence + 0.15, 0.95);\n    }\n\n    return {\n      type: 'task_boundary',\n      confidence,\n      messageIndex: index,\n      reason: `Task completion detected: ${reasons.slice(0, 2).join(', ')}`,\n    };\n  }\n\n  /**\n   * Detect topic shift signals\n   */\n  private detectTopicShift(\n    msg: ConversationMessage,\n    index: number,\n    messages: ConversationMessage[]\n  ): CompactionSignal | null {\n    if (msg.role !== 'user') return null;\n\n    const content = msg.content || '';\n    const sensitivity = this.config.topicShiftSensitivity ?? 0.7;\n\n    // Check explicit shift patterns\n    for (const pattern of ContextManager.TOPIC_SHIFT_PATTERNS) {\n      if (pattern.test(content)) {\n        return {\n          type: 'topic_shift',\n          confidence: 0.7 + sensitivity * 0.2,\n          messageIndex: index,\n          reason: 'Explicit topic shift language detected',\n        };\n      }\n    }\n\n    // Check semantic shift from previous context\n    const prevMessages = messages.slice(Math.max(0, index - 5), index);\n    const prevContent = prevMessages\n      .filter(m => m.role === 'user' || m.role === 'assistant')\n      .map(m => m.content || '')\n      .join(' ');\n\n    if (prevContent && this.isNewTopic(prevContent, content)) {\n      return {\n        type: 'topic_shift',\n        confidence: 0.6 + sensitivity * 0.2,\n        messageIndex: index,\n        reason: 'Semantic topic shift detected',\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * Detect user pivot signals (abandoning current direction)\n   */\n  private detectUserPivot(msg: ConversationMessage, index: number): CompactionSignal | null {\n    if (msg.role !== 'user') return null;\n\n    const content = msg.content || '';\n\n    for (const pattern of ContextManager.USER_PIVOT_PATTERNS) {\n      if (pattern.test(content)) {\n        return {\n          type: 'user_pivot',\n          confidence: 0.85,\n          messageIndex: index,\n          reason: 'User pivot/direction change detected',\n        };\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Detect context saturation (heavy tool output regions)\n   */\n  private detectContextSaturation(\n    msg: ConversationMessage,\n    index: number,\n    messages: ConversationMessage[]\n  ): CompactionSignal | null {\n    if (msg.role !== 'tool') return null;\n\n    // Look at the surrounding region\n    const windowStart = Math.max(0, index - 10);\n    const windowEnd = Math.min(messages.length, index + 5);\n    const window = messages.slice(windowStart, windowEnd);\n\n    // Count tool messages and their sizes\n    let toolCount = 0;\n    let totalToolSize = 0;\n\n    for (const m of window) {\n      if (m.role === 'tool') {\n        toolCount++;\n        totalToolSize += (m.content || '').length;\n      }\n    }\n\n    // High saturation if many tool outputs with large content\n    if (toolCount >= 5 && totalToolSize > 20000) {\n      // Find the last tool message in this cluster as compaction point\n      let lastToolIndex = index;\n      for (let i = index + 1; i < windowEnd; i++) {\n        if (messages[i]?.role === 'tool') {\n          lastToolIndex = i;\n        } else if (messages[i]?.role === 'user') {\n          break; // Stop at next user message\n        }\n      }\n\n      return {\n        type: 'context_saturation',\n        confidence: Math.min(0.5 + toolCount * 0.05, 0.85),\n        messageIndex: lastToolIndex,\n        reason: `Heavy tool output region (${toolCount} tools, ${Math.round(totalToolSize / 1000)}k chars)`,\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * Detect milestone signals (significant accomplishments)\n   */\n  private detectMilestone(\n    msg: ConversationMessage,\n    index: number,\n    _messages: ConversationMessage[]\n  ): CompactionSignal | null {\n    if (msg.role !== 'assistant') return null;\n\n    const content = msg.content || '';\n\n    // Look for milestone indicators\n    const milestonePatterns = [\n      /\\b(commit(?:ted)?|pushed|deployed|merged|released)\\b/i,\n      /\\b(all\\s+tests?\\s+pass(?:ing|ed)?)\\b/i,\n      /\\b(build\\s+(?:succeed|success|pass))\\b/i,\n      /\\b(feature\\s+(?:complete|done|ready))\\b/i,\n      /\\b(pr\\s+(?:created|opened|merged))\\b/i,\n    ];\n\n    for (const pattern of milestonePatterns) {\n      if (pattern.test(content)) {\n        return {\n          type: 'milestone',\n          confidence: 0.9,\n          messageIndex: index,\n          reason: 'Significant milestone achieved',\n        };\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Check if content looks like a task conclusion\n   */\n  private looksLikeConclusion(content: string): boolean {\n    const conclusionPatterns = [\n      /\\b(let\\s+me\\s+know|feel\\s+free|if\\s+you\\s+(?:need|have|want))\\b/i,\n      /\\b(anything\\s+else|other\\s+questions?)\\b/i,\n      /\\b(should\\s+be\\s+(?:good|working|ready|done))\\b/i,\n      /\\b(that\\s+should|this\\s+(?:should|will))\\s+(?:fix|solve|work)/i,\n    ];\n\n    return conclusionPatterns.some(p => p.test(content));\n  }\n\n  /**\n   * Check if two contents represent different topics (simple heuristic)\n   */\n  private isNewTopic(prevContent: string, newContent: string): boolean {\n    // Extract key terms (simple tokenization)\n    const extractTerms = (text: string): Set<string> => {\n      const words = text.toLowerCase()\n        .replace(/[^a-z0-9\\s]/g, ' ')\n        .split(/\\s+/)\n        .filter(w => w.length > 3);\n      return new Set(words);\n    };\n\n    const prevTerms = extractTerms(prevContent);\n    const newTerms = extractTerms(newContent);\n\n    if (prevTerms.size === 0 || newTerms.size === 0) return false;\n\n    // Calculate overlap\n    let overlap = 0;\n    for (const term of newTerms) {\n      if (prevTerms.has(term)) overlap++;\n    }\n\n    const overlapRatio = overlap / Math.min(prevTerms.size, newTerms.size);\n\n    // Low overlap suggests new topic\n    return overlapRatio < 0.2;\n  }\n\n  /**\n   * Calculate urgency level based on token percentage\n   */\n  private calculateUrgency(tokenPercentage: number): 'none' | 'low' | 'medium' | 'high' | 'critical' {\n    if (tokenPercentage >= 0.9) return 'critical';\n    if (tokenPercentage >= 0.75) return 'high';\n    if (tokenPercentage >= 0.6) return 'medium';\n    if (tokenPercentage >= 0.5) return 'low';\n    return 'none';\n  }\n\n  /**\n   * Find the best compaction point from signals\n   */\n  private findBestCompactionPoint(\n    signals: CompactionSignal[],\n    messages: ConversationMessage[],\n    urgency: 'none' | 'low' | 'medium' | 'high' | 'critical'\n  ): number | null {\n    if (signals.length === 0) return null;\n\n    // Score each signal based on type priority and confidence\n    const typePriority: Record<CompactionSignal['type'], number> = {\n      milestone: 1.0,\n      task_boundary: 0.9,\n      user_pivot: 0.85,\n      ai_flow_pattern: 0.82, // AI flow patterns like thinking/tool use cycles\n      topic_shift: 0.8,\n      context_saturation: 0.7,\n    };\n\n    // Urgency affects how far back we're willing to compact\n    const urgencyDepth: Record<string, number> = {\n      none: 0,\n      low: 0.3, // Compact only recent 30%\n      medium: 0.5,\n      high: 0.7,\n      critical: 0.9,\n    };\n\n    const maxDepth = urgencyDepth[urgency] ?? 0.5;\n    const minIndex = Math.floor(messages.length * (1 - maxDepth));\n\n    // Find highest scoring signal within allowed depth\n    let bestSignal: CompactionSignal | null = null;\n    let bestScore = 0;\n\n    for (const signal of signals) {\n      if (signal.messageIndex < minIndex) continue;\n\n      const score = signal.confidence * typePriority[signal.type];\n      if (score > bestScore) {\n        bestScore = score;\n        bestSignal = signal;\n      }\n    }\n\n    return bestSignal?.messageIndex ?? null;\n  }\n\n  /**\n   * Find a safe preservation point that doesn't break tool call chains\n   */\n  private findSafePreservePoint(compactionPoint: number, messages: ConversationMessage[]): number {\n    // Start from compaction point and move forward to find a safe break\n    for (let i = compactionPoint + 1; i < messages.length; i++) {\n      const msg = messages[i];\n      if (!msg) continue;\n\n      // Safe if it's a user message\n      if (msg.role === 'user') {\n        return i;\n      }\n\n      // Safe if it's an assistant without pending tool calls\n      if (msg.role === 'assistant' && !msg.toolCalls?.length) {\n        return i;\n      }\n    }\n\n    // If no safe point found, keep more messages\n    return Math.min(compactionPoint + 1, messages.length);\n  }\n\n  /**\n   * Perform intelligent compaction based on analysis\n   * This method analyzes the conversation and compacts at the optimal point\n   */\n  async intelligentCompact(messages: ConversationMessage[]): Promise<{\n    compacted: ConversationMessage[];\n    analysis: CompactionAnalysis;\n    summarized: boolean;\n  }> {\n    // Analyze for compaction points\n    const analysis = this.analyzeCompactionPoints(messages);\n\n    // If no compaction needed or no good point found\n    if (!analysis.shouldCompact || analysis.recommendedCompactionPoint === null) {\n      return {\n        compacted: messages,\n        analysis,\n        summarized: false,\n      };\n    }\n\n    // Separate messages to summarize and preserve\n    const firstMessage = messages[0];\n    const systemMessage = firstMessage?.role === 'system' ? firstMessage : null;\n    const startIndex = systemMessage ? 1 : 0;\n\n    const toSummarize = messages.slice(startIndex, analysis.preserveFromIndex);\n    const toPreserve = messages.slice(analysis.preserveFromIndex);\n\n    // If nothing to summarize, return as-is\n    if (toSummarize.length === 0) {\n      return {\n        compacted: messages,\n        analysis,\n        summarized: false,\n      };\n    }\n\n    // Build result\n    const compacted: ConversationMessage[] = [];\n    if (systemMessage) {\n      compacted.push(systemMessage);\n    }\n\n    // Try LLM summarization if available\n    if (this.config.summarizationCallback && this.config.useLLMSummarization !== false) {\n      try {\n        const summary = await this.config.summarizationCallback(toSummarize);\n\n        compacted.push({\n          role: 'system',\n          content: [\n            '=== Intelligent Context Summary ===',\n            `Compaction triggered: ${analysis.signals[0]?.reason || 'Context optimization'}`,\n            '',\n            summary.trim(),\n            '',\n            `[Summarized ${toSummarize.length} messages. ${toPreserve.length} recent messages preserved.]`,\n          ].join('\\n'),\n        });\n\n        compacted.push(...toPreserve);\n\n        return {\n          compacted,\n          analysis,\n          summarized: true,\n        };\n      } catch {\n        // Fall through to simple compaction\n      }\n    }\n\n    // Simple compaction without LLM\n    compacted.push({\n      role: 'system',\n      content: `[Context Manager: Intelligently compacted ${toSummarize.length} messages at \"${analysis.signals[0]?.reason || 'optimal point'}\". ${toPreserve.length} recent messages preserved.]`,\n    });\n\n    compacted.push(...toPreserve);\n\n    return {\n      compacted,\n      analysis,\n      summarized: false,\n    };\n  }\n\n  /**\n   * Check if intelligent compaction should be triggered\n   * Call this before generation to proactively manage context\n   */\n  shouldTriggerCompaction(messages: ConversationMessage[]): {\n    shouldCompact: boolean;\n    urgency: CompactionAnalysis['urgency'];\n    reason: string | null;\n  } {\n    if (this.config.enableIntelligentCompaction === false) {\n      return { shouldCompact: false, urgency: 'none', reason: null };\n    }\n\n    const analysis = this.analyzeCompactionPoints(messages);\n\n    if (!analysis.shouldCompact) {\n      return { shouldCompact: false, urgency: analysis.urgency, reason: null };\n    }\n\n    const topSignal = analysis.signals\n      .sort((a, b) => b.confidence - a.confidence)[0];\n\n    return {\n      shouldCompact: true,\n      urgency: analysis.urgency,\n      reason: topSignal?.reason || 'Context optimization recommended',\n    };\n  }\n}\n\n/**\n * Create a default context manager instance with model-aware limits\n */\nexport function createDefaultContextManager(\n  overrides?: Partial<ContextManagerConfig>,\n  model?: string\n): ContextManager {\n  // Get model-specific thresholds\n  const thresholds = calculateContextThresholds(model);\n\n  return new ContextManager({\n    maxTokens: thresholds.maxTokens,\n    targetTokens: thresholds.targetTokens,  // Start pruning at 60%\n    warningTokens: thresholds.warningTokens,  // Warn at 50%\n    criticalTokens: thresholds.criticalTokens,  // Critical at 75%\n    maxToolOutputLength: 5000, // 5k chars max per tool (reduced for safety)\n    preserveRecentMessages: 5, // Keep last 5 exchanges\n    estimatedCharsPerToken: 3.5, // More aggressive estimate (accounts for special tokens, JSON overhead)\n    useLLMSummarization: true, // Enable LLM summarization by default\n    // Intelligent compaction defaults\n    enableIntelligentCompaction: true,\n    compactionThreshold: 0.5, // Start analyzing at 50% context usage\n    minSignalConfidence: 0.6, // Require 60% confidence for compaction signals\n    topicShiftSensitivity: 0.7, // Moderately sensitive to topic changes\n    model,\n    ...overrides,\n  });\n}\n\n/**\n * Format conversation messages into readable text for summarization\n */\nexport function formatMessagesForSummary(messages: ConversationMessage[]): string {\n  const lines: string[] = [];\n\n  for (const msg of messages) {\n    if (msg.role === 'user') {\n      lines.push(`USER: ${msg.content}`);\n    } else if (msg.role === 'assistant') {\n      let content = msg.content || '';\n      if (msg.toolCalls && msg.toolCalls.length > 0) {\n        const toolNames = msg.toolCalls.map(tc => tc.name);\n        content += ` [Called tools: ${toolNames.join(', ')}]`;\n      }\n      lines.push(`ASSISTANT: ${content}`);\n    } else if (msg.role === 'tool') {\n      // Truncate long tool outputs for summarization\n      const output = msg.content.length > 500\n        ? `${msg.content.slice(0, 500)  }...`\n        : msg.content;\n      lines.push(`TOOL (${msg.name}): ${output}`);\n    }\n    // Skip system messages in summary input\n  }\n\n  return lines.join('\\n\\n');\n}\n\n/**\n * Create a summarization callback using the given provider\n */\nexport function createSummarizationCallback(\n  provider: { generate: (messages: ConversationMessage[], tools: unknown[]) => Promise<{ content?: string }> }\n): SummarizationCallback {\n  return async (messages: ConversationMessage[]): Promise<string> => {\n    // Format messages into readable conversation\n    const conversationText = formatMessagesForSummary(messages);\n\n    // Create summarization prompt\n    const prompt = SUMMARIZATION_PROMPT.replace('{conversation}', conversationText);\n\n    // Call provider to generate summary (no tools needed)\n    const response = await provider.generate(\n      [{ role: 'user', content: prompt }],\n      []\n    );\n\n    return response.content || '';\n  };\n}\n"],"mappings":"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","ignoreList":[]}