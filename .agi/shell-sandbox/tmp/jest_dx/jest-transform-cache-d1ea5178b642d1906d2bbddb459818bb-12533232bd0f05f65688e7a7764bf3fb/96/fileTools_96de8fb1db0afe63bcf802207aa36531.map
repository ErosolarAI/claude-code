{"version":3,"names":["_nodeFs","require","_promises","_nodePath","_errors","_asyncUtils","MAX_FILE_SIZE","DEFAULT_SEARCH_HEAD_LIMIT","createFileTools","workingDir","name","description","parameters","type","properties","path","minLength","offset","limit","required","additionalProperties","handler","args","result","readFileWithLineNumbers","output","paths","minItems","items","concurrency","pathsArg","Array","isArray","length","sanitizedPaths","filter","value","map","trim","Boolean","concurrencyArg","Math","floor","min","max","offsetArg","limitArg","results","parallelMap","header","body","join","cacheable","cacheTtlMs","recursive","pathArg","requestedPath","normalizePathContext","resolvedPath","dirPath","undefined","resolveFilePath","existsSync","files","listFilesRecursive","error","buildError","pattern","head_limit","patternArg","requestedPattern","headLimitArg","headLimit","Number","isFinite","searchPath","searchFilesGlob","sort","limited","slice","truncated","headerParts","f","relative","validated","validatePathArg","startsWith","Error","String","dir","maxDepth","baseDir","currentDepth","ignoredDirs","Set","entries","readdirSync","withFileTypes","entry","has","fullPath","indent","repeat","isDirectory","push","stats","statSync","size","formatFileSize","regex","globToRegex","search","currentDir","test","escaped","replace","RegExp","bytes","toFixed","filePath","fileStats","stat","content","readFile","lines","split","totalLines","startLine","endLine","normalizeReadWindow","selectedLines","numberedLines","line","idx","lineNum","padStart","showingRange","rangeInfo","defaultLimit"],"sources":["fileTools.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { existsSync, readdirSync, statSync } from 'node:fs';\nimport { readFile, stat } from 'node:fs/promises';\nimport { join, relative } from 'node:path';\nimport type { ToolDefinition } from '../core/toolRuntime.js';\nimport { buildError } from '../core/errors.js';\nimport { parallelMap } from '../utils/asyncUtils.js';\n\n// Maximum file size to read (10MB) to prevent memory exhaustion\nconst MAX_FILE_SIZE = 10 * 1024 * 1024;\nconst DEFAULT_SEARCH_HEAD_LIMIT = 50;\n\ninterface FormattedReadResult {\n  filePath?: string;\n  output: string;\n}\n\nexport function createFileTools(workingDir: string): ToolDefinition[] {\n  return [\n    {\n      name: 'read_file',\n      description: 'Read the contents of a file at the specified path. Returns content with line numbers. CRITICAL: ALWAYS use this tool BEFORE using Edit tool to get exact text including whitespace. Copy text directly from this output to old_string parameter in Edit. For large files, use offset and limit to read specific portions.',\n      parameters: {\n        type: 'object',\n        properties: {\n          path: {\n            type: 'string',\n            description: 'The file path (relative to working directory or absolute)',\n            minLength: 1,\n          },\n          offset: {\n            type: 'number',\n            description: 'Line number to start reading from (1-based). Defaults to 1.',\n          },\n          limit: {\n            type: 'number',\n            description: 'Maximum number of lines to read. Defaults to entire file (max 2000 lines for large files).',\n          },\n        },\n        required: ['path'],\n        additionalProperties: false,\n      },\n      handler: async (args) => {\n        const result = await readFileWithLineNumbers(workingDir, args['path'], args['offset'], args['limit']);\n        return result.output;\n      },\n    },\n    {\n      name: 'read_files',\n      description: 'Read multiple files in parallel with line numbers. Use this to avoid sequential read bottlenecks when inspecting several files.',\n      parameters: {\n        type: 'object',\n        properties: {\n          paths: {\n            type: 'array',\n            minItems: 1,\n            items: {\n              type: 'string',\n              minLength: 1,\n            },\n            description: 'List of file paths to read (relative or absolute)',\n          },\n          offset: {\n            type: 'number',\n            description: 'Optional starting line for all files (1-based).',\n          },\n          limit: {\n            type: 'number',\n            description: 'Optional max lines to read for each file.',\n          },\n          concurrency: {\n            type: 'number',\n            description: 'Maximum number of files to read concurrently (default: 5, max: 10).',\n          },\n        },\n        required: ['paths'],\n        additionalProperties: false,\n      },\n      handler: async (args) => {\n        const pathsArg = args['paths'];\n        if (!Array.isArray(pathsArg) || pathsArg.length === 0) {\n          return 'Error: paths must be a non-empty array of file paths.';\n        }\n\n        const sanitizedPaths = pathsArg\n          .filter((value): value is string => typeof value === 'string')\n          .map((value) => value.trim())\n          .filter(Boolean);\n\n        if (sanitizedPaths.length === 0) {\n          return 'Error: paths must contain at least one valid string path.';\n        }\n\n        const concurrencyArg = typeof args['concurrency'] === 'number' ? Math.floor(args['concurrency']) : 5;\n        const concurrency = Math.min(Math.max(concurrencyArg, 1), 10);\n        const offsetArg = args['offset'];\n        const limitArg = args['limit'];\n\n        const results = await parallelMap(\n          sanitizedPaths,\n          async (path) => readFileWithLineNumbers(workingDir, path, offsetArg, limitArg),\n          concurrency\n        );\n\n        const header = `Read ${results.length} file${results.length === 1 ? '' : 's'} in parallel (max ${concurrency} concurrent):`;\n        const body = results.map((result) => result.output).join('\\n\\n---\\n\\n');\n        return [header, body].join('\\n\\n');\n      },\n    },\n    {\n      name: 'list_files',\n      description: 'List files and directories at the specified path',\n      cacheable: true,\n      cacheTtlMs: 4000, // short TTL to avoid stale listings while cutting redundant calls\n      parameters: {\n        type: 'object',\n        properties: {\n          path: {\n            type: 'string',\n            description: 'The directory path (defaults to current working directory)',\n            minLength: 1,\n          },\n          recursive: {\n            type: 'boolean',\n            description: 'Whether to list files recursively',\n          },\n        },\n        additionalProperties: false,\n      },\n      handler: async (args) => {\n        const pathArg = args['path'];\n        const requestedPath = normalizePathContext(pathArg);\n        let resolvedPath: string | undefined;\n        try {\n          const dirPath =\n            pathArg !== undefined && pathArg !== null ? resolveFilePath(workingDir, pathArg) : workingDir;\n          resolvedPath = dirPath;\n          const recursive = args['recursive'] === true;\n\n          if (!existsSync(dirPath)) {\n            return `Error: Directory not found: ${dirPath}`;\n          }\n\n          const files = listFilesRecursive(dirPath, recursive ? 5 : 1, workingDir);\n          return `Directory: ${dirPath}\\n\\n${files.join('\\n')}`;\n        } catch (error: any) {\n          return buildError('listing files', error, { path: requestedPath, resolvedPath });\n        }\n      },\n    },\n    {\n      name: 'search_files',\n      description: 'Search for files matching a pattern (supports glob patterns)',\n      parameters: {\n        type: 'object',\n        properties: {\n          pattern: {\n            type: 'string',\n            description: 'The search pattern (e.g., \"*.ts\", \"src/**/*.js\")',\n            minLength: 1,\n          },\n          path: {\n            type: 'string',\n            description: 'The directory to search in (defaults to current working directory)',\n            minLength: 1,\n          },\n          head_limit: {\n            type: 'number',\n            description: `Maximum number of files to return. Defaults to ${DEFAULT_SEARCH_HEAD_LIMIT}.`,\n          },\n        },\n        required: ['pattern'],\n        additionalProperties: false,\n      },\n      handler: async (args) => {\n        const pathArg = args['path'];\n        const requestedPath = normalizePathContext(pathArg);\n        const patternArg = args['pattern'];\n        const requestedPattern = typeof patternArg === 'string' ? patternArg : undefined;\n        let resolvedPath: string | undefined;\n        try {\n          const pattern = typeof patternArg === 'string' && patternArg.trim() ? patternArg : null;\n          if (!pattern) {\n            return 'Error: pattern must be a non-empty string.';\n          }\n          const headLimitArg = args['head_limit'];\n          const headLimit =\n            typeof headLimitArg === 'number' && Number.isFinite(headLimitArg) && headLimitArg > 0\n              ? Math.floor(headLimitArg)\n              : DEFAULT_SEARCH_HEAD_LIMIT;\n          const searchPath =\n            pathArg !== undefined && pathArg !== null ? resolveFilePath(workingDir, pathArg) : workingDir;\n          resolvedPath = searchPath;\n          const results = searchFilesGlob(searchPath, pattern).sort();\n          if (results.length === 0) {\n            return `No files found matching pattern: ${pattern}`;\n          }\n          const limited = results.slice(0, headLimit);\n          const truncated = results.length > headLimit;\n          const headerParts = [\n            `Found ${results.length} file${results.length === 1 ? '' : 's'} matching \"${pattern}\"`,\n            truncated ? `showing first ${headLimit}` : null,\n          ].filter(Boolean);\n\n          let output = `${headerParts.join(' ')}:\\n\\n${limited.map((f) => relative(workingDir, f)).join('\\n')}`;\n\n          if (truncated) {\n            output += `\\n\\n... [${results.length - headLimit} more files truncated. Use head_limit parameter to see more]`;\n          }\n\n          return output;\n        } catch (error: any) {\n          return buildError('searching files', error, {\n            path: requestedPath,\n            resolvedPath,\n            pattern: requestedPattern,\n          });\n        }\n      },\n    },\n  ];\n}\n\nfunction resolveFilePath(workingDir: string, path: unknown): string {\n  const validated = validatePathArg(path);\n  return validated.startsWith('/') ? validated : join(workingDir, validated);\n}\n\nfunction validatePathArg(path: unknown): string {\n  if (typeof path !== 'string' || !path.trim()) {\n    throw new Error('Path must be a non-empty string.');\n  }\n  return path.trim();\n}\n\nfunction normalizePathContext(path: unknown): string | undefined {\n  if (path === undefined || path === null) {\n    return undefined;\n  }\n  try {\n    return String(path);\n  } catch {\n    return '(unprintable)';\n  }\n}\n\nfunction listFilesRecursive(dir: string, maxDepth: number, baseDir: string, currentDepth = 0): string[] {\n  if (currentDepth >= maxDepth) {\n    return [];\n  }\n\n  const ignoredDirs = new Set(['.git', 'node_modules', 'dist', '.next', 'build', 'coverage']);\n  const results: string[] = [];\n\n  try {\n    const entries = readdirSync(dir, { withFileTypes: true });\n\n    for (const entry of entries) {\n      if (ignoredDirs.has(entry.name)) {\n        continue;\n      }\n\n      const fullPath = join(dir, entry.name);\n      const indent = '  '.repeat(currentDepth);\n\n      if (entry.isDirectory()) {\n        results.push(`${indent}${entry.name}/`);\n        results.push(...listFilesRecursive(fullPath, maxDepth, baseDir, currentDepth + 1));\n      } else {\n        const stats = statSync(fullPath);\n        const size = formatFileSize(stats.size);\n        results.push(`${indent}${entry.name} ${size}`);\n      }\n    }\n  } catch (error) {\n    // Ignore filesystem errors; best-effort file listing only.\n  }\n\n  return results;\n}\n\nfunction searchFilesGlob(dir: string, pattern: string): string[] {\n  const results: string[] = [];\n  const regex = globToRegex(pattern);\n\n  function search(currentDir: string) {\n    const ignoredDirs = new Set(['.git', 'node_modules', 'dist', '.next', 'build', 'coverage']);\n\n    try {\n      const entries = readdirSync(currentDir, { withFileTypes: true });\n\n      for (const entry of entries) {\n        if (ignoredDirs.has(entry.name)) {\n          continue;\n        }\n\n        const fullPath = join(currentDir, entry.name);\n\n        if (entry.isDirectory()) {\n          search(fullPath);\n        } else if (regex.test(fullPath)) {\n          results.push(fullPath);\n        }\n      }\n    } catch (error) {\n      // Ignore directory read errors and continue scanning.\n    }\n  }\n\n  search(dir);\n  return results;\n}\n\nfunction globToRegex(pattern: string): RegExp {\n  const escaped = pattern\n    .replace(/\\./g, '\\\\.')\n    .replace(/\\*\\*/g, '.*')\n    .replace(/\\*/g, '[^/]*')\n    .replace(/\\?/g, '.');\n  return new RegExp(escaped);\n}\n\nfunction formatFileSize(bytes: number): string {\n  if (bytes < 1024) return `${bytes}B`;\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)}KB`;\n  return `${(bytes / (1024 * 1024)).toFixed(1)}MB`;\n}\n\nasync function readFileWithLineNumbers(\n  workingDir: string,\n  pathArg: unknown,\n  offsetArg: unknown,\n  limitArg: unknown\n): Promise<FormattedReadResult> {\n  const requestedPath = normalizePathContext(pathArg);\n  let resolvedPath: string | undefined;\n\n  try {\n    const filePath = resolveFilePath(workingDir, pathArg);\n    resolvedPath = filePath;\n    if (!existsSync(filePath)) {\n      return { filePath, output: `Error: File not found: ${filePath}` };\n    }\n\n    const fileStats = await stat(filePath);\n    if (fileStats.size > MAX_FILE_SIZE) {\n      return {\n        filePath,\n        output: `Error: File too large (${formatFileSize(fileStats.size)}). Maximum allowed: ${formatFileSize(MAX_FILE_SIZE)}. Use offset and limit parameters to read specific portions.`,\n      };\n    }\n\n    const content = await readFile(filePath, 'utf-8');\n    const lines = content.split('\\n');\n    const totalLines = lines.length;\n\n    const { offset, startLine, endLine } = normalizeReadWindow(totalLines, offsetArg, limitArg);\n    const selectedLines = lines.slice(startLine, endLine);\n\n    const numberedLines = selectedLines.map((line, idx) => {\n      const lineNum = String(startLine + idx + 1).padStart(6);\n      return `${lineNum}\\t${line}`;\n    });\n\n    const showingRange = startLine > 0 || endLine < totalLines;\n    const rangeInfo = showingRange\n      ? ` (lines ${offset}-${endLine} of ${totalLines})`\n      : ` (${totalLines} lines)`;\n\n    return {\n      filePath,\n      output: `File: ${filePath}${rangeInfo}\\n\\n${numberedLines.join('\\n')}`,\n    };\n  } catch (error: any) {\n    return { filePath: resolvedPath, output: buildError('reading file', error, { path: requestedPath, resolvedPath }) };\n  }\n}\n\nfunction normalizeReadWindow(totalLines: number, offsetArg: unknown, limitArg: unknown): {\n  offset: number;\n  startLine: number;\n  endLine: number;\n} {\n  const offset = typeof offsetArg === 'number' ? Math.max(1, Math.floor(offsetArg)) : 1;\n  const defaultLimit = totalLines > 2000 ? 2000 : totalLines;\n  const limit = typeof limitArg === 'number' ? Math.max(1, Math.floor(limitArg)) : defaultLimit;\n\n  const startLine = offset - 1;\n  const endLine = Math.min(startLine + limit, totalLines);\n\n  return { offset, startLine, endLine };\n}\n"],"mappings":"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","ignoreList":[]}