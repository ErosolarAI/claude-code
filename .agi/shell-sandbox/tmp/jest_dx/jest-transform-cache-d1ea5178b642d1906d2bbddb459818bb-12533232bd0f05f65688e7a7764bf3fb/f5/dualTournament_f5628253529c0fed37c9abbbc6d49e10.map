{"version":3,"names":["DEFAULT_HUMAN_REWARD_WEIGHTS","exports","alpha","beta","gamma","runDualTournament","task","candidates","options","maxCandidates","boundedCandidates","slice","Math","max","length","solo","correctness","scoreCorrectness","metrics","quality","scoreQuality","preferSmallerDiff","learned","scoreLearnedSignals","signals","aggregateScore","combineReward","rewardWeights","ranked","candidateId","id","humanAccuracy","rank","correctnessScore","qualityScore","learnedScore","evaluatorScore","pairwise","evaluatorBreakdown","evaluatorWeights","Map","evaluator","evaluators","eloWeight","elo","set","weight","aggregatedEvaluatorScores","aggregateEvaluatorScores","map","candidate","rewardScore","get","clamp","sort","a","b","forEach","entry","idx","computeHumanAccuracy","execution","executionSuccess","tests","testsPassed","failures","testsFailed","toolSuccess","toolSuccesses","min","score","staticAnalysis","codeQuality","complexityComponent","complexityDelta","blastRadius","diffSize","dependencyPenalty","dependenciesAdded","warningPenalty","warnings","rewardModel","rewardModelScore","human","humanPreference","self","selfAssessment","components","value","default","totalWeight","weightedSum","comp","weights","weighted","total","aggregated","twoCandidateFastPath","candidateIds","c","other","scoresByEvaluator","evaluatorScores","has","evaluatorId","push","notes","size","fallback","candidateScore","totalBordaWeight","rawScores","entries","filter","_","rest","bordaPoints","higher","lower","i","j","points","Number","isNaN","rankIndex","maxIndex","relative"],"sources":["dualTournament.ts"],"sourcesContent":["/**\n * Dual Tournament Engine\n *\n * Shared scoring/ranking utilities used by dual tournaments in both /upgrade and /attack flows.\n * Encodes policy vs evaluator tournaments with human-like reward heuristics and multi-evaluator\n * aggregation to approximate human code review preferences.\n */\n\nexport type PolicyId = string;\n\nexport interface TournamentPolicy {\n  id: PolicyId;\n  label?: string;\n  kind?: 'primary' | 'refiner' | 'checkpoint' | 'attack';\n  elo?: number;\n}\n\nexport interface TournamentEvaluator {\n  id: string;\n  label?: string;\n  /** Weight used when combining evaluator rankings (can be influenced by historical ELO). */\n  weight?: number;\n  kind?: 'hard' | 'soft' | 'hybrid';\n  elo?: number;\n}\n\nexport interface TournamentTask {\n  id: string;\n  goal: string;\n  repoSnapshot?: string;\n  tests?: string[];\n  constraints?: string[];\n  metadata?: Record<string, unknown>;\n}\n\nexport interface CandidateMetrics {\n  executionSuccess?: number; // 0-1\n  testsPassed?: number; // 0-1\n  testsFailed?: number; // count\n  staticAnalysis?: number; // 0-1\n  codeQuality?: number; // 0-1\n  blastRadius?: number; // 0-1 (smaller diff => higher)\n  diffSize?: number; // lines changed\n  complexityDelta?: number; // negative better\n  dependenciesAdded?: number; // count\n  speedBonus?: number; // 0-1\n  toolSuccesses?: number; // count\n  toolFailures?: number; // count\n  warnings?: number; // count\n}\n\nexport interface CandidateSignals {\n  /** Learned reward model / preference score (0-1) */\n  rewardModelScore?: number;\n  /** Self-assessed confidence from the agent (0-1) */\n  selfAssessment?: number;\n  /** Optional human preference label (0-1) */\n  humanPreference?: number;\n}\n\nexport interface EvaluatorScore {\n  evaluatorId: string;\n  score: number;\n  weight?: number;\n  notes?: string;\n}\n\ntype CandidateEvaluatorScore = EvaluatorScore & { candidateId: string };\n\nexport interface TournamentCandidate {\n  id: string;\n  policyId: PolicyId;\n  patchSummary?: string;\n  diffSummary?: string;\n  metrics?: CandidateMetrics;\n  signals?: CandidateSignals;\n  evaluatorScores?: EvaluatorScore[];\n  rawOutput?: string;\n}\n\nexport interface HumanRewardWeights {\n  /** Correctness weight */\n  alpha: number;\n  /** Code quality / robustness weight */\n  beta: number;\n  /** Learned reward / human preference weight */\n  gamma: number;\n}\n\nexport const DEFAULT_HUMAN_REWARD_WEIGHTS: HumanRewardWeights = {\n  alpha: 0.6,\n  beta: 0.25,\n  gamma: 0.15,\n};\n\nexport interface RankedCandidate {\n  candidateId: string;\n  aggregateScore: number;\n  /** Relative human-like accuracy (1 = best rank, 0 = worst rank) */\n  humanAccuracy: number;\n  rank: number;\n  correctnessScore: number;\n  qualityScore: number;\n  learnedScore: number;\n  evaluatorScore: number;\n}\n\nexport type PairwiseWins = Record<string, Record<string, number>>;\n\nexport interface TournamentOutcome {\n  task: TournamentTask;\n  ranked: RankedCandidate[];\n  pairwise: PairwiseWins;\n  evaluatorBreakdown: Record<string, EvaluatorScore[]>;\n}\n\nexport interface TournamentOptions {\n  rewardWeights?: HumanRewardWeights;\n  evaluators?: TournamentEvaluator[];\n  /** When true, prefer smaller diffs by default if diffSize is provided */\n  preferSmallerDiff?: boolean;\n  /** Maximum candidates to evaluate (caps O(n^2) work) */\n  maxCandidates?: number;\n}\n\n/**\n  * Run a dual tournament over candidate patches/agents, combining hard metrics,\n  * human-like reward heuristics, and evaluator rankings.\n  */\nexport function runDualTournament(\n  task: TournamentTask,\n  candidates: TournamentCandidate[],\n  options: TournamentOptions = {}\n): TournamentOutcome {\n  const maxCandidates = options.maxCandidates ?? 8;\n  const boundedCandidates = candidates.slice(0, Math.max(1, maxCandidates));\n\n  // Fast path: single candidate - avoid unnecessary aggregation work\n  if (boundedCandidates.length === 1) {\n    const solo = boundedCandidates[0]!;\n    const correctness = scoreCorrectness(solo.metrics);\n    const quality = scoreQuality(solo.metrics, options.preferSmallerDiff ?? true);\n    const learned = scoreLearnedSignals(solo.signals);\n    const aggregateScore = combineReward(correctness, quality, learned, options.rewardWeights ?? DEFAULT_HUMAN_REWARD_WEIGHTS);\n\n    const ranked: RankedCandidate[] = [{\n      candidateId: solo.id,\n      aggregateScore,\n      humanAccuracy: 1,\n      rank: 1,\n      correctnessScore: correctness,\n      qualityScore: quality,\n      learnedScore: learned,\n      evaluatorScore: aggregateScore,\n    }];\n\n    return {\n      task,\n      ranked,\n      pairwise: {},\n      evaluatorBreakdown: {},\n    };\n  }\n\n  const rewardWeights = options.rewardWeights ?? DEFAULT_HUMAN_REWARD_WEIGHTS;\n  const evaluatorWeights = new Map<string, number>();\n  for (const evaluator of options.evaluators ?? []) {\n    const eloWeight = evaluator.elo ? 1 + Math.max(0, (evaluator.elo - 1200) / 2400) : 1;\n    evaluatorWeights.set(evaluator.id, (evaluator.weight ?? 1) * eloWeight);\n  }\n\n  // Compute evaluator aggregates and pairwise wins first (needed for composite score)\n  const { aggregatedEvaluatorScores, pairwise, evaluatorBreakdown } = aggregateEvaluatorScores(\n    boundedCandidates,\n    evaluatorWeights\n  );\n\n  const ranked: RankedCandidate[] = boundedCandidates.map((candidate) => {\n    const correctness = scoreCorrectness(candidate.metrics);\n    const quality = scoreQuality(candidate.metrics, options.preferSmallerDiff ?? true);\n    const learned = scoreLearnedSignals(candidate.signals);\n    const rewardScore = combineReward(correctness, quality, learned, rewardWeights);\n    const evaluatorScore = aggregatedEvaluatorScores.get(candidate.id) ?? rewardScore;\n\n    // Combine human-like reward with evaluator aggregate (relative preference)\n    // Weighted 60/40 toward human-like reward to maintain quality focus while incorporating evaluator consensus\n    const aggregateScore = clamp(0.60 * rewardScore + 0.40 * evaluatorScore);\n\n    return {\n      candidateId: candidate.id,\n      aggregateScore,\n      humanAccuracy: 0,\n      rank: 0, // set after sorting\n      correctnessScore: correctness,\n      qualityScore: quality,\n      learnedScore: learned,\n      evaluatorScore,\n    };\n  });\n\n  ranked.sort((a, b) => b.aggregateScore - a.aggregateScore);\n  ranked.forEach((entry, idx) => {\n    entry.rank = idx + 1;\n    entry.humanAccuracy = computeHumanAccuracy(idx, ranked.length);\n  });\n\n  return {\n    task,\n    ranked,\n    pairwise,\n    evaluatorBreakdown,\n  };\n}\n\n// ════════════════════════════════════════════════════════════════════════════\n// Internal scoring helpers\n// ════════════════════════════════════════════════════════════════════════════\n\nfunction scoreCorrectness(metrics?: CandidateMetrics): number {\n  if (!metrics) return 0.5;\n\n  const execution = metrics.executionSuccess ?? 0;\n  const tests = metrics.testsPassed ?? 0;\n  const failures = metrics.testsFailed ?? 0;\n  const toolSuccess = metrics.toolSuccesses ? Math.min(1, metrics.toolSuccesses / 3) : 0;\n\n  let score = execution * 0.35 + tests * 0.45 + toolSuccess * 0.2;\n  if (failures > 0) {\n    score -= Math.min(0.35, failures * 0.1);\n  }\n\n  return clamp(score);\n}\n\nfunction scoreQuality(metrics?: CandidateMetrics, preferSmallerDiff = true): number {\n  if (!metrics) return 0.5;\n\n  const staticAnalysis = metrics.staticAnalysis ?? 0.5;\n  const codeQuality = metrics.codeQuality ?? 0.5;\n  const complexityComponent =\n    typeof metrics.complexityDelta === 'number'\n      ? metrics.complexityDelta < 0\n        ? 0.7\n        : 0.45\n      : 0.55;\n\n  const blastRadius =\n    metrics.blastRadius ??\n    (preferSmallerDiff && metrics.diffSize ? 1 - clamp(metrics.diffSize / 500) : 0.55);\n\n  const dependencyPenalty = metrics.dependenciesAdded ? Math.min(0.3, metrics.dependenciesAdded * 0.05) : 0;\n  const warningPenalty = metrics.warnings ? Math.min(0.2, metrics.warnings * 0.05) : 0;\n\n  let score = staticAnalysis * 0.35 + codeQuality * 0.25 + blastRadius * 0.25 + complexityComponent * 0.15;\n  score -= dependencyPenalty + warningPenalty;\n\n  return clamp(score);\n}\n\nfunction scoreLearnedSignals(signals?: CandidateSignals): number {\n  if (!signals) return 0.5;\n\n  const rewardModel = signals.rewardModelScore;\n  const human = signals.humanPreference;\n  const self = signals.selfAssessment;\n\n  // Prioritize reward model score as primary signal (40%)\n  // Human preference as secondary (35%)\n  // Self-assessment as tertiary (25%)\n  // This weights external validation more than self-confidence\n  const components = [\n    { value: rewardModel, weight: 0.40, default: 0.5 },\n    { value: human, weight: 0.35, default: 0.5 },\n    { value: self, weight: 0.25, default: 0.5 }\n  ];\n\n  let totalWeight = 0;\n  let weightedSum = 0;\n\n  for (const comp of components) {\n    if (typeof comp.value === 'number') {\n      weightedSum += comp.value * comp.weight;\n      totalWeight += comp.weight;\n    } else {\n      weightedSum += comp.default * comp.weight;\n      totalWeight += comp.weight;\n    }\n  }\n\n  return totalWeight > 0 ? clamp(weightedSum / totalWeight) : 0.5;\n}\n\nfunction combineReward(\n  correctness: number,\n  quality: number,\n  learned: number,\n  weights: HumanRewardWeights\n): number {\n  const weighted =\n    weights.alpha * correctness +\n    weights.beta * quality +\n    weights.gamma * learned;\n  const total = weights.alpha + weights.beta + weights.gamma;\n  return total > 0 ? clamp(weighted / total) : clamp(weighted);\n}\n\nfunction aggregateEvaluatorScores(\n  candidates: TournamentCandidate[],\n  evaluatorWeights: Map<string, number>\n): {\n  aggregatedEvaluatorScores: Map<string, number>;\n  pairwise: PairwiseWins;\n  evaluatorBreakdown: Record<string, EvaluatorScore[]>;\n} {\n  const pairwise: PairwiseWins = {};\n  const aggregated = new Map<string, number>();\n  const evaluatorBreakdown: Record<string, EvaluatorScore[]> = {};\n\n  if (candidates.length === 0) {\n    return { aggregatedEvaluatorScores: aggregated, pairwise, evaluatorBreakdown };\n  }\n\n  // Pre-size for small tournaments to avoid unnecessary O(n^2) when not needed\n  const twoCandidateFastPath = candidates.length <= 2;\n\n  const candidateIds = candidates.map((c) => c.id);\n  for (const id of candidateIds) {\n    pairwise[id] = {};\n    for (const other of candidateIds) {\n      if (id !== other) pairwise[id][other] = 0;\n    }\n  }\n\n  // Collect scores per evaluator\n  const scoresByEvaluator = new Map<string, CandidateEvaluatorScore[]>();\n  for (const candidate of candidates) {\n    for (const score of candidate.evaluatorScores ?? []) {\n      if (!scoresByEvaluator.has(score.evaluatorId)) {\n        scoresByEvaluator.set(score.evaluatorId, []);\n      }\n      scoresByEvaluator.get(score.evaluatorId)!.push({\n        evaluatorId: score.evaluatorId,\n        score: clamp(score.score),\n        weight: score.weight,\n        notes: score.notes,\n        candidateId: candidate.id,\n      });\n    }\n  }\n\n  // If no evaluator scores provided, fall back to neutral rankings\n  if (scoresByEvaluator.size === 0) {\n    const fallback: CandidateEvaluatorScore[] = [];\n    for (const candidate of candidates) {\n      // Use candidate's own reward signals if available\n      const candidateScore = candidate.signals?.rewardModelScore ?? 0.5;\n      fallback.push({\n        evaluatorId: 'reward-fallback',\n        score: candidateScore,\n        weight: 1,\n        candidateId: candidate.id,\n      });\n    }\n    scoresByEvaluator.set('reward-fallback', fallback);\n  }\n\n  let totalBordaWeight = 0;\n\n  for (const [evaluatorId, rawScores] of scoresByEvaluator.entries()) {\n    const weight = evaluatorWeights.get(evaluatorId) ?? 1;\n    totalBordaWeight += weight * Math.max(1, candidates.length - 1);\n\n    // Sort descending by score to assign ranks (Borda)\n    const ranked = rawScores\n      .filter((entry) => typeof entry.score === 'number')\n      .sort((a, b) => (b.score ?? 0) - (a.score ?? 0));\n\n    evaluatorBreakdown[evaluatorId] = ranked.map(({ candidateId: _, ...rest }) => rest as EvaluatorScore);\n\n    ranked.forEach((entry, idx) => {\n      const candidateId = (entry as unknown as { candidateId: string }).candidateId;\n      const bordaPoints = (candidates.length - idx - 1) * weight;\n      aggregated.set(candidateId, (aggregated.get(candidateId) ?? 0) + bordaPoints);\n    });\n\n    // Pairwise wins for this evaluator (lightweight path for <=2 candidates)\n    if (twoCandidateFastPath && ranked.length === 2) {\n      const higher = ranked[0] as unknown as { candidateId: string; score: number };\n      const lower = ranked[1] as unknown as { candidateId: string; score: number };\n      if (higher.score === lower.score) {\n        pairwise[higher.candidateId][lower.candidateId] += weight * 0.5;\n        pairwise[lower.candidateId][higher.candidateId] += weight * 0.5;\n      } else {\n        pairwise[higher.candidateId][lower.candidateId] += weight;\n      }\n    } else {\n      for (let i = 0; i < ranked.length; i++) {\n        for (let j = i + 1; j < ranked.length; j++) {\n          const higher = ranked[i] as unknown as { candidateId: string; score: number };\n          const lower = ranked[j] as unknown as { candidateId: string; score: number };\n          if (higher.score === lower.score) {\n            pairwise[higher.candidateId][lower.candidateId] += weight * 0.5;\n            pairwise[lower.candidateId][higher.candidateId] += weight * 0.5;\n          } else {\n            pairwise[higher.candidateId][lower.candidateId] += weight;\n          }\n        }\n      }\n    }\n  }\n\n  // Normalize aggregated Borda scores into [0,1]\n  if (totalBordaWeight > 0) {\n    for (const [candidateId, points] of aggregated.entries()) {\n      aggregated.set(candidateId, clamp(points / totalBordaWeight));\n    }\n  }\n\n  // Ensure every candidate has an entry\n  for (const candidateId of candidateIds) {\n    if (!aggregated.has(candidateId)) {\n      aggregated.set(candidateId, 0.5);\n    }\n  }\n\n  return { aggregatedEvaluatorScores: aggregated, pairwise, evaluatorBreakdown };\n}\n\nfunction clamp(value: number, min = 0, max = 1): number {\n  if (Number.isNaN(value)) return min;\n  return Math.max(min, Math.min(max, value));\n}\n\nfunction computeHumanAccuracy(rankIndex: number, total: number): number {\n  if (total <= 1) return 1;\n  const maxIndex = Math.max(1, total - 1);\n  const relative = 1 - rankIndex / maxIndex;\n  return clamp(relative);\n}\n"],"mappings":"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","ignoreList":[]}