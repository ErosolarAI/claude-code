c07b2c946ad4c76a7532f8bba87430b6
"use strict";

var _globals = require("@jest/globals");
var _nodeStream = require("node:stream");
var _UnifiedUIRenderer = require("../src/ui/UnifiedUIRenderer.js");
const createRenderer = () => {
  const input = new _nodeStream.PassThrough();
  input.isTTY = true;
  input.setRawMode = _globals.jest.fn();
  const output = new _nodeStream.PassThrough();
  output.isTTY = true;
  output.columns = 80;
  output.rows = 24;
  output.write = chunk => {
    const text = typeof chunk === 'string' ? chunk : chunk?.toString?.() ?? '';
    // Preserve write signature used by readline
    _nodeStream.PassThrough.prototype.write.call(output, text);
    return true;
  };
  const renderer = new _UnifiedUIRenderer.UnifiedUIRenderer(output, input);
  return {
    renderer,
    input,
    output
  };
};

// Helper function to test toggle symbol stripping
const testStripToggleSymbols = () => {
  const chars = [...'Hello©WorldåTest∂Content'];
  let result = '';
  for (let i = 0; i < chars.length; i++) {
    const ch = chars[i];
    const code = ch.charCodeAt(0);

    // Check for toggle characters
    if (code === 169 || code === 8482) continue; // © ™ (Option+G)
    if (code === 229 || code === 197) continue; // å Å (Option+A)
    if (code === 8706 || code === 8710 || code === 206) continue; // ∂ ∆ Î (Option+D)
    if (code === 8224 || code === 8225) continue; // † ‡ (Option+T)
    if (code === 8730) continue; // √ (Option+V)

    // Check for ESC + toggle letter
    if (code === 27 && i + 1 < chars.length) {
      const letter = chars[i + 1].toLowerCase();
      if (['g', 'a', 'd', 't', 'v'].includes(letter)) {
        i++;
        continue;
      }
    }
    result += ch;
  }
  return result;
};
(0, _globals.describe)('Paste functionality', () => {
  (0, _globals.it)('should not leak toggle symbols during paste', () => {
    // Test the toggle symbol stripping logic directly
    const result = testStripToggleSymbols();
    (0, _globals.expect)(result).toBe('HelloWorldTestContent');
    (0, _globals.expect)(result).not.toContain('©');
    (0, _globals.expect)(result).not.toContain('å');
    (0, _globals.expect)(result).not.toContain('∂');
  });
  (0, _globals.it)('should handle multi-line paste without visual leak', () => {
    const {
      renderer,
      input
    } = createRenderer();
    try {
      // First, write some text to start the paste buffer
      const dataHandler = input.listeners('data')[0];
      (0, _globals.expect)(dataHandler).toBeDefined();

      // Write a character to start paste detection
      dataHandler(Buffer.from('L'));

      // Now write multi-line content
      dataHandler(Buffer.from('ine 1\nLine 2\nLine 3'));

      // The emit-level paste buffer should capture it
      const emitPasteBuffer = renderer.emitPasteBuffer;
      (0, _globals.expect)(emitPasteBuffer).toBe('Line 1\nLine 2\nLine 3');

      // Manually trigger the commit to create collapsed paste
      const commitMethod = renderer.commitEmitPasteBuffer;
      commitMethod.call(renderer);

      // Should create collapsed paste instead of leaking to screen
      const collapsedPaste = renderer.collapsedPaste;
      (0, _globals.expect)(collapsedPaste).toBeDefined();
      (0, _globals.expect)(collapsedPaste.text).toBe('Line 1\nLine 2\nLine 3');
      (0, _globals.expect)(collapsedPaste.lines).toBe(3);
    } finally {
      renderer.cleanup();
    }
  });
  (0, _globals.it)('should strip escape sequences from paste content', () => {
    // Test sanitizePasteContent logic directly
    const sanitizePasteContent = text => {
      if (!text) return '';

      // Remove all ANSI escape sequences
      // eslint-disable-next-line no-control-regex
      let sanitized = text.replace(/\x1b\[[0-9;]*[A-Za-z~]|\x1b\][^\x07]*\x07|\x1b[PX^_][^\x1b]*\x1b\\|\x1b./g, '');
      sanitized = sanitized.replace(/\[20[01]~/g, '');
      // eslint-disable-next-line no-control-regex
      sanitized = sanitized.replace(/^\x1b+|\x1b+$/g, '');

      // Test with various escape sequences
      const testCases = [{
        input: '\x1b[31mRed Text\x1b[0m',
        expected: 'Red Text'
      }, {
        input: 'Normal\x1b[200~Pasted\x1b[201~Text',
        expected: 'NormalPastedText'
      }, {
        input: '\x1b[AUp Arrow',
        expected: 'Up Arrow'
      }];
      testCases.forEach(({
        input,
        expected
      }) => {
        const result = sanitizePasteContent(input);
        (0, _globals.expect)(result).toBe(expected);
      });
      return sanitized;
    };
    const testCases = [{
      input: '\x1b[31mRed Text\x1b[0m',
      expected: 'Red Text'
    }, {
      input: 'Normal\x1b[200~Pasted\x1b[201~Text',
      expected: 'NormalPastedText'
    }, {
      input: '\x1b[AUp Arrow',
      expected: 'Up Arrow'
    }];
    testCases.forEach(({
      input,
      expected
    }) => {
      const result = sanitizePasteContent(input);
      (0, _globals.expect)(result).toBe(expected);
    });
  });
  (0, _globals.it)('should suppress render during paste burst to prevent visual leak', () => {
    const {
      renderer,
      input
    } = createRenderer();
    try {
      _globals.jest.useFakeTimers();

      // Start a paste burst
      const dataHandler = input.listeners('data')[0];
      dataHandler(Buffer.from('Start'));

      // Check that we're in a paste state
      const emitPasteBuffer = renderer.emitPasteBuffer;
      (0, _globals.expect)(emitPasteBuffer).toBe('Start');

      // Set up spy on render method
      const renderSpy = _globals.jest.spyOn(renderer, 'renderPromptImmediate');

      // Render should be suppressed during paste burst
      renderer.renderPrompt();
      (0, _globals.expect)(renderSpy).not.toHaveBeenCalled();

      // Commit the paste
      _globals.jest.advanceTimersByTime(50);

      // Now render should work
      renderer.renderPrompt();
      (0, _globals.expect)(renderSpy).toHaveBeenCalled();
      _globals.jest.useRealTimers();
    } finally {
      renderer.cleanup();
    }
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZ2xvYmFscyIsInJlcXVpcmUiLCJfbm9kZVN0cmVhbSIsIl9VbmlmaWVkVUlSZW5kZXJlciIsImNyZWF0ZVJlbmRlcmVyIiwiaW5wdXQiLCJQYXNzVGhyb3VnaCIsImlzVFRZIiwic2V0UmF3TW9kZSIsImplc3QiLCJmbiIsIm91dHB1dCIsImNvbHVtbnMiLCJyb3dzIiwid3JpdGUiLCJjaHVuayIsInRleHQiLCJ0b1N0cmluZyIsInByb3RvdHlwZSIsImNhbGwiLCJyZW5kZXJlciIsIlVuaWZpZWRVSVJlbmRlcmVyIiwidGVzdFN0cmlwVG9nZ2xlU3ltYm9scyIsImNoYXJzIiwicmVzdWx0IiwiaSIsImxlbmd0aCIsImNoIiwiY29kZSIsImNoYXJDb2RlQXQiLCJsZXR0ZXIiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwiZGVzY3JpYmUiLCJpdCIsImV4cGVjdCIsInRvQmUiLCJub3QiLCJ0b0NvbnRhaW4iLCJkYXRhSGFuZGxlciIsImxpc3RlbmVycyIsInRvQmVEZWZpbmVkIiwiQnVmZmVyIiwiZnJvbSIsImVtaXRQYXN0ZUJ1ZmZlciIsImNvbW1pdE1ldGhvZCIsImNvbW1pdEVtaXRQYXN0ZUJ1ZmZlciIsImNvbGxhcHNlZFBhc3RlIiwibGluZXMiLCJjbGVhbnVwIiwic2FuaXRpemVQYXN0ZUNvbnRlbnQiLCJzYW5pdGl6ZWQiLCJyZXBsYWNlIiwidGVzdENhc2VzIiwiZXhwZWN0ZWQiLCJmb3JFYWNoIiwidXNlRmFrZVRpbWVycyIsInJlbmRlclNweSIsInNweU9uIiwicmVuZGVyUHJvbXB0IiwidG9IYXZlQmVlbkNhbGxlZCIsImFkdmFuY2VUaW1lcnNCeVRpbWUiLCJ1c2VSZWFsVGltZXJzIl0sInNvdXJjZXMiOlsicGFzdGUtbGVhay50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBqZXN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5pbXBvcnQgeyBQYXNzVGhyb3VnaCB9IGZyb20gJ25vZGU6c3RyZWFtJztcbmltcG9ydCB7IFVuaWZpZWRVSVJlbmRlcmVyIH0gZnJvbSAnLi4vc3JjL3VpL1VuaWZpZWRVSVJlbmRlcmVyLmpzJztcblxuY29uc3QgY3JlYXRlUmVuZGVyZXIgPSAoKSA9PiB7XG4gIGNvbnN0IGlucHV0ID0gbmV3IFBhc3NUaHJvdWdoKCkgYXMgdW5rbm93biBhcyBOb2RlSlMuUmVhZFN0cmVhbTtcbiAgKGlucHV0IGFzIGFueSkuaXNUVFkgPSB0cnVlO1xuICAoaW5wdXQgYXMgYW55KS5zZXRSYXdNb2RlID0gamVzdC5mbigpO1xuXG4gIGNvbnN0IG91dHB1dCA9IG5ldyBQYXNzVGhyb3VnaCgpIGFzIHVua25vd24gYXMgTm9kZUpTLldyaXRlU3RyZWFtO1xuICAob3V0cHV0IGFzIGFueSkuaXNUVFkgPSB0cnVlO1xuICAob3V0cHV0IGFzIGFueSkuY29sdW1ucyA9IDgwO1xuICAob3V0cHV0IGFzIGFueSkucm93cyA9IDI0O1xuICAob3V0cHV0IGFzIGFueSkud3JpdGUgPSAoKGNodW5rOiBhbnkpID0+IHtcbiAgICBjb25zdCB0ZXh0ID0gdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyA/IGNodW5rIDogY2h1bms/LnRvU3RyaW5nPy4oKSA/PyAnJztcbiAgICAvLyBQcmVzZXJ2ZSB3cml0ZSBzaWduYXR1cmUgdXNlZCBieSByZWFkbGluZVxuICAgIFBhc3NUaHJvdWdoLnByb3RvdHlwZS53cml0ZS5jYWxsKG91dHB1dCwgdGV4dCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pIGFzIGFueTtcblxuICBjb25zdCByZW5kZXJlciA9IG5ldyBVbmlmaWVkVUlSZW5kZXJlcihvdXRwdXQsIGlucHV0KTtcbiAgcmV0dXJuIHsgcmVuZGVyZXIsIGlucHV0LCBvdXRwdXQgfTtcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byB0ZXN0IHRvZ2dsZSBzeW1ib2wgc3RyaXBwaW5nXG5jb25zdCB0ZXN0U3RyaXBUb2dnbGVTeW1ib2xzID0gKCkgPT4ge1xuICBjb25zdCBjaGFycyA9IFsuLi4nSGVsbG/CqVdvcmxkw6VUZXN04oiCQ29udGVudCddO1xuICBsZXQgcmVzdWx0ID0gJyc7XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2ggPSBjaGFyc1tpXTtcbiAgICBjb25zdCBjb2RlID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICBcbiAgICAvLyBDaGVjayBmb3IgdG9nZ2xlIGNoYXJhY3RlcnNcbiAgICBpZiAoY29kZSA9PT0gMTY5IHx8IGNvZGUgPT09IDg0ODIpIGNvbnRpbnVlOyAvLyDCqSDihKIgKE9wdGlvbitHKVxuICAgIGlmIChjb2RlID09PSAyMjkgfHwgY29kZSA9PT0gMTk3KSBjb250aW51ZTsgIC8vIMOlIMOFIChPcHRpb24rQSlcbiAgICBpZiAoY29kZSA9PT0gODcwNiB8fCBjb2RlID09PSA4NzEwIHx8IGNvZGUgPT09IDIwNikgY29udGludWU7IC8vIOKIgiDiiIYgw44gKE9wdGlvbitEKVxuICAgIGlmIChjb2RlID09PSA4MjI0IHx8IGNvZGUgPT09IDgyMjUpIGNvbnRpbnVlOyAvLyDigKAg4oChIChPcHRpb24rVClcbiAgICBpZiAoY29kZSA9PT0gODczMCkgY29udGludWU7IC8vIOKImiAoT3B0aW9uK1YpXG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIEVTQyArIHRvZ2dsZSBsZXR0ZXJcbiAgICBpZiAoY29kZSA9PT0gMjcgJiYgaSArIDEgPCBjaGFycy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxldHRlciA9IGNoYXJzW2kgKyAxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKFsnZycsICdhJywgJ2QnLCAndCcsICd2J10uaW5jbHVkZXMobGV0dGVyKSkge1xuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXN1bHQgKz0gY2g7XG4gIH1cbiAgXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5kZXNjcmliZSgnUGFzdGUgZnVuY3Rpb25hbGl0eScsICgpID0+IHtcbiAgaXQoJ3Nob3VsZCBub3QgbGVhayB0b2dnbGUgc3ltYm9scyBkdXJpbmcgcGFzdGUnLCAoKSA9PiB7XG4gICAgLy8gVGVzdCB0aGUgdG9nZ2xlIHN5bWJvbCBzdHJpcHBpbmcgbG9naWMgZGlyZWN0bHlcbiAgICBjb25zdCByZXN1bHQgPSB0ZXN0U3RyaXBUb2dnbGVTeW1ib2xzKCk7XG4gICAgZXhwZWN0KHJlc3VsdCkudG9CZSgnSGVsbG9Xb3JsZFRlc3RDb250ZW50Jyk7XG4gICAgZXhwZWN0KHJlc3VsdCkubm90LnRvQ29udGFpbignwqknKTtcbiAgICBleHBlY3QocmVzdWx0KS5ub3QudG9Db250YWluKCfDpScpO1xuICAgIGV4cGVjdChyZXN1bHQpLm5vdC50b0NvbnRhaW4oJ+KIgicpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGhhbmRsZSBtdWx0aS1saW5lIHBhc3RlIHdpdGhvdXQgdmlzdWFsIGxlYWsnLCAoKSA9PiB7XG4gICAgY29uc3QgeyByZW5kZXJlciwgaW5wdXQgfSA9IGNyZWF0ZVJlbmRlcmVyKCk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpcnN0LCB3cml0ZSBzb21lIHRleHQgdG8gc3RhcnQgdGhlIHBhc3RlIGJ1ZmZlclxuICAgICAgY29uc3QgZGF0YUhhbmRsZXIgPSAoaW5wdXQgYXMgYW55KS5saXN0ZW5lcnMoJ2RhdGEnKVswXTtcbiAgICAgIGV4cGVjdChkYXRhSGFuZGxlcikudG9CZURlZmluZWQoKTtcbiAgICAgIFxuICAgICAgLy8gV3JpdGUgYSBjaGFyYWN0ZXIgdG8gc3RhcnQgcGFzdGUgZGV0ZWN0aW9uXG4gICAgICBkYXRhSGFuZGxlcihCdWZmZXIuZnJvbSgnTCcpKTtcbiAgICAgIFxuICAgICAgLy8gTm93IHdyaXRlIG11bHRpLWxpbmUgY29udGVudFxuICAgICAgZGF0YUhhbmRsZXIoQnVmZmVyLmZyb20oJ2luZSAxXFxuTGluZSAyXFxuTGluZSAzJykpO1xuICAgICAgXG4gICAgICAvLyBUaGUgZW1pdC1sZXZlbCBwYXN0ZSBidWZmZXIgc2hvdWxkIGNhcHR1cmUgaXRcbiAgICAgIGNvbnN0IGVtaXRQYXN0ZUJ1ZmZlciA9IChyZW5kZXJlciBhcyBhbnkpLmVtaXRQYXN0ZUJ1ZmZlcjtcbiAgICAgIGV4cGVjdChlbWl0UGFzdGVCdWZmZXIpLnRvQmUoJ0xpbmUgMVxcbkxpbmUgMlxcbkxpbmUgMycpO1xuICAgICAgXG4gICAgICAvLyBNYW51YWxseSB0cmlnZ2VyIHRoZSBjb21taXQgdG8gY3JlYXRlIGNvbGxhcHNlZCBwYXN0ZVxuICAgICAgY29uc3QgY29tbWl0TWV0aG9kID0gKHJlbmRlcmVyIGFzIGFueSkuY29tbWl0RW1pdFBhc3RlQnVmZmVyO1xuICAgICAgY29tbWl0TWV0aG9kLmNhbGwocmVuZGVyZXIpO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgY3JlYXRlIGNvbGxhcHNlZCBwYXN0ZSBpbnN0ZWFkIG9mIGxlYWtpbmcgdG8gc2NyZWVuXG4gICAgICBjb25zdCBjb2xsYXBzZWRQYXN0ZSA9IChyZW5kZXJlciBhcyBhbnkpLmNvbGxhcHNlZFBhc3RlO1xuICAgICAgZXhwZWN0KGNvbGxhcHNlZFBhc3RlKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGNvbGxhcHNlZFBhc3RlLnRleHQpLnRvQmUoJ0xpbmUgMVxcbkxpbmUgMlxcbkxpbmUgMycpO1xuICAgICAgZXhwZWN0KGNvbGxhcHNlZFBhc3RlLmxpbmVzKS50b0JlKDMpO1xuICAgICAgXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlbmRlcmVyLmNsZWFudXAoKTtcbiAgICB9XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgc3RyaXAgZXNjYXBlIHNlcXVlbmNlcyBmcm9tIHBhc3RlIGNvbnRlbnQnLCAoKSA9PiB7XG4gICAgLy8gVGVzdCBzYW5pdGl6ZVBhc3RlQ29udGVudCBsb2dpYyBkaXJlY3RseVxuICAgIGNvbnN0IHNhbml0aXplUGFzdGVDb250ZW50ID0gKHRleHQ6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgICBpZiAoIXRleHQpIHJldHVybiAnJztcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIGFsbCBBTlNJIGVzY2FwZSBzZXF1ZW5jZXNcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICAgICBsZXQgc2FuaXRpemVkID0gdGV4dC5yZXBsYWNlKC9cXHgxYlxcW1swLTk7XSpbQS1aYS16fl18XFx4MWJcXF1bXlxceDA3XSpcXHgwN3xcXHgxYltQWF5fXVteXFx4MWJdKlxceDFiXFxcXHxcXHgxYi4vZywgJycpO1xuICAgICAgc2FuaXRpemVkID0gc2FuaXRpemVkLnJlcGxhY2UoL1xcWzIwWzAxXX4vZywgJycpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgICAgIHNhbml0aXplZCA9IHNhbml0aXplZC5yZXBsYWNlKC9eXFx4MWIrfFxceDFiKyQvZywgJycpO1xuICAgICAgXG4gICAgICAvLyBUZXN0IHdpdGggdmFyaW91cyBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICBjb25zdCB0ZXN0Q2FzZXMgPSBbXG4gICAgICAgIHsgaW5wdXQ6ICdcXHgxYlszMW1SZWQgVGV4dFxceDFiWzBtJywgZXhwZWN0ZWQ6ICdSZWQgVGV4dCcgfSxcbiAgICAgICAgeyBpbnB1dDogJ05vcm1hbFxceDFiWzIwMH5QYXN0ZWRcXHgxYlsyMDF+VGV4dCcsIGV4cGVjdGVkOiAnTm9ybWFsUGFzdGVkVGV4dCcgfSxcbiAgICAgICAgeyBpbnB1dDogJ1xceDFiW0FVcCBBcnJvdycsIGV4cGVjdGVkOiAnVXAgQXJyb3cnIH0sXG4gICAgICBdO1xuICAgICAgXG4gICAgICB0ZXN0Q2FzZXMuZm9yRWFjaCgoeyBpbnB1dCwgZXhwZWN0ZWQgfSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzYW5pdGl6ZVBhc3RlQ29udGVudChpbnB1dCk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZXhwZWN0ZWQpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiBzYW5pdGl6ZWQ7XG4gICAgfTtcbiAgICBcbiAgICBjb25zdCB0ZXN0Q2FzZXMgPSBbXG4gICAgICB7IGlucHV0OiAnXFx4MWJbMzFtUmVkIFRleHRcXHgxYlswbScsIGV4cGVjdGVkOiAnUmVkIFRleHQnIH0sXG4gICAgICB7IGlucHV0OiAnTm9ybWFsXFx4MWJbMjAwflBhc3RlZFxceDFiWzIwMX5UZXh0JywgZXhwZWN0ZWQ6ICdOb3JtYWxQYXN0ZWRUZXh0JyB9LFxuICAgICAgeyBpbnB1dDogJ1xceDFiW0FVcCBBcnJvdycsIGV4cGVjdGVkOiAnVXAgQXJyb3cnIH0sXG4gICAgXTtcbiAgICBcbiAgICB0ZXN0Q2FzZXMuZm9yRWFjaCgoeyBpbnB1dCwgZXhwZWN0ZWQgfSkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gc2FuaXRpemVQYXN0ZUNvbnRlbnQoaW5wdXQpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShleHBlY3RlZCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgc3VwcHJlc3MgcmVuZGVyIGR1cmluZyBwYXN0ZSBidXJzdCB0byBwcmV2ZW50IHZpc3VhbCBsZWFrJywgKCkgPT4ge1xuICAgIGNvbnN0IHsgcmVuZGVyZXIsIGlucHV0IH0gPSBjcmVhdGVSZW5kZXJlcigpO1xuICAgIHRyeSB7XG4gICAgICBqZXN0LnVzZUZha2VUaW1lcnMoKTtcbiAgICAgIFxuICAgICAgLy8gU3RhcnQgYSBwYXN0ZSBidXJzdFxuICAgICAgY29uc3QgZGF0YUhhbmRsZXIgPSAoaW5wdXQgYXMgYW55KS5saXN0ZW5lcnMoJ2RhdGEnKVswXTtcbiAgICAgIGRhdGFIYW5kbGVyKEJ1ZmZlci5mcm9tKCdTdGFydCcpKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSdyZSBpbiBhIHBhc3RlIHN0YXRlXG4gICAgICBjb25zdCBlbWl0UGFzdGVCdWZmZXIgPSAocmVuZGVyZXIgYXMgYW55KS5lbWl0UGFzdGVCdWZmZXI7XG4gICAgICBleHBlY3QoZW1pdFBhc3RlQnVmZmVyKS50b0JlKCdTdGFydCcpO1xuICAgICAgXG4gICAgICAvLyBTZXQgdXAgc3B5IG9uIHJlbmRlciBtZXRob2RcbiAgICAgIGNvbnN0IHJlbmRlclNweSA9IGplc3Quc3B5T24ocmVuZGVyZXIgYXMgYW55LCAncmVuZGVyUHJvbXB0SW1tZWRpYXRlJyk7XG4gICAgICBcbiAgICAgIC8vIFJlbmRlciBzaG91bGQgYmUgc3VwcHJlc3NlZCBkdXJpbmcgcGFzdGUgYnVyc3RcbiAgICAgIHJlbmRlcmVyLnJlbmRlclByb21wdCgpO1xuICAgICAgZXhwZWN0KHJlbmRlclNweSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIFxuICAgICAgLy8gQ29tbWl0IHRoZSBwYXN0ZVxuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDUwKTtcbiAgICAgIFxuICAgICAgLy8gTm93IHJlbmRlciBzaG91bGQgd29ya1xuICAgICAgcmVuZGVyZXIucmVuZGVyUHJvbXB0KCk7XG4gICAgICBleHBlY3QocmVuZGVyU3B5KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBcbiAgICAgIGplc3QudXNlUmVhbFRpbWVycygpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZW5kZXJlci5jbGVhbnVwKCk7XG4gICAgfVxuICB9KTtcbn0pOyJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFBQSxRQUFBLEdBQUFDLE9BQUE7QUFDQSxJQUFBQyxXQUFBLEdBQUFELE9BQUE7QUFDQSxJQUFBRSxrQkFBQSxHQUFBRixPQUFBO0FBRUEsTUFBTUcsY0FBYyxHQUFHQSxDQUFBLEtBQU07RUFDM0IsTUFBTUMsS0FBSyxHQUFHLElBQUlDLHVCQUFXLENBQUMsQ0FBaUM7RUFDOURELEtBQUssQ0FBU0UsS0FBSyxHQUFHLElBQUk7RUFDMUJGLEtBQUssQ0FBU0csVUFBVSxHQUFHQyxhQUFJLENBQUNDLEVBQUUsQ0FBQyxDQUFDO0VBRXJDLE1BQU1DLE1BQU0sR0FBRyxJQUFJTCx1QkFBVyxDQUFDLENBQWtD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RUFBRSxnQkFBZ0I7TUFBRWlELFFBQVEsRUFBRTtJQUFXLENBQUMsQ0FDbEQ7SUFFREQsU0FBUyxDQUFDRSxPQUFPLENBQUMsQ0FBQztNQUFFbEQsS0FBSztNQUFFaUQ7SUFBUyxDQUFDLEtBQUs7TUFDekMsTUFBTTlCLE1BQU0sR0FBRzBCLG9CQUFvQixDQUFDN0MsS0FBSyxDQUFDO01BQzFDLElBQUE4QixlQUFNLEVBQUNYLE1BQU0sQ0FBQyxDQUFDWSxJQUFJLENBQUNrQixRQUFRLENBQUM7SUFDL0IsQ0FBQyxDQUFDO0VBQ0osQ0FBQyxDQUFDO0VBRUYsSUFBQXBCLFdBQUUsRUFBQyxrRUFBa0UsRUFBRSxNQUFNO0lBQzNFLE1BQU07TUFBRWQsUUFBUTtNQUFFZjtJQUFNLENBQUMsR0FBR0QsY0FBYyxDQUFDLENBQUM7SUFDNUMsSUFBSTtNQUNGSyxhQUFJLENBQUMrQyxhQUFhLENBQUMsQ0FBQzs7TUFFcEI7TUFDQSxNQUFNakIsV0FBVyxHQUFJbEMsS0FBSyxDQUFTbUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztNQUN2REQsV0FBVyxDQUFDRyxNQUFNLENBQUNDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQzs7TUFFakM7TUFDQSxNQUFNQyxlQUFlLEdBQUl4QixRQUFRLENBQVN3QixlQUFlO01BQ3pELElBQUFULGVBQU0sRUFBQ1MsZUFBZSxDQUFDLENBQUNSLElBQUksQ0FBQyxPQUFPLENBQUM7O01BRXJDO01BQ0EsTUFBTXFCLFNBQVMsR0FBR2hELGFBQUksQ0FBQ2lELEtBQUssQ0FBQ3RDLFFBQVEsRUFBUyx1QkFBdUIsQ0FBQzs7TUFFdEU7TUFDQUEsUUFBUSxDQUFDdUMsWUFBWSxDQUFDLENBQUM7TUFDdkIsSUFBQXhCLGVBQU0sRUFBQ3NCLFNBQVMsQ0FBQyxDQUFDcEIsR0FBRyxDQUFDdUIsZ0JBQWdCLENBQUMsQ0FBQzs7TUFFeEM7TUFDQW5ELGFBQUksQ0FBQ29ELG1CQUFtQixDQUFDLEVBQUUsQ0FBQzs7TUFFNUI7TUFDQXpDLFFBQVEsQ0FBQ3VDLFlBQVksQ0FBQyxDQUFDO01BQ3ZCLElBQUF4QixlQUFNLEVBQUNzQixTQUFTLENBQUMsQ0FBQ0csZ0JBQWdCLENBQUMsQ0FBQztNQUVwQ25ELGFBQUksQ0FBQ3FELGFBQWEsQ0FBQyxDQUFDO0lBQ3RCLENBQUMsU0FBUztNQUNSMUMsUUFBUSxDQUFDNkIsT0FBTyxDQUFDLENBQUM7SUFDcEI7RUFDRixDQUFDLENBQUM7QUFDSixDQUFDLENBQUMiLCJpZ25vcmVMaXN0IjpbXX0=