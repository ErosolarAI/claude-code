e369dfbfb986a35b6af3a71fd8caefda
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EDIT_WITHOUT_READ = void 0;
exports.validateAIFlowPatterns = validateAIFlowPatterns;
exports.validateToolPreconditions = validateToolPreconditions;
var _nodeFs = require("node:fs");
var _nodePath = require("node:path");
var _bashCommandGuidance = require("./bashCommandGuidance.js");
/**
 * Pre-flight validation patterns for AI flow design.
 * Catches common tool usage failures before execution and provides actionable guidance.
 */

const EDIT_WITHOUT_READ = exports.EDIT_WITHOUT_READ = 'EDIT_WITHOUT_READ';
/**
 * Validate tool preconditions before execution to prevent common AI flow failures.
 *
 * This function implements the critical AI flow design principle: validate before execute.
 * It catches common patterns that lead to tool failures and provides actionable guidance.
 *
 * @param toolName - Name of the tool being called
 * @param args - Tool arguments
 * @returns Array of pre-flight warnings (empty if all validations pass)
 */
function validateToolPreconditions(toolName, args) {
  const warnings = [];
  const toolLower = toolName.toLowerCase();

  // -------------------------------------------------------------------------
  // Edit Tool Validation - Critical for AI software engineering flow
  // -------------------------------------------------------------------------
  if (toolLower === 'edit') {
    const oldString = args['old_string'];
    const newString = args['new_string'];
    const filePath = args['file_path'];
    if (!oldString) {
      // Empty old_string = new file creation - validate path structure
      if (filePath && !filePath.startsWith('/')) {
        warnings.push({
          code: 'EDIT_RELATIVE_PATH',
          message: 'Edit file_path should be absolute path for new file creation',
          severity: 'warning',
          suggestion: 'Use absolute path starting with / for file creation'
        });
      }
    } else {
      // PATTERN 1: Placeholder patterns - AI is guessing content (but NOT "TODO" which is legitimate code)
      const placeholderPatterns = ['[content]', '[code]', '/* ... */', '// ...'];
      // Only flag "..." if it's standalone, not as part of spread operator or ellipsis in comments
      const hasStandalonePlaceholder = placeholderPatterns.some(p => oldString.includes(p)) || /(?<!\.)\.\.\.(?!\.)/.test(oldString); // Matches ... but not .... or .....
      if (hasStandalonePlaceholder) {
        warnings.push({
          code: 'EDIT_PLACEHOLDER',
          message: 'Placeholder patterns detected - HALLUCINATION ALERT',
          severity: 'critical',
          suggestion: 'AI is guessing content instead of reading actual file. ALWAYS use Read tool to get exact file content including whitespace.'
        });
      }

      // PATTERN 2: Tab vs space mismatch (legitimate concern)
      if (oldString && newString) {
        const oldHasTabs = oldString.includes('\t');
        const newHasTabs = newString.includes('\t');
        if (oldHasTabs && !newHasTabs) {
          warnings.push({
            code: 'EDIT_WHITESPACE_MISMATCH',
            message: 'old_string uses tabs, new_string uses spaces',
            severity: 'warning',
            suggestion: 'Whitespace type mismatch may cause Edit to fail.'
          });
        }
      }
    }
  }

  // -------------------------------------------------------------------------
  // Search Operations Validation - Only flag truly problematic patterns
  // -------------------------------------------------------------------------
  if (toolLower === 'grep' || toolLower === 'glob' || toolLower.includes('search')) {
    const patternArg = args['pattern'];
    const pattern = typeof patternArg === 'string' ? patternArg.trim() : '';
    const isGrepTool = toolLower.includes('grep');
    if (pattern) {
      // Only warn on truly broad patterns that would match everything
      if (isBroadBasePattern(pattern)) {
        warnings.push({
          code: 'SEARCH_BROAD_PATTERN',
          message: `Pattern '${pattern}' is too broad and may return thousands of files`,
          severity: 'critical',
          suggestion: "Use targeted patterns like '**/*.ts' or 'src/**/*.js'."
        });
      }

      // For grep: only warn on patterns that literally match everything
      if (isGrepTool && isVeryBroadRegex(pattern)) {
        const hasFileFilters = typeof args['glob'] === 'string' || typeof args['type'] === 'string';
        if (!hasFileFilters) {
          warnings.push({
            code: 'SEARCH_CONTEXT_OVERFLOW_RISK',
            message: `Regex pattern '${pattern}' matches everything`,
            severity: 'warning',
            suggestion: 'Use a more specific pattern or add a glob/type filter.'
          });
        }
      }
    }
  }

  // -------------------------------------------------------------------------
  // Bash Command Efficiency
  // -------------------------------------------------------------------------
  if (toolLower === 'bash' || toolLower === 'execute_bash') {
    const command = String(args['command'] || '');
    const flowWarnings = (0, _bashCommandGuidance.analyzeBashFlow)(command);
    for (const flow of flowWarnings) {
      warnings.push({
        code: flow.code,
        message: flow.message,
        severity: flow.severity === 'critical' ? 'critical' : flow.severity === 'info' ? 'info' : 'warning',
        suggestion: flow.suggestion ?? flow.message
      });
    }
  }
  return warnings;
}

/**
 * Enhanced AI flow validation for TypeScript software engineering
 * Provides comprehensive validation of AI tool usage patterns
 */
function validateAIFlowPatterns(toolName, args, toolHistory) {
  const warnings = [];
  const toolLower = toolName.toLowerCase();

  // Pattern: Edit without prior Read - Critical for hallucination reduction
  if (toolLower === 'edit') {
    const targetPath = normalizeFilePath(args['file_path']);
    const isNewFileCreation = isNewFileEdit(args['old_string']);
    const hasRecentRead = hasMatchingRead(toolHistory, targetPath);
    if (!isNewFileCreation && !hasRecentRead) {
      warnings.push({
        code: EDIT_WITHOUT_READ,
        message: 'Edit attempted without prior file read - HIGH HALLUCINATION RISK',
        severity: 'critical',
        suggestion: 'ALWAYS use Read tool first to get exact text including whitespace and indentation. Never guess file content.'
      });
    }
  }

  // Pattern: Multiple validation runs
  if (toolLower === 'run_repo_checks' || toolLower === 'run_tests' || toolLower === 'run_build') {
    const now = Date.now();
    const recencyWindowMs = 15 * 60 * 1000; // Only warn when validations are clustered
    const recentValidations = toolHistory.filter(call => call.toolName.toLowerCase().includes('run_') || call.toolName.toLowerCase().includes('test') || call.toolName.toLowerCase().includes('build')).filter(call => {
      if (typeof call.timestamp !== 'number') {
        return true;
      }
      return now - call.timestamp <= recencyWindowMs;
    });
    if (recentValidations.length > 0) {
      warnings.push({
        code: 'DEFERRED_VALIDATION_REMINDER',
        message: 'Validation already ran recently; batch edits and run one final pass at the end.',
        severity: 'info',
        suggestion: 'Finish implementation work first, then run a single build/test/check step to validate.'
      });
    }
  }

  // Pattern: Excessive git status calls (actually wasteful)
  // Note: Multiple git operations in sequence (add, commit, push) is fine - don't warn on that
  if (toolLower.includes('git')) {
    const command = String(args['command'] || '');
    if (command.includes('git status')) {
      const recentStatusCalls = toolHistory.filter(call => {
        const cmd = String(call.args['command'] || '');
        return cmd.includes('git status');
      });
      // Only warn if there are 3+ status calls - 2 is normal (before and after operations)
      if (recentStatusCalls.length >= 3) {
        warnings.push({
          code: 'GIT_REDUNDANT_STATUS',
          message: 'Multiple git status calls detected',
          severity: 'info',
          suggestion: 'One git status call is usually sufficient.'
        });
      }
    }
  }
  return warnings;
}
function isBroadBasePattern(pattern) {
  // Only the truly universal patterns that match everything
  return pattern === '.' || pattern === '*' || pattern === '**' || pattern === '**/*';
}
function isVeryBroadRegex(pattern) {
  const normalized = pattern.trim();
  return normalized === '.*' || normalized === '.+' || normalized === '.';
}
function hasMatchingRead(toolHistory, targetPath) {
  if (!targetPath) return false;
  return toolHistory.some(call => {
    const callLower = call.toolName.toLowerCase();
    if (!callLower.includes('read')) {
      return false;
    }
    const readPath = normalizeFilePath(call.args['path'] ?? call.args['file_path']);
    return Boolean(readPath && readPath === targetPath);
  });
}
function isNewFileEdit(oldString) {
  return typeof oldString === 'string' && oldString.length === 0;
}
function normalizeFilePath(pathValue) {
  if (typeof pathValue !== 'string') {
    return null;
  }
  const trimmed = pathValue.trim();
  if (!trimmed) {
    return null;
  }
  try {
    const normalized = (0, _nodePath.normalize)(trimmed);
    const absolutePath = (0, _nodePath.isAbsolute)(normalized) ? normalized : (0, _nodePath.resolve)(process.cwd(), normalized);

    // Resolve symlinks on the deepest existing directory to avoid /var vs /private/var mismatches
    let currentDir = (0, _nodePath.dirname)(absolutePath);
    let suffix = (0, _nodePath.basename)(absolutePath);

    // Loop until we find an existing ancestor or hit the filesystem root.
    // eslint-disable-next-line no-constant-condition
    while (true) {
      if ((0, _nodeFs.existsSync)(currentDir)) {
        try {
          const realDir = (0, _nodeFs.realpathSync)(currentDir);
          return (0, _nodePath.normalize)((0, _nodePath.join)(realDir, suffix));
        } catch {
          // If realpath fails, fall through to the default normalization
          break;
        }
      }
      const parentDir = (0, _nodePath.dirname)(currentDir);
      if (parentDir === currentDir) {
        break;
      }
      suffix = (0, _nodePath.join)((0, _nodePath.basename)(currentDir), suffix);
      currentDir = parentDir;
    }
    return (0, _nodePath.normalize)(absolutePath);
  } catch {
    return trimmed;
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfbm9kZUZzIiwicmVxdWlyZSIsIl9ub2RlUGF0aCIsIl9iYXNoQ29tbWFuZEd1aWRhbmNlIiwiRURJVF9XSVRIT1VUX1JFQUQiLCJleHBvcnRzIiwidmFsaWRhdGVUb29sUHJlY29uZGl0aW9ucyIsInRvb2xOYW1lIiwiYXJncyIsIndhcm5pbmdzIiwidG9vbExvd2VyIiwidG9Mb3dlckNhc2UiLCJvbGRTdHJpbmciLCJuZXdTdHJpbmciLCJmaWxlUGF0aCIsInN0YXJ0c1dpdGgiLCJwdXNoIiwiY29kZSIsIm1lc3NhZ2UiLCJzZXZlcml0eSIsInN1Z2dlc3Rpb24iLCJwbGFjZWhvbGRlclBhdHRlcm5zIiwiaGFzU3RhbmRhbG9uZVBsYWNlaG9sZGVyIiwic29tZSIsInAiLCJpbmNsdWRlcyIsInRlc3QiLCJvbGRIYXNUYWJzIiwibmV3SGFzVGFicyIsInBhdHRlcm5BcmciLCJwYXR0ZXJuIiwidHJpbSIsImlzR3JlcFRvb2wiLCJpc0Jyb2FkQmFzZVBhdHRlcm4iLCJpc1ZlcnlCcm9hZFJlZ2V4IiwiaGFzRmlsZUZpbHRlcnMiLCJjb21tYW5kIiwiU3RyaW5nIiwiZmxvd1dhcm5pbmdzIiwiYW5hbHl6ZUJhc2hGbG93IiwiZmxvdyIsInZhbGlkYXRlQUlGbG93UGF0dGVybnMiLCJ0b29sSGlzdG9yeSIsInRhcmdldFBhdGgiLCJub3JtYWxpemVGaWxlUGF0aCIsImlzTmV3RmlsZUNyZWF0aW9uIiwiaXNOZXdGaWxlRWRpdCIsImhhc1JlY2VudFJlYWQiLCJoYXNNYXRjaGluZ1JlYWQiLCJub3ciLCJEYXRlIiwicmVjZW5jeVdpbmRvd01zIiwicmVjZW50VmFsaWRhdGlvbnMiLCJmaWx0ZXIiLCJjYWxsIiwidGltZXN0YW1wIiwibGVuZ3RoIiwicmVjZW50U3RhdHVzQ2FsbHMiLCJjbWQiLCJub3JtYWxpemVkIiwiY2FsbExvd2VyIiwicmVhZFBhdGgiLCJCb29sZWFuIiwicGF0aFZhbHVlIiwidHJpbW1lZCIsIm5vcm1hbGl6ZVBhdGgiLCJhYnNvbHV0ZVBhdGgiLCJpc0Fic29sdXRlIiwicmVzb2x2ZVBhdGgiLCJwcm9jZXNzIiwiY3dkIiwiY3VycmVudERpciIsImRpcm5hbWUiLCJzdWZmaXgiLCJiYXNlbmFtZSIsImV4aXN0c1N5bmMiLCJyZWFsRGlyIiwicmVhbHBhdGhTeW5jIiwiam9pbiIsInBhcmVudERpciJdLCJzb3VyY2VzIjpbInRvb2xQcmVjb25kaXRpb25zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4aXN0c1N5bmMsIHJlYWxwYXRoU3luYyB9IGZyb20gJ25vZGU6ZnMnO1xuaW1wb3J0IHsgYmFzZW5hbWUsIGRpcm5hbWUsIGlzQWJzb2x1dGUsIGpvaW4sIG5vcm1hbGl6ZSBhcyBub3JtYWxpemVQYXRoLCByZXNvbHZlIGFzIHJlc29sdmVQYXRoIH0gZnJvbSAnbm9kZTpwYXRoJztcbmltcG9ydCB7IGFuYWx5emVCYXNoRmxvdyB9IGZyb20gJy4vYmFzaENvbW1hbmRHdWlkYW5jZS5qcyc7XG5cbi8qKlxuICogUHJlLWZsaWdodCB2YWxpZGF0aW9uIHBhdHRlcm5zIGZvciBBSSBmbG93IGRlc2lnbi5cbiAqIENhdGNoZXMgY29tbW9uIHRvb2wgdXNhZ2UgZmFpbHVyZXMgYmVmb3JlIGV4ZWN1dGlvbiBhbmQgcHJvdmlkZXMgYWN0aW9uYWJsZSBndWlkYW5jZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcmVmbGlnaHRXYXJuaW5nIHtcbiAgcmVhZG9ubHkgY29kZTogc3RyaW5nO1xuICByZWFkb25seSBtZXNzYWdlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHNldmVyaXR5OiAnY3JpdGljYWwnIHwgJ3dhcm5pbmcnIHwgJ2luZm8nO1xuICByZWFkb25seSBzdWdnZXN0aW9uOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBFRElUX1dJVEhPVVRfUkVBRCA9ICdFRElUX1dJVEhPVVRfUkVBRCc7XG5cbnR5cGUgVG9vbEhpc3RvcnlDYWxsID0ge1xuICB0b29sTmFtZTogc3RyaW5nO1xuICBhcmdzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgdGltZXN0YW1wPzogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSB0b29sIHByZWNvbmRpdGlvbnMgYmVmb3JlIGV4ZWN1dGlvbiB0byBwcmV2ZW50IGNvbW1vbiBBSSBmbG93IGZhaWx1cmVzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyB0aGUgY3JpdGljYWwgQUkgZmxvdyBkZXNpZ24gcHJpbmNpcGxlOiB2YWxpZGF0ZSBiZWZvcmUgZXhlY3V0ZS5cbiAqIEl0IGNhdGNoZXMgY29tbW9uIHBhdHRlcm5zIHRoYXQgbGVhZCB0byB0b29sIGZhaWx1cmVzIGFuZCBwcm92aWRlcyBhY3Rpb25hYmxlIGd1aWRhbmNlLlxuICpcbiAqIEBwYXJhbSB0b29sTmFtZSAtIE5hbWUgb2YgdGhlIHRvb2wgYmVpbmcgY2FsbGVkXG4gKiBAcGFyYW0gYXJncyAtIFRvb2wgYXJndW1lbnRzXG4gKiBAcmV0dXJucyBBcnJheSBvZiBwcmUtZmxpZ2h0IHdhcm5pbmdzIChlbXB0eSBpZiBhbGwgdmFsaWRhdGlvbnMgcGFzcylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVG9vbFByZWNvbmRpdGlvbnMoXG4gIHRvb2xOYW1lOiBzdHJpbmcsXG4gIGFyZ3M6IFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4pOiBQcmVmbGlnaHRXYXJuaW5nW10ge1xuICBjb25zdCB3YXJuaW5nczogUHJlZmxpZ2h0V2FybmluZ1tdID0gW107XG4gIGNvbnN0IHRvb2xMb3dlciA9IHRvb2xOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBFZGl0IFRvb2wgVmFsaWRhdGlvbiAtIENyaXRpY2FsIGZvciBBSSBzb2Z0d2FyZSBlbmdpbmVlcmluZyBmbG93XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgaWYgKHRvb2xMb3dlciA9PT0gJ2VkaXQnKSB7XG4gICAgY29uc3Qgb2xkU3RyaW5nID0gYXJnc1snb2xkX3N0cmluZyddIGFzIHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBjb25zdCBuZXdTdHJpbmcgPSBhcmdzWyduZXdfc3RyaW5nJ10gYXMgc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGNvbnN0IGZpbGVQYXRoID0gYXJnc1snZmlsZV9wYXRoJ10gYXMgc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKCFvbGRTdHJpbmcpIHtcbiAgICAgIC8vIEVtcHR5IG9sZF9zdHJpbmcgPSBuZXcgZmlsZSBjcmVhdGlvbiAtIHZhbGlkYXRlIHBhdGggc3RydWN0dXJlXG4gICAgICBpZiAoZmlsZVBhdGggJiYgIWZpbGVQYXRoLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgICAgICBjb2RlOiAnRURJVF9SRUxBVElWRV9QQVRIJyxcbiAgICAgICAgICBtZXNzYWdlOiAnRWRpdCBmaWxlX3BhdGggc2hvdWxkIGJlIGFic29sdXRlIHBhdGggZm9yIG5ldyBmaWxlIGNyZWF0aW9uJyxcbiAgICAgICAgICBzZXZlcml0eTogJ3dhcm5pbmcnLFxuICAgICAgICAgIHN1Z2dlc3Rpb246ICdVc2UgYWJzb2x1dGUgcGF0aCBzdGFydGluZyB3aXRoIC8gZm9yIGZpbGUgY3JlYXRpb24nLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUEFUVEVSTiAxOiBQbGFjZWhvbGRlciBwYXR0ZXJucyAtIEFJIGlzIGd1ZXNzaW5nIGNvbnRlbnQgKGJ1dCBOT1QgXCJUT0RPXCIgd2hpY2ggaXMgbGVnaXRpbWF0ZSBjb2RlKVxuICAgICAgY29uc3QgcGxhY2Vob2xkZXJQYXR0ZXJucyA9IFsnW2NvbnRlbnRdJywgJ1tjb2RlXScsICcvKiAuLi4gKi8nLCAnLy8gLi4uJ107XG4gICAgICAvLyBPbmx5IGZsYWcgXCIuLi5cIiBpZiBpdCdzIHN0YW5kYWxvbmUsIG5vdCBhcyBwYXJ0IG9mIHNwcmVhZCBvcGVyYXRvciBvciBlbGxpcHNpcyBpbiBjb21tZW50c1xuICAgICAgY29uc3QgaGFzU3RhbmRhbG9uZVBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXJQYXR0ZXJucy5zb21lKChwKSA9PiBvbGRTdHJpbmcuaW5jbHVkZXMocCkpIHx8XG4gICAgICAgIC8oPzwhXFwuKVxcLlxcLlxcLig/IVxcLikvLnRlc3Qob2xkU3RyaW5nKTsgLy8gTWF0Y2hlcyAuLi4gYnV0IG5vdCAuLi4uIG9yIC4uLi4uXG4gICAgICBpZiAoaGFzU3RhbmRhbG9uZVBsYWNlaG9sZGVyKSB7XG4gICAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICAgIGNvZGU6ICdFRElUX1BMQUNFSE9MREVSJyxcbiAgICAgICAgICBtZXNzYWdlOiAnUGxhY2Vob2xkZXIgcGF0dGVybnMgZGV0ZWN0ZWQgLSBIQUxMVUNJTkFUSU9OIEFMRVJUJyxcbiAgICAgICAgICBzZXZlcml0eTogJ2NyaXRpY2FsJyxcbiAgICAgICAgICBzdWdnZXN0aW9uOlxuICAgICAgICAgICAgJ0FJIGlzIGd1ZXNzaW5nIGNvbnRlbnQgaW5zdGVhZCBvZiByZWFkaW5nIGFjdHVhbCBmaWxlLiBBTFdBWVMgdXNlIFJlYWQgdG9vbCB0byBnZXQgZXhhY3QgZmlsZSBjb250ZW50IGluY2x1ZGluZyB3aGl0ZXNwYWNlLicsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBQQVRURVJOIDI6IFRhYiB2cyBzcGFjZSBtaXNtYXRjaCAobGVnaXRpbWF0ZSBjb25jZXJuKVxuICAgICAgaWYgKG9sZFN0cmluZyAmJiBuZXdTdHJpbmcpIHtcbiAgICAgICAgY29uc3Qgb2xkSGFzVGFicyA9IG9sZFN0cmluZy5pbmNsdWRlcygnXFx0Jyk7XG4gICAgICAgIGNvbnN0IG5ld0hhc1RhYnMgPSBuZXdTdHJpbmcuaW5jbHVkZXMoJ1xcdCcpO1xuICAgICAgICBpZiAob2xkSGFzVGFicyAmJiAhbmV3SGFzVGFicykge1xuICAgICAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICAgICAgY29kZTogJ0VESVRfV0hJVEVTUEFDRV9NSVNNQVRDSCcsXG4gICAgICAgICAgICBtZXNzYWdlOiAnb2xkX3N0cmluZyB1c2VzIHRhYnMsIG5ld19zdHJpbmcgdXNlcyBzcGFjZXMnLFxuICAgICAgICAgICAgc2V2ZXJpdHk6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgIHN1Z2dlc3Rpb246ICdXaGl0ZXNwYWNlIHR5cGUgbWlzbWF0Y2ggbWF5IGNhdXNlIEVkaXQgdG8gZmFpbC4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBTZWFyY2ggT3BlcmF0aW9ucyBWYWxpZGF0aW9uIC0gT25seSBmbGFnIHRydWx5IHByb2JsZW1hdGljIHBhdHRlcm5zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgaWYgKHRvb2xMb3dlciA9PT0gJ2dyZXAnIHx8IHRvb2xMb3dlciA9PT0gJ2dsb2InIHx8IHRvb2xMb3dlci5pbmNsdWRlcygnc2VhcmNoJykpIHtcbiAgICBjb25zdCBwYXR0ZXJuQXJnID0gYXJnc1sncGF0dGVybiddO1xuICAgIGNvbnN0IHBhdHRlcm4gPSB0eXBlb2YgcGF0dGVybkFyZyA9PT0gJ3N0cmluZycgPyBwYXR0ZXJuQXJnLnRyaW0oKSA6ICcnO1xuICAgIGNvbnN0IGlzR3JlcFRvb2wgPSB0b29sTG93ZXIuaW5jbHVkZXMoJ2dyZXAnKTtcblxuICAgIGlmIChwYXR0ZXJuKSB7XG4gICAgICAvLyBPbmx5IHdhcm4gb24gdHJ1bHkgYnJvYWQgcGF0dGVybnMgdGhhdCB3b3VsZCBtYXRjaCBldmVyeXRoaW5nXG4gICAgICBpZiAoaXNCcm9hZEJhc2VQYXR0ZXJuKHBhdHRlcm4pKSB7XG4gICAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICAgIGNvZGU6ICdTRUFSQ0hfQlJPQURfUEFUVEVSTicsXG4gICAgICAgICAgbWVzc2FnZTogYFBhdHRlcm4gJyR7cGF0dGVybn0nIGlzIHRvbyBicm9hZCBhbmQgbWF5IHJldHVybiB0aG91c2FuZHMgb2YgZmlsZXNgLFxuICAgICAgICAgIHNldmVyaXR5OiAnY3JpdGljYWwnLFxuICAgICAgICAgIHN1Z2dlc3Rpb246IFwiVXNlIHRhcmdldGVkIHBhdHRlcm5zIGxpa2UgJyoqLyoudHMnIG9yICdzcmMvKiovKi5qcycuXCIsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBGb3IgZ3JlcDogb25seSB3YXJuIG9uIHBhdHRlcm5zIHRoYXQgbGl0ZXJhbGx5IG1hdGNoIGV2ZXJ5dGhpbmdcbiAgICAgIGlmIChpc0dyZXBUb29sICYmIGlzVmVyeUJyb2FkUmVnZXgocGF0dGVybikpIHtcbiAgICAgICAgY29uc3QgaGFzRmlsZUZpbHRlcnMgPSB0eXBlb2YgYXJnc1snZ2xvYiddID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYXJnc1sndHlwZSddID09PSAnc3RyaW5nJztcbiAgICAgICAgaWYgKCFoYXNGaWxlRmlsdGVycykge1xuICAgICAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICAgICAgY29kZTogJ1NFQVJDSF9DT05URVhUX09WRVJGTE9XX1JJU0snLFxuICAgICAgICAgICAgbWVzc2FnZTogYFJlZ2V4IHBhdHRlcm4gJyR7cGF0dGVybn0nIG1hdGNoZXMgZXZlcnl0aGluZ2AsXG4gICAgICAgICAgICBzZXZlcml0eTogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgc3VnZ2VzdGlvbjogJ1VzZSBhIG1vcmUgc3BlY2lmaWMgcGF0dGVybiBvciBhZGQgYSBnbG9iL3R5cGUgZmlsdGVyLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEJhc2ggQ29tbWFuZCBFZmZpY2llbmN5XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgaWYgKHRvb2xMb3dlciA9PT0gJ2Jhc2gnIHx8IHRvb2xMb3dlciA9PT0gJ2V4ZWN1dGVfYmFzaCcpIHtcbiAgICBjb25zdCBjb21tYW5kID0gU3RyaW5nKGFyZ3NbJ2NvbW1hbmQnXSB8fCAnJyk7XG4gICAgY29uc3QgZmxvd1dhcm5pbmdzID0gYW5hbHl6ZUJhc2hGbG93KGNvbW1hbmQpO1xuXG4gICAgZm9yIChjb25zdCBmbG93IG9mIGZsb3dXYXJuaW5ncykge1xuICAgICAgd2FybmluZ3MucHVzaCh7XG4gICAgICAgIGNvZGU6IGZsb3cuY29kZSxcbiAgICAgICAgbWVzc2FnZTogZmxvdy5tZXNzYWdlLFxuICAgICAgICBzZXZlcml0eTogZmxvdy5zZXZlcml0eSA9PT0gJ2NyaXRpY2FsJyA/ICdjcml0aWNhbCcgOiBmbG93LnNldmVyaXR5ID09PSAnaW5mbycgPyAnaW5mbycgOiAnd2FybmluZycsXG4gICAgICAgIHN1Z2dlc3Rpb246IGZsb3cuc3VnZ2VzdGlvbiA/PyBmbG93Lm1lc3NhZ2UsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd2FybmluZ3M7XG59XG5cbi8qKlxuICogRW5oYW5jZWQgQUkgZmxvdyB2YWxpZGF0aW9uIGZvciBUeXBlU2NyaXB0IHNvZnR3YXJlIGVuZ2luZWVyaW5nXG4gKiBQcm92aWRlcyBjb21wcmVoZW5zaXZlIHZhbGlkYXRpb24gb2YgQUkgdG9vbCB1c2FnZSBwYXR0ZXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBSUZsb3dQYXR0ZXJucyhcbiAgdG9vbE5hbWU6IHN0cmluZyxcbiAgYXJnczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIHRvb2xIaXN0b3J5OiByZWFkb25seSBUb29sSGlzdG9yeUNhbGxbXVxuKTogUHJlZmxpZ2h0V2FybmluZ1tdIHtcbiAgY29uc3Qgd2FybmluZ3M6IFByZWZsaWdodFdhcm5pbmdbXSA9IFtdO1xuICBjb25zdCB0b29sTG93ZXIgPSB0b29sTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIFBhdHRlcm46IEVkaXQgd2l0aG91dCBwcmlvciBSZWFkIC0gQ3JpdGljYWwgZm9yIGhhbGx1Y2luYXRpb24gcmVkdWN0aW9uXG4gIGlmICh0b29sTG93ZXIgPT09ICdlZGl0Jykge1xuICAgIGNvbnN0IHRhcmdldFBhdGggPSBub3JtYWxpemVGaWxlUGF0aChhcmdzWydmaWxlX3BhdGgnXSk7XG4gICAgY29uc3QgaXNOZXdGaWxlQ3JlYXRpb24gPSBpc05ld0ZpbGVFZGl0KGFyZ3NbJ29sZF9zdHJpbmcnXSk7XG4gICAgY29uc3QgaGFzUmVjZW50UmVhZCA9IGhhc01hdGNoaW5nUmVhZCh0b29sSGlzdG9yeSwgdGFyZ2V0UGF0aCk7XG5cbiAgICBpZiAoIWlzTmV3RmlsZUNyZWF0aW9uICYmICFoYXNSZWNlbnRSZWFkKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgICAgY29kZTogRURJVF9XSVRIT1VUX1JFQUQsXG4gICAgICAgIG1lc3NhZ2U6ICdFZGl0IGF0dGVtcHRlZCB3aXRob3V0IHByaW9yIGZpbGUgcmVhZCAtIEhJR0ggSEFMTFVDSU5BVElPTiBSSVNLJyxcbiAgICAgICAgc2V2ZXJpdHk6ICdjcml0aWNhbCcsXG4gICAgICAgIHN1Z2dlc3Rpb246ICdBTFdBWVMgdXNlIFJlYWQgdG9vbCBmaXJzdCB0byBnZXQgZXhhY3QgdGV4dCBpbmNsdWRpbmcgd2hpdGVzcGFjZSBhbmQgaW5kZW50YXRpb24uIE5ldmVyIGd1ZXNzIGZpbGUgY29udGVudC4nLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUGF0dGVybjogTXVsdGlwbGUgdmFsaWRhdGlvbiBydW5zXG4gIGlmICh0b29sTG93ZXIgPT09ICdydW5fcmVwb19jaGVja3MnIHx8IHRvb2xMb3dlciA9PT0gJ3J1bl90ZXN0cycgfHwgdG9vbExvd2VyID09PSAncnVuX2J1aWxkJykge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgcmVjZW5jeVdpbmRvd01zID0gMTUgKiA2MCAqIDEwMDA7IC8vIE9ubHkgd2FybiB3aGVuIHZhbGlkYXRpb25zIGFyZSBjbHVzdGVyZWRcbiAgICBjb25zdCByZWNlbnRWYWxpZGF0aW9ucyA9IHRvb2xIaXN0b3J5XG4gICAgICAuZmlsdGVyKChjYWxsKSA9PlxuICAgICAgICBjYWxsLnRvb2xOYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3J1bl8nKSB8fFxuICAgICAgICBjYWxsLnRvb2xOYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3Rlc3QnKSB8fFxuICAgICAgICBjYWxsLnRvb2xOYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2J1aWxkJylcbiAgICAgIClcbiAgICAgIC5maWx0ZXIoKGNhbGwpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsLnRpbWVzdGFtcCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm93IC0gY2FsbC50aW1lc3RhbXAgPD0gcmVjZW5jeVdpbmRvd01zO1xuICAgICAgfSk7XG5cbiAgICBpZiAocmVjZW50VmFsaWRhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgd2FybmluZ3MucHVzaCh7XG4gICAgICAgIGNvZGU6ICdERUZFUlJFRF9WQUxJREFUSU9OX1JFTUlOREVSJyxcbiAgICAgICAgbWVzc2FnZTogJ1ZhbGlkYXRpb24gYWxyZWFkeSByYW4gcmVjZW50bHk7IGJhdGNoIGVkaXRzIGFuZCBydW4gb25lIGZpbmFsIHBhc3MgYXQgdGhlIGVuZC4nLFxuICAgICAgICBzZXZlcml0eTogJ2luZm8nLFxuICAgICAgICBzdWdnZXN0aW9uOiAnRmluaXNoIGltcGxlbWVudGF0aW9uIHdvcmsgZmlyc3QsIHRoZW4gcnVuIGEgc2luZ2xlIGJ1aWxkL3Rlc3QvY2hlY2sgc3RlcCB0byB2YWxpZGF0ZS4nLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUGF0dGVybjogRXhjZXNzaXZlIGdpdCBzdGF0dXMgY2FsbHMgKGFjdHVhbGx5IHdhc3RlZnVsKVxuICAvLyBOb3RlOiBNdWx0aXBsZSBnaXQgb3BlcmF0aW9ucyBpbiBzZXF1ZW5jZSAoYWRkLCBjb21taXQsIHB1c2gpIGlzIGZpbmUgLSBkb24ndCB3YXJuIG9uIHRoYXRcbiAgaWYgKHRvb2xMb3dlci5pbmNsdWRlcygnZ2l0JykpIHtcbiAgICBjb25zdCBjb21tYW5kID0gU3RyaW5nKGFyZ3NbJ2NvbW1hbmQnXSB8fCAnJyk7XG4gICAgaWYgKGNvbW1hbmQuaW5jbHVkZXMoJ2dpdCBzdGF0dXMnKSkge1xuICAgICAgY29uc3QgcmVjZW50U3RhdHVzQ2FsbHMgPSB0b29sSGlzdG9yeS5maWx0ZXIoXG4gICAgICAgIChjYWxsKSA9PiB7XG4gICAgICAgICAgY29uc3QgY21kID0gU3RyaW5nKGNhbGwuYXJnc1snY29tbWFuZCddIHx8ICcnKTtcbiAgICAgICAgICByZXR1cm4gY21kLmluY2x1ZGVzKCdnaXQgc3RhdHVzJyk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICAvLyBPbmx5IHdhcm4gaWYgdGhlcmUgYXJlIDMrIHN0YXR1cyBjYWxscyAtIDIgaXMgbm9ybWFsIChiZWZvcmUgYW5kIGFmdGVyIG9wZXJhdGlvbnMpXG4gICAgICBpZiAocmVjZW50U3RhdHVzQ2FsbHMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgd2FybmluZ3MucHVzaCh7XG4gICAgICAgICAgY29kZTogJ0dJVF9SRURVTkRBTlRfU1RBVFVTJyxcbiAgICAgICAgICBtZXNzYWdlOiAnTXVsdGlwbGUgZ2l0IHN0YXR1cyBjYWxscyBkZXRlY3RlZCcsXG4gICAgICAgICAgc2V2ZXJpdHk6ICdpbmZvJyxcbiAgICAgICAgICBzdWdnZXN0aW9uOiAnT25lIGdpdCBzdGF0dXMgY2FsbCBpcyB1c3VhbGx5IHN1ZmZpY2llbnQuJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdhcm5pbmdzO1xufVxuXG5mdW5jdGlvbiBpc0Jyb2FkQmFzZVBhdHRlcm4ocGF0dGVybjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIE9ubHkgdGhlIHRydWx5IHVuaXZlcnNhbCBwYXR0ZXJucyB0aGF0IG1hdGNoIGV2ZXJ5dGhpbmdcbiAgcmV0dXJuIHBhdHRlcm4gPT09ICcuJyB8fCBwYXR0ZXJuID09PSAnKicgfHwgcGF0dGVybiA9PT0gJyoqJyB8fCBwYXR0ZXJuID09PSAnKiovKic7XG59XG5cbmZ1bmN0aW9uIGlzVmVyeUJyb2FkUmVnZXgocGF0dGVybjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBwYXR0ZXJuLnRyaW0oKTtcbiAgcmV0dXJuIG5vcm1hbGl6ZWQgPT09ICcuKicgfHwgbm9ybWFsaXplZCA9PT0gJy4rJyB8fCBub3JtYWxpemVkID09PSAnLic7XG59XG5cbmZ1bmN0aW9uIGhhc01hdGNoaW5nUmVhZChcbiAgdG9vbEhpc3Rvcnk6IHJlYWRvbmx5IFRvb2xIaXN0b3J5Q2FsbFtdLFxuICB0YXJnZXRQYXRoOiBzdHJpbmcgfCBudWxsXG4pOiBib29sZWFuIHtcbiAgaWYgKCF0YXJnZXRQYXRoKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHRvb2xIaXN0b3J5LnNvbWUoKGNhbGwpID0+IHtcbiAgICBjb25zdCBjYWxsTG93ZXIgPSBjYWxsLnRvb2xOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCFjYWxsTG93ZXIuaW5jbHVkZXMoJ3JlYWQnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHJlYWRQYXRoID0gbm9ybWFsaXplRmlsZVBhdGgoY2FsbC5hcmdzWydwYXRoJ10gPz8gY2FsbC5hcmdzWydmaWxlX3BhdGgnXSk7XG4gICAgcmV0dXJuIEJvb2xlYW4ocmVhZFBhdGggJiYgcmVhZFBhdGggPT09IHRhcmdldFBhdGgpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNOZXdGaWxlRWRpdChvbGRTdHJpbmc6IHVua25vd24pOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVvZiBvbGRTdHJpbmcgPT09ICdzdHJpbmcnICYmIG9sZFN0cmluZy5sZW5ndGggPT09IDA7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUZpbGVQYXRoKHBhdGhWYWx1ZTogdW5rbm93bik6IHN0cmluZyB8IG51bGwge1xuICBpZiAodHlwZW9mIHBhdGhWYWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHRyaW1tZWQgPSBwYXRoVmFsdWUudHJpbSgpO1xuICBpZiAoIXRyaW1tZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVBhdGgodHJpbW1lZCk7XG4gICAgY29uc3QgYWJzb2x1dGVQYXRoID0gaXNBYnNvbHV0ZShub3JtYWxpemVkKSA/IG5vcm1hbGl6ZWQgOiByZXNvbHZlUGF0aChwcm9jZXNzLmN3ZCgpLCBub3JtYWxpemVkKTtcblxuICAgIC8vIFJlc29sdmUgc3ltbGlua3Mgb24gdGhlIGRlZXBlc3QgZXhpc3RpbmcgZGlyZWN0b3J5IHRvIGF2b2lkIC92YXIgdnMgL3ByaXZhdGUvdmFyIG1pc21hdGNoZXNcbiAgICBsZXQgY3VycmVudERpciA9IGRpcm5hbWUoYWJzb2x1dGVQYXRoKTtcbiAgICBsZXQgc3VmZml4ID0gYmFzZW5hbWUoYWJzb2x1dGVQYXRoKTtcblxuICAgIC8vIExvb3AgdW50aWwgd2UgZmluZCBhbiBleGlzdGluZyBhbmNlc3RvciBvciBoaXQgdGhlIGZpbGVzeXN0ZW0gcm9vdC5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChleGlzdHNTeW5jKGN1cnJlbnREaXIpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVhbERpciA9IHJlYWxwYXRoU3luYyhjdXJyZW50RGlyKTtcbiAgICAgICAgICByZXR1cm4gbm9ybWFsaXplUGF0aChqb2luKHJlYWxEaXIsIHN1ZmZpeCkpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAvLyBJZiByZWFscGF0aCBmYWlscywgZmFsbCB0aHJvdWdoIHRvIHRoZSBkZWZhdWx0IG5vcm1hbGl6YXRpb25cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJlbnREaXIgPSBkaXJuYW1lKGN1cnJlbnREaXIpO1xuICAgICAgaWYgKHBhcmVudERpciA9PT0gY3VycmVudERpcikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgc3VmZml4ID0gam9pbihiYXNlbmFtZShjdXJyZW50RGlyKSwgc3VmZml4KTtcbiAgICAgIGN1cnJlbnREaXIgPSBwYXJlbnREaXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZVBhdGgoYWJzb2x1dGVQYXRoKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHRyaW1tZWQ7XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxJQUFBQSxPQUFBLEdBQUFDLE9BQUE7QUFDQSxJQUFBQyxTQUFBLEdBQUFELE9BQUE7QUFDQSxJQUFBRSxvQkFBQSxHQUFBRixPQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBUU8sTUFBTUcsaUJBQWlCLEdBQUFDLE9BQUEsQ0FBQUQsaUJBQUEsR0FBRyxtQkFBbUI7QUFRcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LGFBQWFBLENBQUNsQyxTQUFrQixFQUFXO0VBQ2xELE9BQU8sT0FBT0EsU0FBUyxLQUFLLFFBQVEsSUFBSUEsU0FBUyxDQUFDNEMsTUFBTSxLQUFLLENBQUM7QUFDaEU7QUFFQSxTQUFTWixpQkFBaUJBLENBQUNtQixTQUFrQixFQUFpQjtFQUM1RCxJQUFJLE9BQU9BLFNBQVMsS0FBSyxRQUFRLEVBQUU7SUFDakMsT0FBTyxJQUFJO0VBQ2I7RUFFQSxNQUFNQyxPQUFPLEdBQUdELFNBQVMsQ0FBQ2hDLElBQUksQ0FBQyxDQUFDO0VBQ2hDLElBQUksQ0FBQ2lDLE9BQU8sRUFBRTtJQUNaLE9BQU8sSUFBSTtFQUNiO0VBRUEsSUFBSTtJQUNGLE1BQU1MLFVBQVUsR0FBRyxJQUFBTSxtQkFBYSxFQUFDRCxPQUFPLENBQUM7SUFDekMsTUFBTUUsWUFBWSxHQUFHLElBQUFDLG9CQUFVLEVBQUNSLFVBQVUsQ0FBQyxHQUFHQSxVQUFVLEdBQUcsSUFBQVMsaUJBQVcsRUFBQ0MsT0FBTyxDQUFDQyxHQUFHLENBQUMsQ0FBQyxFQUFFWCxVQUFVLENBQUM7O0lBRWpHO0lBQ0EsSUFBSVksVUFBVSxHQUFHLElBQUFDLGlCQUFPLEVBQUNOLFlBQVksQ0FBQztJQUN0QyxJQUFJTyxNQUFNLEdBQUcsSUFBQUMsa0JBQVEsRUFBQ1IsWUFBWSxDQUFDOztJQUVuQztJQUNBO0lBQ0EsT0FBTyxJQUFJLEVBQUU7TUFDWCxJQUFJLElBQUFTLGtCQUFVLEVBQUNKLFVBQVUsQ0FBQyxFQUFFO1FBQzFCLElBQUk7VUFDRixNQUFNSyxPQUFPLEdBQUcsSUFBQUMsb0JBQVksRUFBQ04sVUFBVSxDQUFDO1VBQ3hDLE9BQU8sSUFBQU4sbUJBQWEsRUFBQyxJQUFBYSxjQUFJLEVBQUNGLE9BQU8sRUFBRUgsTUFBTSxDQUFDLENBQUM7UUFDN0MsQ0FBQyxDQUFDLE1BQU07VUFDTjtVQUNBO1FBQ0Y7TUFDRjtNQUVBLE1BQU1NLFNBQVMsR0FBRyxJQUFBUCxpQkFBTyxFQUFDRCxVQUFVLENBQUM7TUFDckMsSUFBSVEsU0FBUyxLQUFLUixVQUFVLEVBQUU7UUFDNUI7TUFDRjtNQUVBRSxNQUFNLEdBQUcsSUFBQUssY0FBSSxFQUFDLElBQUFKLGtCQUFRLEVBQUNILFVBQVUsQ0FBQyxFQUFFRSxNQUFNLENBQUM7TUFDM0NGLFVBQVUsR0FBR1EsU0FBUztJQUN4QjtJQUVBLE9BQU8sSUFBQWQsbUJBQWEsRUFBQ0MsWUFBWSxDQUFDO0VBQ3BDLENBQUMsQ0FBQyxNQUFNO0lBQ04sT0FBT0YsT0FBTztFQUNoQjtBQUNGIiwiaWdub3JlTGlzdCI6W119