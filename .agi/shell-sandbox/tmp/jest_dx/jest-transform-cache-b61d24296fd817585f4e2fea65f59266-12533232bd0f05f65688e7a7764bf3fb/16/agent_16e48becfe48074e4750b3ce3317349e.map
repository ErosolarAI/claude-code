{"version":3,"names":["_nodePath","_interopRequireDefault","require","_multilinePasteHandler","_secretStore","_debugLogger","_finalResponseFormatter","e","__esModule","default","MAX_CONTEXT_RECOVERY_ATTEMPTS","isContextOverflowError","error","Error","message","toLowerCase","includes","isTransientError","networkPatterns","some","p","MAX_TRANSIENT_RETRIES","getRetryDelay","attempt","Math","min","pow","sleep","ms","Promise","resolve","setTimeout","AgentRuntime","messages","activeRun","cancellationRequested","lastToolCallSignature","repeatedToolCallCount","MAX_REPEATED_TOOL_CALLS","totalContextRecoveries","MAX_TOTAL_RECOVERIES","recentToolCalls","TOOL_HISTORY_SIZE","BEHAVIORAL_LOOP_THRESHOLD","EDIT_CONTEXT_CHAR_LIMIT","NON_CACHEABLE_TOOL_NAMES","Set","LOOP_EXEMPT_TOOL_NAMES","toolResultCache","Map","TOOL_CACHE_MAX_SIZE","toolHistoryCursor","modelInfo","modelInfoFetched","constructor","options","provider","toolRuntime","callbacks","contextManager","providerId","modelId","workingDirectory","process","cwd","explainEdits","trimmedPrompt","systemPrompt","trim","baseSystemPrompt","push","role","content","requestCancellation","isCancellationRequested","isRunning","isEditToolCall","toolName","name","getEditedFilePath","call","args","arguments","rawPath","relativePath","path","relative","startsWith","getEditedFiles","toolCalls","files","filePath","send","text","useStreaming","prompt","onRequestReceived","slice","resetBehavioralLoopTracking","getToolHistory","length","isMultilinePaste","processed","processPaste","onMultilinePaste","displaySummary","metadata","fullContent","run","startedAt","Date","now","generateStream","processConversationStreaming","processConversation","contextRecoveryAttempts","transientRetryAttempts","onCancelled","pruneMessagesIfNeeded","response","generate","providerTools","usage","contextStats","getContextStats","type","behavioralLoopResult","checkBehavioralLoop","emitAssistantMessage","isFinal","signatureCalls","filter","shouldSkipLoopDetection","toolSignature","map","t","JSON","stringify","sort","join","loopMsg","narration","maybeAckToolCalls","Boolean","assistantMessage","resolveToolCalls","reply","output","finalReply","ensureNextSteps","triggerVerificationIfNeeded","canRecover","recovered","recoverFromContextOverflow","onContinueAfterRecovery","delayMs","onRetrying","STREAM_HARD_CHAR_LIMIT","totalCharsReceived","truncatedResponse","reasoningContent","suppressStreamNarration","shouldSuppressToolNarration","bufferedContent","logDebug","stream","iterator","Symbol","asyncIterator","streamClosed","closeStream","return","closeError","safeErrorMessage","describeChunk","chunk","snippet","debugSnippet","toolCall","totalTokens","chunkCount","result","next","chunkLabel","done","value","partial","nextContent","nextBuffered","onStreamChunk","onUsage","combinedContent","notice","updated","wasStreamed","wasReasoningUsedAsReply","appended","numCalls","executedEdits","toolCallId","id","cached","getCachedToolResult","onToolExecution","execute","cacheToolResult","fromCache","maybeExplainEdits","cachedResults","toExecute","toolNames","c","executed","all","originalCall","find","r","CHUNK_SIZE","allResults","i","cachedInChunk","toExecuteInChunk","chunkNames","truncateEditOutput","limit","head","floor","tail","omitted","buildEditExplanationPrompt","toolOutput","fileLine","userContent","results","truncatedOutput","explanation","onEditExplanation","listProviderTools","elapsedMs","undefined","payload","onAssistantMessage","onVerificationNeeded","verifiablePatterns","hasVerifiableClaims","pattern","test","conversationHistory","recentMessages","msg","model","extractCmdHash","cmd","replace","String","firstArg","Object","values","loopEligibleCalls","nonCachedCalls","existingCounts","cmdHash","key","set","get","currentCount","shift","hasModelNarration","acknowledgement","onBeforeFirstToolCall","getToolCacheKey","sortedArgs","keys","reduce","acc","isCacheableTool","nameLower","has","size","firstKey","delete","drainToolExecutions","history","newEntries","entry","success","hasOutput","getHistory","cloneMessage","loadHistory","clearHistory","isApproachingLimit","pruneMessagesWithSummary","removed","pruned","stats","getStats","enrichedStats","summarized","method","onContextPruned","env","percentage","getContextManager","fetchModelInfo","getModelInfo","getContextWindowFromProvider","info","contextWindow","reductionPercentages","reductionPercent","toolOutputLimits","toolOutputLimit","round","onContextRecovery","onContextSquishing","systemMessages","conversationMessages","targetRemoveCount","turns","currentTurn","targetTurnsToRemove","keepTurns","startIndex","firstTurn","firstMsg","toolCallIds","tc","presentToolResultIds","m","allPresent","validTurns","keepMessages","flat","actualRemoveCount","truncatedCount","truncated","lastNewline","lastIndexOf","cutPoint","sys","removedPercent","turnsRemoved","truncatedOutputs","newStats","minLimit","exports","clone","cloneToolCall"],"sources":["agent.ts"],"sourcesContent":["import path from 'node:path';\nimport type { IToolRuntime } from './toolRuntime.js';\nimport {\n  type ConversationMessage,\n  type LLMProvider,\n  type ProviderModelInfo,\n  type ProviderToolDefinition,\n  type ToolCallRequest,\n  type ProviderUsage,\n  type StreamChunk,\n} from './types.js';\nimport { ContextManager } from './contextManager.js';\nimport { isMultilinePaste, processPaste, type PasteSummary } from './multilinePasteHandler.js';\nimport { safeErrorMessage } from './secretStore.js';\nimport { logDebug, debugSnippet } from '../utils/debugLogger.js';\nimport { ensureNextSteps } from './finalResponseFormatter.js';\n\n/**\n * Maximum number of context overflow recovery attempts\n */\nconst MAX_CONTEXT_RECOVERY_ATTEMPTS = 3;\n\n// Streaming runs without timeouts - we let the model take as long as it needs\n\n/**\n * Check if an error is a context overflow error\n */\nfunction isContextOverflowError(error: unknown): boolean {\n  if (!(error instanceof Error)) return false;\n  const message = error.message.toLowerCase();\n  return (\n    message.includes('context length') ||\n    message.includes('token') && (message.includes('limit') || message.includes('exceed') || message.includes('maximum')) ||\n    message.includes('too long') ||\n    message.includes('too many tokens') ||\n    message.includes('max_tokens') ||\n    message.includes('context window')\n  );\n}\n\n/**\n * Check if an error is a transient/retryable error (network issues, rate limits, server errors)\n */\nfunction isTransientError(error: unknown): boolean {\n  if (!(error instanceof Error)) return false;\n  const message = error.message.toLowerCase();\n\n  // Network errors\n  const networkPatterns = [\n    'econnrefused', 'econnreset', 'enotfound', 'etimedout', 'epipe',\n    'network error', 'connection error', 'fetch failed', 'socket hang up',\n    'network is unreachable', 'connection refused', 'connection reset',\n  ];\n  if (networkPatterns.some(p => message.includes(p))) {\n    return true;\n  }\n\n  // Rate limit errors\n  if (message.includes('rate limit') || message.includes('429') || message.includes('too many requests')) {\n    return true;\n  }\n\n  // Server errors (5xx)\n  if (message.includes('500') || message.includes('502') || message.includes('503') || message.includes('504')) {\n    return true;\n  }\n\n  // Temporary service errors\n  if (message.includes('service unavailable') || message.includes('temporarily unavailable') ||\n      message.includes('overloaded') || message.includes('server error')) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Maximum number of transient error retries\n */\nconst MAX_TRANSIENT_RETRIES = 3;\n\n/**\n * Delay before retry (in ms), with exponential backoff\n */\nfunction getRetryDelay(attempt: number): number {\n  // Base delay of 1 second, doubles each attempt: 1s, 2s, 4s\n  return Math.min(1000 * Math.pow(2, attempt - 1), 10000);\n}\n\n/**\n * Sleep for the specified milliseconds\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nexport interface AgentCallbacks {\n  onAssistantMessage?(content: string, metadata: AssistantMessageMetadata): void;\n  onStreamChunk?(chunk: string, type?: 'content' | 'reasoning'): void;\n  /** Called when real token usage is received from the provider during streaming */\n  onUsage?(usage: ProviderUsage): void;\n  onContextPruned?(removedCount: number, stats: Record<string, unknown>): void;\n  /** Called when auto context squishing occurs in background */\n  onContextSquishing?(message: string): void;\n  /** Called when context recovery from overflow is attempted */\n  onContextRecovery?(attempt: number, maxAttempts: number, message: string): void;\n  /** Called when agent continues after context recovery - useful for updating UI */\n  onContinueAfterRecovery?(): void;\n  /** Called when multi-line paste is detected - displays summary instead of full content */\n  onMultilinePaste?(summary: string, metadata: PasteSummary): void;\n  /** Called when verification should be triggered for a final response */\n  onVerificationNeeded?(response: string, context: VerificationCallbackContext): void;\n  /** Called when the operation is cancelled by the user */\n  onCancelled?(): void;\n  /** Called when tool execution starts - useful for updating activity status */\n  onToolExecution?(toolName: string, isStart: boolean, args?: Record<string, unknown>): void;\n  /** Called when the agent generates an explanation for a completed edit */\n  onEditExplanation?(payload: EditExplanationPayload): void;\n  /**\n   * Called IMMEDIATELY when a user request is received, BEFORE any provider call.\n   * Useful for updating UI activity without showing filler messages.\n   */\n  onRequestReceived?(requestPreview: string): void;\n  /**\n   * Called BEFORE the first tool call in a turn, allowing UI to update activity state.\n   * @param toolNames - Names of tools about to be called\n   * @param hasModelNarration - Whether the model provided narration/thinking before tools\n   * @returns Optional acknowledgement text to display (if model didn't provide narration)\n   */\n  onBeforeFirstToolCall?(toolNames: string[], hasModelNarration: boolean): string | undefined;\n  /**\n   * Called when the agent encounters a transient error and will retry.\n   * @param attempt - Current retry attempt number\n   * @param maxAttempts - Maximum retry attempts\n   * @param error - The error that triggered the retry\n   */\n  onRetrying?(attempt: number, maxAttempts: number, error: Error): void;\n}\n\nexport interface ToolExecutionRecord {\n  name: string;\n  success: boolean;\n  hasOutput: boolean;\n}\n\nexport interface VerificationCallbackContext {\n  /** Working directory for verification */\n  workingDirectory: string;\n  /** Recent conversation history for context */\n  conversationHistory: string[];\n  /** Provider ID */\n  provider: string;\n  /** Model ID */\n  model: string;\n}\n\nexport interface AssistantMessageMetadata {\n  isFinal: boolean;\n  elapsedMs?: number;\n  usage?: ProviderUsage | null;\n  contextStats?: Record<string, unknown> | null;\n  /** True if content was already displayed via streaming chunks */\n  wasStreamed?: boolean;\n  /** Hint to UI to suppress rendering of internal/system filler messages */\n  suppressDisplay?: boolean;\n}\n\nexport interface EditExplanationPayload {\n  explanation: string;\n  files: string[];\n  toolName: string;\n  toolCallId?: string;\n}\n\n\ninterface AgentOptions {\n  provider: LLMProvider;\n  toolRuntime: IToolRuntime;\n  systemPrompt: string;\n  callbacks?: AgentCallbacks;\n  contextManager?: ContextManager;\n  /** Provider ID for verification context */\n  providerId?: string;\n  /** Model ID for verification context */\n  modelId?: string;\n  /** Working directory for verification */\n  workingDirectory?: string;\n  /** Whether to generate and surface explanations after edit tools complete */\n  explainEdits?: boolean;\n}\n\nexport class AgentRuntime {\n  private readonly messages: ConversationMessage[] = [];\n  private readonly provider: LLMProvider;\n  private readonly toolRuntime: IToolRuntime;\n  private readonly callbacks: AgentCallbacks;\n  private readonly contextManager: ContextManager | null;\n  private activeRun: { startedAt: number } | null = null;\n  private readonly baseSystemPrompt: string | null;\n  private readonly providerId: string;\n  private readonly modelId: string;\n  private readonly workingDirectory: string;\n  private readonly explainEdits: boolean;\n  private cancellationRequested = false;\n  // Loop detection: track last tool calls to detect stuck loops\n  private lastToolCallSignature: string | null = null;\n  private repeatedToolCallCount = 0;\n  private static readonly MAX_REPEATED_TOOL_CALLS = 5; // Stop on 5th identical call (4 allowed)\n\n  // Session-level context recovery tracking to prevent endless recovery loops\n  private totalContextRecoveries = 0;\n  private static readonly MAX_TOTAL_RECOVERIES = 5; // Max recoveries across entire session\n\n  // Behavioral loop detection: track recent tool calls to catch repetitive patterns\n  // e.g., calling \"execute_bash\" with \"git status\" 5 times even if output differs slightly\n  private recentToolCalls: Array<{ name: string; cmdHash: string }> = [];\n  private static readonly TOOL_HISTORY_SIZE = 12;\n  private static readonly BEHAVIORAL_LOOP_THRESHOLD = 3; // Same tool+cmd 3+ times in last 12 = stuck\n  private static readonly EDIT_CONTEXT_CHAR_LIMIT = 4000;\n\n  // Never cache stateful tools - they must always execute to reflect current system state\n  private static readonly NON_CACHEABLE_TOOL_NAMES = new Set([\n    'bash',\n    'execute_bash',\n    'execute_command',\n    'run_command',\n    'edit',\n    'edit_file',\n    'write',\n    'write_file',\n    'notebookedit',\n    'read',\n    'read_file',\n    'read_files',\n    'list_files',\n    'list_dir',\n    'glob',\n    'grep',\n    'search',\n    'search_text',\n    'git_status',\n    'git_diff',\n    'git_log',\n    'git_commit',\n    'git_push',\n  ]);\n\n  // Skip loop short-circuiting for direct execution tools to avoid blocking user commands\n  private static readonly LOOP_EXEMPT_TOOL_NAMES = new Set([\n    'bash',\n    'execute_bash',\n    'execute_command',\n    'run_command',\n    'edit',\n    'edit_file',\n    'write',\n    'write_file',\n    'notebookedit',\n    // Read/search tools are noise-prone and often repeated legitimately\n    'read',\n    'read_file',\n    'read_files',\n    'list_files',\n    'list_dir',\n    'glob',\n    'glob_search',\n    'grep',\n    'search',\n  ]);\n\n  // Tool result cache: prevent duplicate identical tool calls by returning cached results\n  // Key: tool signature (name + JSON args), Value: result string\n  private toolResultCache = new Map<string, string>();\n  private static readonly TOOL_CACHE_MAX_SIZE = 50; // Keep last 50 tool results\n\n  // Track tool history position per send() call for accurate progress detection\n  private toolHistoryCursor = 0;\n\n  // Cached model info from provider API (real context window limits)\n  private modelInfo: ProviderModelInfo | null = null;\n  private modelInfoFetched = false;\n\n  constructor(options: AgentOptions) {\n    this.provider = options.provider;\n    this.toolRuntime = options.toolRuntime;\n    this.callbacks = options.callbacks ?? {};\n    this.contextManager = options.contextManager ?? null;\n    this.providerId = options.providerId ?? 'unknown';\n    this.modelId = options.modelId ?? 'unknown';\n    this.workingDirectory = options.workingDirectory ?? process.cwd();\n    this.explainEdits = options.explainEdits ?? false;\n\n    const trimmedPrompt = options.systemPrompt.trim();\n    this.baseSystemPrompt = trimmedPrompt || null;\n    if (trimmedPrompt) {\n      this.messages.push({ role: 'system', content: trimmedPrompt });\n    }\n  }\n\n  /**\n   * Request cancellation of the current operation.\n   * The agent will stop at the next safe point (after current tool completes).\n   */\n  requestCancellation(): void {\n    this.cancellationRequested = true;\n  }\n\n  /**\n   * Check if cancellation has been requested.\n   */\n  isCancellationRequested(): boolean {\n    return this.cancellationRequested;\n  }\n\n  /**\n   * Check if the agent is currently processing a request.\n   */\n  isRunning(): boolean {\n    return this.activeRun !== null;\n  }\n\n  /**\n   * Check if any of the tool calls are edit operations (Edit, Write)\n   */\n  private isEditToolCall(toolName: string): boolean {\n    const name = toolName.toLowerCase();\n    return name === 'edit' || name === 'edit_file' || name === 'write' || name === 'write_file';\n  }\n\n  /**\n   * Extract a display-friendly file path from a tool call (prefers workspace-relative path)\n   */\n  private getEditedFilePath(call: ToolCallRequest): string | null {\n    const args = call.arguments as Record<string, unknown>;\n    const rawPath = typeof args['file_path'] === 'string'\n      ? args['file_path']\n      : typeof args['path'] === 'string'\n        ? args['path']\n        : null;\n\n    if (!rawPath) {\n      return null;\n    }\n\n    const relativePath = path.relative(this.workingDirectory, rawPath);\n    if (relativePath && !relativePath.startsWith('..') && relativePath !== '') {\n      return relativePath;\n    }\n\n    return rawPath;\n  }\n\n  /**\n   * Get the file paths from edit tool calls for the explanation prompt\n   */\n  private getEditedFiles(toolCalls: ToolCallRequest[]): string[] {\n    const files: string[] = [];\n    for (const call of toolCalls) {\n      if (this.isEditToolCall(call.name)) {\n        const filePath = this.getEditedFilePath(call);\n        if (filePath) {\n          files.push(filePath);\n        }\n      }\n    }\n    return files;\n  }\n\n  async send(text: string, useStreaming = false): Promise<string> {\n    const prompt = text.trim();\n    if (!prompt) {\n      return '';\n    }\n    // Notify UI immediately so it can reflect activity without waiting for generation\n    this.callbacks.onRequestReceived?.(prompt.slice(0, 400));\n\n    // Reset cancellation flag and loop tracking at start of new request\n    this.cancellationRequested = false;\n    this.resetBehavioralLoopTracking();\n    // Track tool history position for this run\n    this.toolHistoryCursor = this.toolRuntime.getToolHistory().length;\n\n    // Handle multi-line paste: show summary to user, send full content to AI\n    if (isMultilinePaste(prompt)) {\n      const processed = processPaste(prompt);\n      // Notify UI about the paste summary\n      this.callbacks.onMultilinePaste?.(processed.displaySummary, processed.metadata);\n      // But send the full content to the AI\n      this.messages.push({ role: 'user', content: processed.fullContent });\n    } else {\n      // Single-line or short text: send as-is\n      this.messages.push({ role: 'user', content: prompt });\n    }\n    const run = { startedAt: Date.now() };\n    this.activeRun = run;\n    try {\n      // Always use streaming when available - no fallback\n      if (useStreaming && this.provider.generateStream) {\n        return await this.processConversationStreaming();\n      }\n      return await this.processConversation();\n    } finally {\n      if (this.activeRun === run) {\n        this.activeRun = null;\n      }\n      // Reset cancellation flag when done\n      this.cancellationRequested = false;\n    }\n  }\n\n  private async processConversation(): Promise<string> {\n    let contextRecoveryAttempts = 0;\n    let transientRetryAttempts = 0;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      // Check for cancellation at start of each iteration\n      if (this.cancellationRequested) {\n        this.callbacks.onCancelled?.();\n        return '[Operation cancelled by user]';\n      }\n\n      // Prune messages if approaching context limit (BEFORE generation)\n      await this.pruneMessagesIfNeeded();\n\n      try {\n        const response = await this.provider.generate(this.messages, this.providerTools);\n        const usage = response.usage ?? null;\n        const contextStats = this.getContextStats();\n\n        // Reset recovery attempts on successful generation\n        contextRecoveryAttempts = 0;\n\n        if (response.type === 'tool_calls') {\n          // BEHAVIORAL LOOP DETECTION: Check if model is stuck calling same tool repeatedly\n          const behavioralLoopResult = this.checkBehavioralLoop(response.toolCalls);\n          if (behavioralLoopResult) {\n            this.emitAssistantMessage(behavioralLoopResult, { isFinal: true, usage, contextStats });\n            this.messages.push({ role: 'assistant', content: behavioralLoopResult });\n            return behavioralLoopResult;\n          }\n\n          // Loop detection: check if same tool calls are being repeated (exact signature match)\n          const signatureCalls = response.toolCalls.filter(call => !this.shouldSkipLoopDetection(call));\n          const toolSignature = signatureCalls.length\n            ? signatureCalls\n              .map((t) => `${t.name}:${JSON.stringify(t.arguments)}`)\n              .sort()\n              .join('|')\n            : null;\n          if (toolSignature && toolSignature === this.lastToolCallSignature) {\n            this.repeatedToolCallCount++;\n            if (this.repeatedToolCallCount >= AgentRuntime.MAX_REPEATED_TOOL_CALLS) {\n              // Break out of loop - model is stuck\n              const loopMsg = `Tool loop detected: same tools called ${this.repeatedToolCallCount} times. Please try a different approach or provide more specific instructions.`;\n              this.emitAssistantMessage(loopMsg, { isFinal: true, usage, contextStats });\n              this.messages.push({ role: 'assistant', content: loopMsg });\n              this.lastToolCallSignature = null;\n              this.repeatedToolCallCount = 0;\n              return loopMsg;\n            }\n          } else if (toolSignature) {\n            this.lastToolCallSignature = toolSignature;\n            this.repeatedToolCallCount = 1;\n          } else {\n            this.lastToolCallSignature = null;\n            this.repeatedToolCallCount = 0;\n          }\n\n          // Emit narration if present - it shows the AI's thought process before tools\n          const narration = response.content?.trim();\n          if (narration) {\n            this.emitAssistantMessage(narration, {\n              isFinal: false,\n              usage,\n              contextStats,\n            });\n          }\n          this.maybeAckToolCalls(response.toolCalls, Boolean(narration?.length), usage, contextStats);\n          const assistantMessage: ConversationMessage = {\n            role: 'assistant',\n            content: response.content ?? '',\n          };\n          if (response.toolCalls?.length) {\n            assistantMessage.toolCalls = response.toolCalls;\n          }\n          this.messages.push(assistantMessage);\n          await this.resolveToolCalls(response.toolCalls);\n          continue;\n        }\n\n        const reply = response.content?.trim() ?? '';\n        const { output: finalReply } = ensureNextSteps(reply);\n\n        // Reset loop detection when we get a text response (not just tool calls)\n        if (finalReply.length >= 10) {\n          this.lastToolCallSignature = null;\n          this.repeatedToolCallCount = 0;\n        }\n\n        if (finalReply) {\n          this.emitAssistantMessage(finalReply, { isFinal: true, usage, contextStats });\n        }\n        this.messages.push({ role: 'assistant', content: finalReply });\n\n        // Trigger verification for final responses with verifiable claims\n        this.triggerVerificationIfNeeded(finalReply);\n\n        return finalReply;\n      } catch (error) {\n        // Auto-recover from context overflow errors (with session-level limit)\n        const canRecover = contextRecoveryAttempts < MAX_CONTEXT_RECOVERY_ATTEMPTS &&\n                          this.totalContextRecoveries < AgentRuntime.MAX_TOTAL_RECOVERIES;\n        if (isContextOverflowError(error) && canRecover) {\n          contextRecoveryAttempts++;\n          this.totalContextRecoveries++;\n          const recovered = await this.recoverFromContextOverflow(contextRecoveryAttempts);\n          if (recovered) {\n            // Notify UI that we're continuing after recovery\n            this.callbacks.onContinueAfterRecovery?.();\n            // Retry the generation with reduced context\n            continue;\n          }\n        }\n        // Auto-retry transient errors (network issues, rate limits, server errors)\n        if (isTransientError(error) && transientRetryAttempts < MAX_TRANSIENT_RETRIES) {\n          transientRetryAttempts++;\n          const delayMs = getRetryDelay(transientRetryAttempts);\n          this.callbacks.onRetrying?.(transientRetryAttempts, MAX_TRANSIENT_RETRIES, error as Error);\n          await sleep(delayMs);\n          continue;\n        }\n        // Re-throw if not recoverable or recovery failed\n        throw error;\n      }\n    }\n  }\n\n  private async processConversationStreaming(): Promise<string> {\n    if (!this.provider.generateStream) {\n      return this.processConversation();\n    }\n\n    let contextRecoveryAttempts = 0;\n    let transientRetryAttempts = 0;\n    const STREAM_HARD_CHAR_LIMIT = 120000; // Hard guardrail to prevent runaway provider output\n    let totalCharsReceived = 0;\n    let truncatedResponse = false;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      // Check for cancellation at start of each iteration\n      if (this.cancellationRequested) {\n        this.callbacks.onCancelled?.();\n        return '[Operation cancelled by user]';\n      }\n\n      // Prune messages if approaching context limit (BEFORE generation)\n      await this.pruneMessagesIfNeeded();\n\n      try {\n        let fullContent = '';\n        let reasoningContent = '';\n        const toolCalls: ToolCallRequest[] = [];\n        let usage: ProviderUsage | null = null;\n        const suppressStreamNarration = this.shouldSuppressToolNarration();\n        let bufferedContent = '';\n\n        logDebug('[DEBUG agent] Starting stream generation');\n        const stream = this.provider.generateStream(this.messages, this.providerTools);\n        const iterator = stream[Symbol.asyncIterator]();\n        let streamClosed = false;\n        logDebug('[DEBUG agent] Got stream iterator');\n        const closeStream = async (): Promise<void> => {\n          if (streamClosed) {\n            return;\n          }\n          streamClosed = true;\n          if (typeof iterator.return === 'function') {\n            try {\n              await iterator.return();\n            } catch (closeError) {\n              logDebug(`[agent] Failed to close stream cleanly: ${safeErrorMessage(closeError)}`);\n            }\n          }\n        };\n\n        const describeChunk = (chunk?: StreamChunk): string => {\n          if (!chunk) {\n            return 'unknown chunk';\n          }\n          switch (chunk.type) {\n            case 'content':\n            case 'reasoning': {\n              const snippet = debugSnippet(chunk.content);\n              return snippet ? `${chunk.type} → ${snippet}` : chunk.type;\n            }\n            case 'tool_call':\n              return chunk.toolCall ? `tool_call ${chunk.toolCall.name}` : 'tool_call';\n            case 'usage':\n              if (chunk.usage?.totalTokens != null) {\n                return `usage tokens=${chunk.usage.totalTokens}`;\n              }\n              return 'usage';\n            case 'done':\n              return 'done';\n            default:\n              return chunk.type;\n          }\n        };\n\n        // Simple streaming loop - no timeouts, let the stream run until done\n        try {\n          logDebug('[DEBUG agent] Entering streaming loop');\n          let chunkCount = 0;\n          // eslint-disable-next-line no-constant-condition\n          while (true) {\n            logDebug('[DEBUG agent] Awaiting next chunk...');\n            const result = await iterator.next();\n            chunkCount++;\n            const chunkLabel = result.done ? 'done' : describeChunk(result.value);\n            logDebug(`[DEBUG agent] Got chunk ${chunkCount}: ${chunkLabel}`);\n\n            // Check for cancellation during streaming\n            if (this.cancellationRequested) {\n              await closeStream();\n              this.callbacks.onCancelled?.();\n              const partial = (fullContent || reasoningContent).trim();\n              if (partial) {\n                this.messages.push({ role: 'assistant', content: `${partial}\\n\\n[Cancelled by user]` });\n              }\n              return '[Operation cancelled by user]';\n            }\n\n            if (result.done) {\n              break;\n            }\n\n            const chunk = result.value;\n\n            if (chunk.type === 'reasoning' && chunk.content) {\n              // Buffer reasoning content - don't stream token-by-token\n              // It will be emitted as a complete block when ready\n              const next = reasoningContent + chunk.content;\n              totalCharsReceived += chunk.content.length;\n              // Hard cap buffered reasoning to protect memory\n              if (next.length > 24000) {\n                reasoningContent = next.slice(-24000);\n              } else {\n                reasoningContent = next;\n              }\n              if (totalCharsReceived > STREAM_HARD_CHAR_LIMIT) {\n                truncatedResponse = true;\n                await closeStream();\n                break;\n              }\n              continue;\n            }\n\n            if (chunk.type === 'content' && chunk.content) {\n              const nextContent = fullContent + chunk.content;\n              totalCharsReceived += chunk.content.length;\n              // Cap buffered content to avoid OOM from runaway outputs\n              fullContent = nextContent.length > 48000 ? nextContent.slice(-48000) : nextContent;\n              if (suppressStreamNarration) {\n                const nextBuffered = bufferedContent + chunk.content;\n                bufferedContent = nextBuffered.length > 24000 ? nextBuffered.slice(-24000) : nextBuffered;\n              } else {\n                this.callbacks.onStreamChunk?.(chunk.content, 'content');\n              }\n              if (totalCharsReceived > STREAM_HARD_CHAR_LIMIT) {\n                truncatedResponse = true;\n                await closeStream();\n                break;\n              }\n            } else if (chunk.type === 'tool_call' && chunk.toolCall) {\n              // On first tool call, flush any buffered content\n              if (toolCalls.length === 0) {\n                // Emit complete reasoning block first\n                if (reasoningContent.trim()) {\n                  this.callbacks.onStreamChunk?.(reasoningContent, 'reasoning');\n                }\n                // Then emit buffered narration content\n                if (suppressStreamNarration && bufferedContent) {\n                  this.callbacks.onStreamChunk?.(bufferedContent, 'content');\n                  bufferedContent = '';\n                }\n              }\n              toolCalls.push(chunk.toolCall);\n            } else if (chunk.type === 'usage' && chunk.usage) {\n              usage = chunk.usage;\n              // Emit real token usage during streaming\n              this.callbacks.onUsage?.(chunk.usage);\n            }\n          }\n        } finally {\n          await closeStream();\n        }\n\n        // Reset recovery attempts on successful generation\n        contextRecoveryAttempts = 0;\n\n        const contextStats = this.getContextStats();\n        // IMPORTANT: Only use fullContent for user-visible output\n        // reasoningContent is internal model thinking and should NEVER be shown to users\n        // We keep it for conversation history (helps the model) but not for display\n        const combinedContent = fullContent;\n\n        if (truncatedResponse) {\n          const notice = '\\n\\n[Response truncated: reached safety limit of 120k characters to prevent OOM.]';\n          const updated = combinedContent ? `${combinedContent}${notice}` : notice.trim();\n          fullContent = updated;\n          reasoningContent = '';\n          // Partial tool calls are unsafe when truncated; drop them\n          toolCalls.length = 0;\n        }\n\n        // If no tool calls were issued, emit reasoning and buffered content as complete blocks\n        if (toolCalls.length === 0) {\n          // Emit complete reasoning block if we have one\n          if (reasoningContent.trim()) {\n            this.callbacks.onStreamChunk?.(reasoningContent, 'reasoning');\n          }\n          // Emit buffered narration content\n          if (suppressStreamNarration && bufferedContent) {\n            this.callbacks.onStreamChunk?.(bufferedContent, 'content');\n            bufferedContent = '';\n          }\n        }\n\n        // Check if we got tool calls\n        if (toolCalls.length > 0) {\n          // BEHAVIORAL LOOP DETECTION: Check if model is stuck calling same tool repeatedly\n          // This catches patterns like \"git status\" called 5 times even with slightly different outputs\n          const behavioralLoopResult = this.checkBehavioralLoop(toolCalls);\n          if (behavioralLoopResult) {\n            this.emitAssistantMessage(behavioralLoopResult, { isFinal: true, usage, contextStats, wasStreamed: true });\n            this.messages.push({ role: 'assistant', content: behavioralLoopResult });\n            return behavioralLoopResult;\n          }\n\n          // Loop detection: check if same tool calls are being repeated (exact signature match)\n          const signatureCalls = toolCalls.filter(call => !this.shouldSkipLoopDetection(call));\n          const toolSignature = signatureCalls.length\n            ? signatureCalls\n              .map((t) => `${t.name}:${JSON.stringify(t.arguments)}`)\n              .sort()\n              .join('|')\n            : null;\n          if (toolSignature && toolSignature === this.lastToolCallSignature) {\n            this.repeatedToolCallCount++;\n            if (this.repeatedToolCallCount >= AgentRuntime.MAX_REPEATED_TOOL_CALLS) {\n              // Break out of loop - model is stuck\n              const loopMsg = `Tool loop detected: same tools called ${this.repeatedToolCallCount} times. Please try a different approach or provide more specific instructions.`;\n              this.emitAssistantMessage(loopMsg, { isFinal: true, usage, contextStats, wasStreamed: true });\n              this.messages.push({ role: 'assistant', content: loopMsg });\n              this.lastToolCallSignature = null;\n              this.repeatedToolCallCount = 0;\n              return loopMsg;\n            }\n          } else if (toolSignature) {\n            this.lastToolCallSignature = toolSignature;\n            this.repeatedToolCallCount = 1;\n          } else {\n            this.lastToolCallSignature = null;\n            this.repeatedToolCallCount = 0;\n          }\n\n          // Content was already streamed via onStreamChunk, just record it for context\n          // (wasStreamed=true prevents duplicate display)\n          // Note: Acknowledgement injection happens during streaming (when first tool_call chunk arrives)\n          const narration = combinedContent.trim();\n          if (narration) {\n            this.emitAssistantMessage(narration, {\n              isFinal: false,\n              usage,\n              contextStats,\n              wasStreamed: true,\n            });\n          }\n          this.maybeAckToolCalls(toolCalls, Boolean(narration.length), usage, contextStats);\n          const assistantMessage: ConversationMessage = {\n            role: 'assistant',\n            content: combinedContent,\n            toolCalls,\n          };\n          this.messages.push(assistantMessage);\n          await this.resolveToolCalls(toolCalls);\n          continue;\n        }\n\n        let reply = combinedContent.trim();\n        let wasReasoningUsedAsReply = false;\n\n        // For reasoning models: if no content but we have reasoning, use reasoning as the response\n        // This handles models like DeepSeek-reasoner that put their entire response in reasoning_content\n        // The reasoning has already been streamed as 'thought' events showing the AI's thinking\n        if (!reply && reasoningContent.trim()) {\n          // Use reasoning as the reply - it contains the model's answer\n          reply = reasoningContent.trim();\n          wasReasoningUsedAsReply = true;\n          // Stream the content so it appears as the actual response (not just thoughts)\n          this.callbacks.onStreamChunk?.(reply, 'content');\n        }\n\n        const { output: finalReply, appended } = ensureNextSteps(reply);\n\n        // Reset loop detection when we get a text response (not just tool calls)\n        if (finalReply.length >= 10) {\n          this.lastToolCallSignature = null;\n          this.repeatedToolCallCount = 0;\n        }\n\n        // If we appended a required Next steps section, stream just the delta\n        if (appended) {\n          this.callbacks.onStreamChunk?.(appended, 'content');\n        }\n\n        // Final message - mark as streamed to avoid double-display in UI\n        if (finalReply) {\n          this.emitAssistantMessage(finalReply, { isFinal: true, usage, contextStats, wasStreamed: true });\n        }\n        this.messages.push({ role: 'assistant', content: finalReply });\n\n        // Trigger verification for final responses with verifiable claims\n        this.triggerVerificationIfNeeded(finalReply);\n\n        return finalReply;\n      } catch (error) {\n        // Auto-recover from context overflow errors (with session-level limit)\n        const canRecover = contextRecoveryAttempts < MAX_CONTEXT_RECOVERY_ATTEMPTS &&\n                          this.totalContextRecoveries < AgentRuntime.MAX_TOTAL_RECOVERIES;\n        if (isContextOverflowError(error) && canRecover) {\n          contextRecoveryAttempts++;\n          this.totalContextRecoveries++;\n          const recovered = await this.recoverFromContextOverflow(contextRecoveryAttempts);\n          if (recovered) {\n            // Notify UI that we're continuing after recovery\n            this.callbacks.onContinueAfterRecovery?.();\n            // Retry the generation with reduced context\n            continue;\n          }\n        }\n        // Auto-retry transient errors (network issues, rate limits, server errors)\n        if (isTransientError(error) && transientRetryAttempts < MAX_TRANSIENT_RETRIES) {\n          transientRetryAttempts++;\n          const delayMs = getRetryDelay(transientRetryAttempts);\n          this.callbacks.onRetrying?.(transientRetryAttempts, MAX_TRANSIENT_RETRIES, error as Error);\n          await sleep(delayMs);\n          continue;\n        }\n        // Re-throw if not recoverable or recovery failed\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Execute tool calls with optimized concurrency\n   *\n   * PERF: Uses Promise.all for parallel execution with early result handling.\n   * Results are collected in order but execution happens concurrently.\n   * For very large batches (>10 tools), uses chunked execution to prevent\n   * overwhelming system resources.\n   */\n  private async resolveToolCalls(toolCalls: ToolCallRequest[]): Promise<void> {\n    const numCalls = toolCalls.length;\n    const executedEdits: Array<{ call: ToolCallRequest; output: string; fromCache: boolean }> = [];\n\n    // Check for cancellation before starting tool execution\n    if (this.cancellationRequested) {\n      // Add cancellation message for each pending tool call\n      for (const call of toolCalls) {\n        this.messages.push({\n          role: 'tool',\n          name: call.name,\n          toolCallId: call.id,\n          content: '[Tool execution cancelled by user]',\n        });\n      }\n      return;\n    }\n\n    // Fast path: single tool call\n    if (numCalls === 1) {\n      const call = toolCalls[0]!;\n\n      // Check cache first - prevent duplicate identical tool calls\n      const cached = this.getCachedToolResult(call);\n      if (cached !== null) {\n        // Return cached result with indicator that it was from cache\n        this.messages.push({\n          role: 'tool',\n          name: call.name,\n          toolCallId: call.id,\n          content: `[Cached result - identical call already executed]\\n\\n${cached}`,\n        });\n        return;\n      }\n\n      this.callbacks.onToolExecution?.(call.name, true);\n      const output = await this.toolRuntime.execute(call);\n      this.callbacks.onToolExecution?.(call.name, false);\n\n      // Cache the result for future identical calls\n      this.cacheToolResult(call, output);\n\n      if (this.isEditToolCall(call.name)) {\n        executedEdits.push({ call, output, fromCache: false });\n      }\n\n      this.messages.push({\n        role: 'tool',\n        name: call.name,\n        toolCallId: call.id,\n        content: output,\n      });\n      await this.maybeExplainEdits(executedEdits);\n      return;\n    }\n\n    // PERF: For reasonable batch sizes, execute all in parallel\n    // Check cache for each call and only execute non-cached ones\n    if (numCalls <= 10) {\n      const cachedResults: Array<{ call: ToolCallRequest; output: string; fromCache: boolean }> = [];\n      const toExecute: ToolCallRequest[] = [];\n\n      // Separate cached from non-cached calls\n      for (const call of toolCalls) {\n        const cached = this.getCachedToolResult(call);\n        if (cached !== null) {\n          cachedResults.push({ call, output: cached, fromCache: true });\n          if (this.isEditToolCall(call.name)) {\n            executedEdits.push({ call, output: cached, fromCache: true });\n          }\n        } else {\n          toExecute.push(call);\n        }\n      }\n\n      // Execute non-cached calls in parallel\n      if (toExecute.length > 0) {\n        const toolNames = toExecute.map(c => c.name).join(', ');\n        this.callbacks.onToolExecution?.(toolNames, true);\n        const executed = await Promise.all(\n          toExecute.map(async (call) => {\n            const output = await this.toolRuntime.execute(call);\n            this.cacheToolResult(call, output);\n            if (this.isEditToolCall(call.name)) {\n              executedEdits.push({ call, output, fromCache: false });\n            }\n            return { call, output, fromCache: false };\n          })\n        );\n        this.callbacks.onToolExecution?.(toolNames, false);\n        cachedResults.push(...executed);\n      }\n\n      // Add all results to messages in the original order\n      for (const originalCall of toolCalls) {\n        const result = cachedResults.find(r => r.call.id === originalCall.id);\n        if (result) {\n          const content = result.fromCache\n            ? `[Cached result - identical call already executed]\\n\\n${result.output}`\n            : result.output;\n          this.messages.push({\n            role: 'tool',\n            name: result.call.name,\n            toolCallId: result.call.id,\n            content,\n          });\n        }\n      }\n      await this.maybeExplainEdits(executedEdits);\n      return;\n    }\n\n    // PERF: For large batches, use chunked parallel execution with caching\n    const CHUNK_SIZE = 8;\n    const allResults: Array<{ call: ToolCallRequest; output: string; fromCache: boolean }> = [];\n\n    for (let i = 0; i < numCalls; i += CHUNK_SIZE) {\n      const chunk = toolCalls.slice(i, i + CHUNK_SIZE);\n      const cachedInChunk: Array<{ call: ToolCallRequest; output: string; fromCache: boolean }> = [];\n      const toExecuteInChunk: ToolCallRequest[] = [];\n\n      for (const call of chunk) {\n        const cached = this.getCachedToolResult(call);\n        if (cached !== null) {\n          cachedInChunk.push({ call, output: cached, fromCache: true });\n          if (this.isEditToolCall(call.name)) {\n            executedEdits.push({ call, output: cached, fromCache: true });\n          }\n        } else {\n          toExecuteInChunk.push(call);\n        }\n      }\n\n      if (toExecuteInChunk.length > 0) {\n        const chunkNames = toExecuteInChunk.map(c => c.name).join(', ');\n        this.callbacks.onToolExecution?.(chunkNames, true);\n        const executed = await Promise.all(\n          toExecuteInChunk.map(async (call) => {\n            const output = await this.toolRuntime.execute(call);\n            this.cacheToolResult(call, output);\n            if (this.isEditToolCall(call.name)) {\n              executedEdits.push({ call, output, fromCache: false });\n            }\n            return { call, output, fromCache: false };\n          })\n        );\n        this.callbacks.onToolExecution?.(chunkNames, false);\n        cachedInChunk.push(...executed);\n      }\n\n      allResults.push(...cachedInChunk);\n    }\n\n    // Add results to messages in original order\n    for (const originalCall of toolCalls) {\n      const result = allResults.find(r => r.call.id === originalCall.id);\n      if (result) {\n        const content = result.fromCache\n          ? `[Cached result - identical call already executed]\\n\\n${result.output}`\n          : result.output;\n        this.messages.push({\n          role: 'tool',\n          name: result.call.name,\n          toolCallId: result.call.id,\n          content,\n        });\n      }\n    }\n    await this.maybeExplainEdits(executedEdits);\n  }\n\n  private truncateEditOutput(output: string): string {\n    if (!output) {\n      return '[no tool output available]';\n    }\n    const limit = AgentRuntime.EDIT_CONTEXT_CHAR_LIMIT;\n    if (output.length <= limit) {\n      return output;\n    }\n\n    const head = output.slice(0, Math.floor(limit * 0.7));\n    const tail = output.slice(-Math.floor(limit * 0.2));\n    const omitted = output.length - head.length - tail.length;\n    return `${head}\\n... [truncated ${omitted} chars] ...\\n${tail}`;\n  }\n\n  private buildEditExplanationPrompt(toolName: string, files: string[], toolOutput: string): ConversationMessage[] {\n    const fileLine = files.length ? `Files: ${files.join(', ')}` : 'Files: (not provided)';\n    const userContent = [\n      'Provide a concise, user-facing explanation of the edit that just completed.',\n      'Keep it to 1-3 sentences and mention intent, impact, and any user-visible changes.',\n      fileLine,\n      `Tool: ${toolName}`,\n      '',\n      'Tool output:',\n      toolOutput,\n    ].join('\\n');\n\n    return [\n      {\n        role: 'system',\n        content: 'You summarize code edits for the user interface. Be specific about what changed and why, and avoid filler.',\n      },\n      { role: 'user', content: userContent },\n    ];\n  }\n\n  private async maybeExplainEdits(results: Array<{ call: ToolCallRequest; output: string; fromCache: boolean }>): Promise<void> {\n    if (!this.explainEdits || results.length === 0 || this.cancellationRequested) {\n      return;\n    }\n\n    for (const result of results) {\n      if (result.fromCache || !this.isEditToolCall(result.call.name)) {\n        continue;\n      }\n\n      const files = this.getEditedFiles([result.call]);\n      const truncatedOutput = this.truncateEditOutput(result.output);\n      const prompt = this.buildEditExplanationPrompt(result.call.name, files, truncatedOutput);\n\n      try {\n        const response = await this.provider.generate(prompt, []);\n        if (response.type !== 'message') {\n          continue;\n        }\n        const explanation = response.content?.trim();\n        if (explanation) {\n          this.callbacks.onEditExplanation?.({\n            explanation,\n            files,\n            toolName: result.call.name,\n            toolCallId: result.call.id,\n          });\n        }\n      } catch (error) {\n        logDebug(`[agent] Failed to generate edit explanation: ${safeErrorMessage(error)}`);\n      }\n    }\n  }\n\n  private get providerTools(): ProviderToolDefinition[] {\n    return this.toolRuntime.listProviderTools();\n  }\n\n  /**\n   * Whether to suppress tool narration in the content field.\n   * Previously suppressed for OpenAI but now we show all thinking/narration.\n   */\n  private shouldSuppressToolNarration(): boolean {\n    return false; // Always show thinking/narration\n  }\n\n  private emitAssistantMessage(content: string, metadata: AssistantMessageMetadata): void {\n    if (!content || !content.trim()) {\n      return;\n    }\n    const elapsedMs = this.activeRun ? Date.now() - this.activeRun.startedAt : undefined;\n    const payload: AssistantMessageMetadata = { ...metadata };\n    if (typeof elapsedMs === 'number') {\n      payload.elapsedMs = elapsedMs;\n    }\n    this.callbacks.onAssistantMessage?.(content, payload);\n  }\n\n  /**\n   * Trigger verification for a final response if callback is registered\n   * and response contains verifiable claims (implementation, build success, etc.)\n   */\n  private triggerVerificationIfNeeded(response: string): void {\n    if (!this.callbacks.onVerificationNeeded) {\n      return;\n    }\n\n    // Only trigger verification for responses that likely contain verifiable claims\n    // These patterns indicate the model is claiming to have completed work\n    const verifiablePatterns = [\n      /\\b(implemented|created|wrote|added|fixed|built|deployed|completed|refactored)\\b/i,\n      /\\b(tests?\\s+(are\\s+)?pass(ing)?|build\\s+succeed)/i,\n      /\\b(file|function|class|module|component)\\s+(has been|is now|was)\\s+(created|updated|modified)/i,\n      /✅|✓|\\[done\\]|\\[complete\\]/i,\n      /\\bcommit(ted)?\\b.*\\b(success|done)\\b/i,\n    ];\n\n    const hasVerifiableClaims = verifiablePatterns.some(pattern => pattern.test(response));\n    if (!hasVerifiableClaims) {\n      return;\n    }\n\n    // Build conversation history for context (last 5 user/assistant exchanges)\n    const conversationHistory: string[] = [];\n    const recentMessages = this.messages.slice(-10);\n    for (const msg of recentMessages) {\n      if (msg.role === 'user' || msg.role === 'assistant') {\n        const content = typeof msg.content === 'string' ? msg.content : '';\n        if (content.length > 0) {\n          conversationHistory.push(`${msg.role}: ${content.slice(0, 500)}`);\n        }\n      }\n    }\n\n    // Trigger verification callback\n    this.callbacks.onVerificationNeeded(response, {\n      workingDirectory: this.workingDirectory,\n      conversationHistory,\n      provider: this.providerId,\n      model: this.modelId,\n    });\n  }\n\n  /**\n   * Extract a \"command hash\" from tool arguments for behavioral loop detection.\n   * For execute_bash, this is the actual command. For other tools, key identifying args.\n   */\n  private extractCmdHash(name: string, args: Record<string, unknown>): string {\n    // For bash/execute commands, extract the command itself\n    if (name === 'execute_bash' || name === 'Bash') {\n      const cmd = args['command'] as string | undefined;\n      if (cmd) {\n        // Normalize: trim, take first 100 chars, remove variable parts like timestamps\n        return cmd.trim().slice(0, 100).replace(/\\d{10,}/g, 'N');\n      }\n    }\n    // For file operations, use the path\n    if (name === 'read_file' || name === 'Read' || name === 'read_files') {\n      const path = args['path'] || args['file_path'] || args['paths'];\n      if (path) return `path:${JSON.stringify(path).slice(0, 100)}`;\n    }\n    if (name === 'list_files' || name === 'Glob') {\n      const path = args['path'] || args['pattern'];\n      if (path) return `path:${JSON.stringify(path).slice(0, 100)}`;\n    }\n    // For search, use the query/pattern\n    if (name === 'Grep' || name === 'grep' || name === 'search') {\n      const pattern = args['pattern'] || args['query'];\n      if (pattern) return `search:${String(pattern).slice(0, 100)}`;\n    }\n    // Default: use first significant arg value\n    const firstArg = Object.values(args)[0];\n    if (firstArg) {\n      return String(firstArg).slice(0, 100);\n    }\n    return 'no-args';\n  }\n\n  /**\n   * Check for behavioral loops - model calling the same tool with similar args repeatedly.\n   * Returns an error message if a loop is detected, null otherwise.\n   *\n   * FUNDAMENTAL PREVENTION: Cached calls are excluded from loop detection since they\n   * don't actually execute (the cache provides the result). This means:\n   * - First call: executes and caches result\n   * - Second identical call: returns cached result, NOT counted toward loop\n   * - Only genuinely NEW (non-cached) repetitive calls trigger loop detection\n   *\n   * Direct execution tools (bash/edit) are also exempt to avoid short-circuiting\n   * legitimate repeated user commands.\n   *\n   * This catches patterns like:\n   * - \"git status -sb\" called 3 times with DIFFERENT outputs (cache miss each time)\n   * - Repeated file reads where file content changed\n   * - Repeated searches with same pattern but new results\n   */\n  private checkBehavioralLoop(toolCalls: ToolCallRequest[]): string | null {\n    // Skip loop detection for direct execution tools (bash/edit) to avoid false positives\n    const loopEligibleCalls = toolCalls.filter(call => !this.shouldSkipLoopDetection(call));\n\n    if (loopEligibleCalls.length === 0) {\n      return null;\n    }\n\n    // Filter out calls that will be served from cache - these don't count toward loops\n    // since they're handled fundamentally by the caching mechanism\n    const nonCachedCalls = loopEligibleCalls.filter(call => this.getCachedToolResult(call) === null);\n\n    // If all calls are cached, no loop detection needed\n    if (nonCachedCalls.length === 0) {\n      return null;\n    }\n\n    // Count existing occurrences in recent history\n    const existingCounts = new Map<string, number>();\n    for (const { name, cmdHash } of this.recentToolCalls) {\n      const key = `${name}:${cmdHash}`;\n      existingCounts.set(key, (existingCounts.get(key) ?? 0) + 1);\n    }\n\n    // Check if ANY incoming NON-CACHED call would exceed threshold\n    for (const call of nonCachedCalls) {\n      const cmdHash = this.extractCmdHash(call.name, call.arguments ?? {});\n      const key = `${call.name}:${cmdHash}`;\n      const currentCount = existingCounts.get(key) ?? 0;\n      // If adding this call would reach or exceed threshold, block immediately\n      if (currentCount + 1 >= AgentRuntime.BEHAVIORAL_LOOP_THRESHOLD) {\n        // Reset history to prevent immediate re-trigger\n        this.recentToolCalls = [];\n        return `Behavioral loop detected: \"${call.name}\" called ${currentCount + 1} times with similar arguments. The task appears stuck. Please try a different approach or provide more specific instructions.`;\n      }\n    }\n\n    // Track only non-cached tool calls (cached ones are handled by caching)\n    for (const call of nonCachedCalls) {\n      const cmdHash = this.extractCmdHash(call.name, call.arguments ?? {});\n      this.recentToolCalls.push({ name: call.name, cmdHash });\n    }\n\n    // Keep only recent history\n    while (this.recentToolCalls.length > AgentRuntime.TOOL_HISTORY_SIZE) {\n      this.recentToolCalls.shift();\n    }\n\n    return null;\n  }\n\n  /**\n   * Provide an acknowledgement before the first tool call when the model\n   * hasn't narrated its plan. This keeps the UI responsive and lets the\n   * user know work is happening even before tool output arrives.\n   */\n  private maybeAckToolCalls(\n    toolCalls: ToolCallRequest[],\n    hasModelNarration: boolean,\n    usage: ProviderUsage | null,\n    contextStats: Record<string, unknown> | null\n  ): void {\n    if (!toolCalls?.length) {\n      return;\n    }\n    const acknowledgement = this.callbacks.onBeforeFirstToolCall?.(\n      toolCalls.map((call) => call.name),\n      hasModelNarration\n    );\n    if (acknowledgement && acknowledgement.trim()) {\n      this.emitAssistantMessage(acknowledgement, {\n        isFinal: false,\n        usage,\n        contextStats,\n      });\n    }\n  }\n\n  /**\n   * Reset behavioral loop tracking (called when user provides new input or task completes)\n   */\n  private resetBehavioralLoopTracking(): void {\n    this.recentToolCalls = [];\n    this.lastToolCallSignature = null;\n    this.repeatedToolCallCount = 0;\n    // Note: we DON'T clear toolResultCache here for cacheable tools; stateful tools bypass caching\n  }\n\n  /**\n   * Create a stable cache key for a tool call based on name and arguments\n   */\n  private getToolCacheKey(call: ToolCallRequest): string {\n    const args = call.arguments ?? {};\n    // Sort keys for consistent ordering\n    const sortedArgs = Object.keys(args).sort().reduce((acc, key) => {\n      acc[key] = args[key];\n      return acc;\n    }, {} as Record<string, unknown>);\n    return `${call.name}:${JSON.stringify(sortedArgs)}`;\n  }\n\n  /**\n   * Only cache tools that are safe to reuse; stateful commands must always execute.\n   */\n  private isCacheableTool(call: ToolCallRequest): boolean {\n    const nameLower = call.name.toLowerCase();\n    return !AgentRuntime.NON_CACHEABLE_TOOL_NAMES.has(nameLower);\n  }\n\n  /**\n   * Direct execution tools should not trigger behavioral loop short-circuiting.\n   */\n  private shouldSkipLoopDetection(call: ToolCallRequest): boolean {\n    const nameLower = call.name.toLowerCase();\n    return AgentRuntime.LOOP_EXEMPT_TOOL_NAMES.has(nameLower);\n  }\n\n  /**\n   * Get cached result for a tool call, or null if not cached\n   */\n  private getCachedToolResult(call: ToolCallRequest): string | null {\n    if (!this.isCacheableTool(call)) {\n      return null;\n    }\n    const key = this.getToolCacheKey(call);\n    return this.toolResultCache.get(key) ?? null;\n  }\n\n  /**\n   * Cache a tool result for future identical calls\n   */\n  private cacheToolResult(call: ToolCallRequest, result: string): void {\n    if (!this.isCacheableTool(call)) {\n      return;\n    }\n    const key = this.getToolCacheKey(call);\n\n    // Evict oldest entries if cache is full\n    if (this.toolResultCache.size >= AgentRuntime.TOOL_CACHE_MAX_SIZE) {\n      const firstKey = this.toolResultCache.keys().next().value;\n      if (firstKey) {\n        this.toolResultCache.delete(firstKey);\n      }\n    }\n\n    this.toolResultCache.set(key, result);\n  }\n\n  /**\n   * Drain the list of tools executed during the most recent send() call.\n   * Used by higher-level orchestrators to reason about progress.\n   */\n  drainToolExecutions(): ToolExecutionRecord[] {\n    if (typeof this.toolRuntime.getToolHistory !== 'function') {\n      return [];\n    }\n\n    const history = this.toolRuntime.getToolHistory();\n    const newEntries = history.slice(this.toolHistoryCursor);\n    this.toolHistoryCursor = history.length;\n\n    return newEntries.map((entry) => ({\n      name: entry.toolName,\n      success: entry.success ?? true,\n      hasOutput: entry.hasOutput ?? true,\n    }));\n  }\n\n  getHistory(): ConversationMessage[] {\n    return this.messages.map(cloneMessage);\n  }\n\n  loadHistory(history: ConversationMessage[]): void {\n    this.messages.length = 0;\n    if (history.length === 0) {\n      if (this.baseSystemPrompt) {\n        this.messages.push({ role: 'system', content: this.baseSystemPrompt });\n      }\n      return;\n    }\n    for (const message of history) {\n      this.messages.push(cloneMessage(message));\n    }\n  }\n\n  clearHistory(): void {\n    this.messages.length = 0;\n    if (this.baseSystemPrompt) {\n      this.messages.push({ role: 'system', content: this.baseSystemPrompt });\n    }\n  }\n\n  /**\n   * Prune messages if approaching context limit\n   *\n   * This runs BEFORE each generation to ensure we stay within budget.\n   * If LLM summarization is available, it will create intelligent summaries\n   * instead of just removing old messages.\n   */\n  private async pruneMessagesIfNeeded(): Promise<void> {\n    if (!this.contextManager) {\n      return;\n    }\n\n    if (this.contextManager.isApproachingLimit(this.messages)) {\n      // Try LLM-based summarization first (preserves context better)\n      const result = await this.contextManager.pruneMessagesWithSummary(this.messages);\n\n      if (result.removed > 0) {\n        // Replace messages with pruned/summarized version\n        this.messages.length = 0;\n        this.messages.push(...result.pruned);\n\n        // Notify callback with enriched stats\n        const stats = this.contextManager.getStats(this.messages);\n        const enrichedStats = {\n          ...stats,\n          summarized: result.summarized,\n          method: result.summarized ? 'llm-summary' : 'simple-prune',\n        };\n        this.callbacks.onContextPruned?.(result.removed, enrichedStats);\n\n        if (process.env['DEBUG_CONTEXT']) {\n          logDebug(\n            `[Context Manager] ${result.summarized ? 'Summarized' : 'Pruned'} ${result.removed} messages. ` +\n            `Tokens: ${stats.totalTokens} (${stats.percentage}%)`\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Get current context statistics\n   */\n  private getContextStats(): Record<string, unknown> | null {\n    if (!this.contextManager) {\n      return null;\n    }\n    return this.contextManager.getStats(this.messages);\n  }\n\n  /**\n   * Get context manager instance\n   */\n  getContextManager(): ContextManager | null {\n    return this.contextManager;\n  }\n\n  /**\n   * Fetch model info from the provider API.\n   * Returns context window and token limits from the real API.\n   * Results are cached for the lifetime of this agent instance.\n   */\n  async fetchModelInfo(): Promise<ProviderModelInfo | null> {\n    if (this.modelInfoFetched) {\n      return this.modelInfo;\n    }\n\n    this.modelInfoFetched = true;\n\n    if (typeof this.provider.getModelInfo === 'function') {\n      try {\n        this.modelInfo = await this.provider.getModelInfo();\n      } catch {\n        // Ignore errors - fall back to null\n        this.modelInfo = null;\n      }\n    }\n\n    return this.modelInfo;\n  }\n\n  /**\n   * Get cached model info (must call fetchModelInfo first)\n   */\n  getModelInfo(): ProviderModelInfo | null {\n    return this.modelInfo;\n  }\n\n  /**\n   * Get the context window size from the provider API.\n   * Returns null if the provider doesn't support this or the API call fails.\n   */\n  async getContextWindowFromProvider(): Promise<number | null> {\n    const info = await this.fetchModelInfo();\n    return info?.contextWindow ?? null;\n  }\n\n  /**\n   * Auto-recover from context overflow errors by aggressively pruning messages.\n   *\n   * This is called when an API call fails due to context length exceeding limits.\n   * It performs increasingly aggressive pruning on each attempt:\n   * - Attempt 1: Remove 30% of oldest messages + truncate tool outputs to 5k\n   * - Attempt 2: Remove 50% of oldest messages + truncate tool outputs to 2k\n   * - Attempt 3: Remove 70% of oldest messages + truncate tool outputs to 500 chars\n   *\n   * @returns true if recovery was successful (context was reduced)\n   */\n  private async recoverFromContextOverflow(attempt: number): Promise<boolean> {\n    // Calculate reduction percentage based on attempt\n    const reductionPercentages = [0.3, 0.5, 0.7];\n    const reductionPercent = reductionPercentages[attempt - 1] ?? 0.7;\n\n    // Increasingly aggressive tool output truncation limits\n    const toolOutputLimits = [5000, 2000, 500];\n    const toolOutputLimit = toolOutputLimits[attempt - 1] ?? 500;\n\n    // Notify UI about recovery attempt\n    const message = `Context overflow detected. Auto-squishing context (attempt ${attempt}/${MAX_CONTEXT_RECOVERY_ATTEMPTS}, removing ${Math.round(reductionPercent * 100)}% of history)...`;\n    this.callbacks.onContextRecovery?.(attempt, MAX_CONTEXT_RECOVERY_ATTEMPTS, message);\n    this.callbacks.onContextSquishing?.(message);\n\n    // Separate system messages from conversation\n    const systemMessages: ConversationMessage[] = [];\n    const conversationMessages: ConversationMessage[] = [];\n\n    for (const msg of this.messages) {\n      if (msg.role === 'system') {\n        systemMessages.push(msg);\n      } else {\n        conversationMessages.push(msg);\n      }\n    }\n\n    // Calculate how many messages to remove (target)\n    const targetRemoveCount = Math.floor(conversationMessages.length * reductionPercent);\n    if (targetRemoveCount === 0 || conversationMessages.length <= 2) {\n      // Nothing to remove or too few messages - can't recover\n      return false;\n    }\n\n    // Group messages into conversation \"turns\" to maintain tool call/result pairing\n    // A turn is: [user] or [assistant + tool results] or [assistant without tools]\n    const turns: ConversationMessage[][] = [];\n    let currentTurn: ConversationMessage[] = [];\n\n    for (let i = 0; i < conversationMessages.length; i++) {\n      const msg = conversationMessages[i]!;\n\n      if (msg.role === 'user') {\n        // User messages start a new turn\n        if (currentTurn.length > 0) {\n          turns.push(currentTurn);\n        }\n        currentTurn = [msg];\n      } else if (msg.role === 'assistant') {\n        // Assistant messages start a new turn (flush previous)\n        if (currentTurn.length > 0) {\n          turns.push(currentTurn);\n        }\n        currentTurn = [msg];\n      } else if (msg.role === 'tool') {\n        // Tool results belong to the current assistant turn\n        currentTurn.push(msg);\n      }\n    }\n    // Don't forget the last turn\n    if (currentTurn.length > 0) {\n      turns.push(currentTurn);\n    }\n\n    // Calculate how many turns to remove\n    const targetTurnsToRemove = Math.floor(turns.length * reductionPercent);\n    if (targetTurnsToRemove === 0 || turns.length <= 2) {\n      return false;\n    }\n\n    // Keep recent turns (remove from the beginning)\n    const keepTurns = turns.slice(targetTurnsToRemove);\n\n    // IMPORTANT: Ensure we don't start with orphaned tool messages\n    // The first kept turn must NOT be a tool-only turn\n    let startIndex = 0;\n    while (startIndex < keepTurns.length) {\n      const firstTurn = keepTurns[startIndex];\n      if (firstTurn && firstTurn.length > 0) {\n        const firstMsg = firstTurn[0];\n        // If first message is a tool result, skip this turn\n        if (firstMsg?.role === 'tool') {\n          startIndex++;\n          continue;\n        }\n        // If first message is an assistant with tool calls but we're missing results,\n        // check if all tool results are present\n        if (firstMsg?.role === 'assistant' && firstMsg.toolCalls && firstMsg.toolCalls.length > 0) {\n          // PERF: Pre-compute tool call IDs as array, use direct Set lookup\n          const toolCallIds = firstMsg.toolCalls.map(tc => tc.id);\n          const presentToolResultIds = new Set(\n            firstTurn.filter(m => m.role === 'tool').map(m => (m as { toolCallId?: string }).toolCallId)\n          );\n          // PERF: Direct has() calls with early exit instead of spread + every()\n          let allPresent = true;\n          for (const id of toolCallIds) {\n            if (!presentToolResultIds.has(id)) {\n              allPresent = false;\n              break;\n            }\n          }\n          if (allPresent) {\n            break;\n          }\n          // Otherwise skip this turn\n          startIndex++;\n          continue;\n        }\n      }\n      break;\n    }\n\n    const validTurns = keepTurns.slice(startIndex);\n    if (validTurns.length === 0) {\n      return false;\n    }\n\n    // Flatten valid turns back to messages\n    const keepMessages = validTurns.flat();\n    const actualRemoveCount = conversationMessages.length - keepMessages.length;\n\n    // Aggressively truncate tool outputs in remaining messages\n    let truncatedCount = 0;\n    for (const msg of keepMessages) {\n      if (msg.role === 'tool' && msg.content) {\n        const content = typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content);\n        if (content.length > toolOutputLimit) {\n          // Truncate with smart ending\n          const truncated = content.slice(0, toolOutputLimit);\n          const lastNewline = truncated.lastIndexOf('\\n');\n          const cutPoint = lastNewline > toolOutputLimit * 0.7 ? lastNewline : toolOutputLimit;\n          msg.content = `${truncated.slice(0, cutPoint)  }\\n\\n[... truncated ${content.length - cutPoint} chars for context recovery ...]`;\n          truncatedCount++;\n        }\n      }\n      // Also truncate very long assistant messages\n      if (msg.role === 'assistant' && msg.content && msg.content.length > toolOutputLimit * 2) {\n        const content = msg.content;\n        const limit = toolOutputLimit * 2;\n        const truncated = content.slice(0, limit);\n        const lastNewline = truncated.lastIndexOf('\\n');\n        const cutPoint = lastNewline > limit * 0.8 ? lastNewline : limit;\n        msg.content = `${truncated.slice(0, cutPoint)  }\\n\\n[... truncated for context recovery ...]`;\n        truncatedCount++;\n      }\n    }\n\n    // Also truncate system messages if they're huge (except first system prompt)\n    for (let i = 1; i < systemMessages.length; i++) {\n      const sys = systemMessages[i];\n      if (sys && sys.content && sys.content.length > toolOutputLimit) {\n        sys.content = `${sys.content.slice(0, toolOutputLimit)  }\\n[... truncated ...]`;\n        truncatedCount++;\n      }\n    }\n\n    // Rebuild message array\n    this.messages.length = 0;\n\n    // Add system messages\n    for (const sys of systemMessages) {\n      this.messages.push(sys);\n    }\n\n    // Add summary notice\n    this.messages.push({\n      role: 'system',\n      content: `[Auto Context Recovery] Removed ${actualRemoveCount} messages and truncated ${truncatedCount} large outputs to stay within token limits.`,\n    });\n\n    // Add remaining conversation (maintaining tool call/result pairing)\n    for (const msg of keepMessages) {\n      this.messages.push(msg);\n    }\n\n    // Notify about pruning\n    const stats = this.contextManager?.getStats(this.messages) ?? {};\n    this.callbacks.onContextPruned?.(actualRemoveCount, {\n      ...stats,\n      method: 'emergency-recovery',\n      attempt,\n      removedPercent: reductionPercent * 100,\n      turnsRemoved: targetTurnsToRemove + startIndex,\n      truncatedOutputs: truncatedCount,\n      toolOutputLimit,\n    });\n\n    // Check if we're still over limit after all reductions\n    const newStats = this.contextManager?.getStats(this.messages);\n    if (newStats && newStats.percentage > 100) {\n      // Still over limit - do one more aggressive pass\n      // Truncate ALL tool outputs to absolute minimum\n      const minLimit = 200;\n      for (const msg of this.messages) {\n        if (msg.role === 'tool' && msg.content) {\n          const content = typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content);\n          if (content.length > minLimit) {\n            msg.content = `${content.slice(0, minLimit)  }\\n[... severely truncated ...]`;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n}\n\nfunction cloneMessage(message: ConversationMessage): ConversationMessage {\n  switch (message.role) {\n    case 'assistant': {\n      const clone: ConversationMessage = {\n        role: 'assistant',\n        content: message.content,\n      };\n      if (message.toolCalls) {\n        clone.toolCalls = message.toolCalls.map(cloneToolCall);\n      }\n      return clone;\n    }\n    case 'tool':\n      return {\n        role: 'tool',\n        name: message.name,\n        content: message.content,\n        toolCallId: message.toolCallId,\n      };\n    case 'system':\n      return { role: 'system', content: message.content };\n    case 'user':\n    default:\n      return { role: 'user', content: message.content };\n  }\n}\n\nfunction cloneToolCall(call: ToolCallRequest): ToolCallRequest {\n  return {\n    id: call.id,\n    name: call.name,\n    arguments: { ...(call.arguments ?? {}) },\n  };\n}\n"],"mappings":"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","ignoreList":[]}