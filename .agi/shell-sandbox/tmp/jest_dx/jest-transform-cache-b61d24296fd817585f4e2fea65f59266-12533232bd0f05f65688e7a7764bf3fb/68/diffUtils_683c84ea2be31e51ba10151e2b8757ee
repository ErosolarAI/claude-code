4ce9fc1c06bf88a2a8948ea2bff32e59
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildDiffSegments = buildDiffSegments;
exports.buildDiffSegmentsFast = buildDiffSegmentsFast;
exports.buildDiffWithContext = buildDiffWithContext;
exports.formatDiffClaudeStyle = formatDiffClaudeStyle;
exports.formatDiffLines = formatDiffLines;
var _nodeChild_process = require("node:child_process");
var _nodeFs = require("node:fs");
var _nodeOs = require("node:os");
var _nodePath = require("node:path");
/**
 * Result from building a diff with context lines
 */

function buildDiffSegments(previous, next) {
  const before = normalizeNewlines(previous);
  const after = normalizeNewlines(next);
  if (before === after) {
    return [];
  }
  const gitSegments = tryBuildWithGit(before, after);
  if (gitSegments) {
    return gitSegments;
  }
  return buildNaiveDiff(before, after);
}

/**
 * Fast in-memory diff algorithm - no git spawning, no temp files.
 * Uses efficient line-by-line comparison with context tracking.
 * ~10x faster than git-based diff for typical edits.
 */
function buildDiffSegmentsFast(previous, next) {
  const before = normalizeNewlines(previous);
  const after = normalizeNewlines(next);
  if (before === after) {
    return [];
  }
  const oldLines = splitLines(before);
  const newLines = splitLines(after);
  const segments = [];

  // Limit output for very large files
  const MAX_DIFF_SEGMENTS = 200;
  const MAX_LINE_LENGTH = 500;

  // Use simple LCS-based approach optimized for typical code edits
  // Most edits are small, so we use a fast path for detecting changed regions
  let i = 0;
  let j = 0;
  while (i < oldLines.length || j < newLines.length) {
    if (segments.length >= MAX_DIFF_SEGMENTS) {
      const remaining = Math.max(oldLines.length - i, newLines.length - j);
      if (remaining > 0) {
        segments.push({
          type: 'added',
          lineNumber: 0,
          content: `[Diff truncated - ${remaining} more lines not shown]`
        });
      }
      break;
    }
    const oldLine = oldLines[i];
    const newLine = newLines[j];

    // Both lines exist and match - skip
    if (oldLine === newLine) {
      i++;
      j++;
      continue;
    }

    // Look ahead to find matching lines (handles insertions/deletions)
    const lookAhead = 10;
    let foundOld = -1;
    let foundNew = -1;

    // Check if current old line appears later in new (deletion followed by same content)
    for (let k = 1; k <= lookAhead && j + k < newLines.length; k++) {
      if (oldLine === newLines[j + k]) {
        foundNew = j + k;
        break;
      }
    }

    // Check if current new line appears later in old (insertion)
    for (let k = 1; k <= lookAhead && i + k < oldLines.length; k++) {
      if (newLine === oldLines[i + k]) {
        foundOld = i + k;
        break;
      }
    }

    // Insertion: new lines were added
    if (foundOld > 0 && (foundNew < 0 || foundNew > foundOld)) {
      while (j < newLines.length && newLines[j] !== oldLines[i]) {
        if (segments.length >= MAX_DIFF_SEGMENTS) break;
        const content = newLines[j] || '';
        segments.push({
          type: 'added',
          lineNumber: j + 1,
          content: content.length > MAX_LINE_LENGTH ? `${content.slice(0, MAX_LINE_LENGTH)}...` : content
        });
        j++;
      }
      continue;
    }

    // Deletion: old lines were removed
    if (foundNew > 0) {
      while (i < oldLines.length && oldLines[i] !== newLines[j]) {
        if (segments.length >= MAX_DIFF_SEGMENTS) break;
        const content = oldLines[i] || '';
        segments.push({
          type: 'removed',
          lineNumber: i + 1,
          content: content.length > MAX_LINE_LENGTH ? `${content.slice(0, MAX_LINE_LENGTH)}...` : content
        });
        i++;
      }
      continue;
    }

    // Modification: line changed
    if (typeof oldLine === 'string') {
      const content = oldLine.length > MAX_LINE_LENGTH ? `${oldLine.slice(0, MAX_LINE_LENGTH)}...` : oldLine;
      segments.push({
        type: 'removed',
        lineNumber: i + 1,
        content
      });
      i++;
    }
    if (typeof newLine === 'string') {
      const content = newLine.length > MAX_LINE_LENGTH ? `${newLine.slice(0, MAX_LINE_LENGTH)}...` : newLine;
      segments.push({
        type: 'added',
        lineNumber: j + 1,
        content
      });
      j++;
    }

    // Handle end of one array
    if (i >= oldLines.length && j < newLines.length) {
      j++;
    } else if (j >= newLines.length && i < oldLines.length) {
      i++;
    }
  }
  return segments;
}

// ANSI color codes for terminal output
const ANSI_RESET = '\x1b[0m';
const ANSI_RED = '\x1b[31m';
const ANSI_GREEN = '\x1b[32m';
const ANSI_DIM = '\x1b[2m';
// Background colors for Claude Code style highlighting

/**
 * Format diff lines with + and - prefixes for added/removed lines.
 * Supports context lines (unchanged lines around changes).
 */
function formatDiffLines(diff, useColors = true) {
  if (!diff.length) {
    return [];
  }
  const width = Math.max(1, ...diff.map(entry => Math.max(1, entry.lineNumber).toString().length));
  return diff.map(entry => {
    const lineNumber = Math.max(1, entry.lineNumber);
    const body = entry.content.length > 0 ? entry.content : '[empty line]';
    const paddedNumber = lineNumber.toString().padStart(width, ' ');
    if (entry.type === 'added') {
      const prefix = '+';
      if (useColors) {
        return `${ANSI_GREEN}${prefix} L${paddedNumber} | ${body}${ANSI_RESET}`;
      }
      return `${prefix} L${paddedNumber} | ${body}`;
    } else if (entry.type === 'removed') {
      const prefix = '-';
      if (useColors) {
        return `${ANSI_RED}${prefix} L${paddedNumber} | ${body}${ANSI_RESET}`;
      }
      return `${prefix} L${paddedNumber} | ${body}`;
    } else {
      // context line
      if (useColors) {
        return `${ANSI_DIM}  L${paddedNumber} | ${body}${ANSI_RESET}`;
      }
      return `  L${paddedNumber} | ${body}`;
    }
  });
}

/**
 * Format diff in Claude Code style with proper indentation and line wrapping.
 * Shows line numbers in margin with +/- symbols for changes.
 * Long lines are wrapped with continuation markers, but the default width is
 * deliberately generous so single logical lines don't look like multiple edits.
 *
 * Example output:
 *   1832 +    /**
 *        +     * Show a compacting
 *        + status with animated
 */
function formatDiffClaudeStyle(diff, useColors = true, maxLineWidth) {
  if (!diff.length) {
    return [];
  }

  // Use terminal-aware width so single logical lines don't appear split.
  const wrapWidth = normalizeWrapWidth(maxLineWidth);
  const INDENT = '      '; // 6 spaces for line number column
  const width = Math.max(1, ...diff.map(entry => Math.max(1, entry.lineNumber).toString().length));
  const result = [];
  for (const entry of diff) {
    const lineNumber = Math.max(1, entry.lineNumber);
    const paddedNumber = lineNumber.toString().padStart(width, ' ');
    const continuationPad = ' '.repeat(width); // Same width as line number for continuation

    if (entry.type === 'added') {
      const prefix = ` ${paddedNumber} +`;
      const continuationPrefix = `${continuationPad}    +`; // Align + with first line
      const body = entry.content;

      // Wrap long lines using terminal-aware width
      const wrappedLines = wrapDiffLine(body, wrapWidth);
      for (let i = 0; i < wrappedLines.length; i++) {
        const lineContent = wrappedLines[i];
        const isFirstLine = i === 0;
        const linePrefix = isFirstLine ? prefix : continuationPrefix;
        if (useColors) {
          result.push(`${ANSI_GREEN}${INDENT}${linePrefix}   ${lineContent}${ANSI_RESET}`);
        } else {
          result.push(`${INDENT}${linePrefix}   ${lineContent}`);
        }
      }
    } else if (entry.type === 'removed') {
      const prefix = ` ${paddedNumber} -`;
      const continuationPrefix = `${continuationPad}    -`; // Align - with first line
      const body = entry.content;

      // Wrap long lines using terminal-aware width
      const wrappedLines = wrapDiffLine(body, wrapWidth);
      for (let i = 0; i < wrappedLines.length; i++) {
        const lineContent = wrappedLines[i];
        const isFirstLine = i === 0;
        const linePrefix = isFirstLine ? prefix : continuationPrefix;
        if (useColors) {
          result.push(`${ANSI_RED}${INDENT}${linePrefix}   ${lineContent}${ANSI_RESET}`);
        } else {
          result.push(`${INDENT}${linePrefix}   ${lineContent}`);
        }
      }
    } else {
      // context line - no wrapping for context
      const prefix = ` ${paddedNumber}  `;
      const body = entry.content;
      if (useColors) {
        result.push(`${ANSI_DIM}${INDENT}${prefix}  ${body}${ANSI_RESET}`);
      } else {
        result.push(`${INDENT}${prefix}  ${body}`);
      }
    }
  }
  return result;
}
function normalizeWrapWidth(maxLineWidth) {
  // Honor explicit width when provided
  if (typeof maxLineWidth === 'number' && Number.isFinite(maxLineWidth) && maxLineWidth > 0) {
    return Math.max(40, Math.floor(maxLineWidth));
  }
  const terminalWidth = typeof process.stdout?.columns === 'number' && process.stdout.columns > 0 ? process.stdout.columns : null;

  // Default to a generous width so single logical lines don't render as multiple edits.
  // We intentionally avoid shrinking to the terminal width; the terminal can wrap naturally
  // without adding extra +/- prefixes that look like new lines.
  const baseWidth = terminalWidth ? Math.max(terminalWidth - 8, 120) : 240;

  // Cap to avoid runaway wrapping for extremely long lines while keeping most code unwrapped.
  return Math.max(200, Math.min(baseWidth, 500));
}

/**
 * Wrap a diff line at word boundaries if it exceeds maxWidth.
 * Preserves leading whitespace on first line.
 */
function wrapDiffLine(line, maxWidth) {
  const width = Math.max(1, Math.floor(maxWidth));
  if (line.length <= width) {
    return [line];
  }
  const result = [];
  let remaining = line;
  while (remaining.length > width) {
    // Find a good break point (space, or force break at maxWidth)
    let breakPoint = remaining.lastIndexOf(' ', width);
    if (breakPoint <= 0) {
      // No space found, force break
      breakPoint = width;
    }
    result.push(remaining.substring(0, breakPoint));
    remaining = remaining.substring(breakPoint).trimStart();
  }
  if (remaining.length > 0) {
    result.push(remaining);
  }
  return result.length > 0 ? result : [''];
}
function tryBuildWithGit(before, after) {
  let tempDir = null;
  try {
    tempDir = (0, _nodeFs.mkdtempSync)((0, _nodePath.join)((0, _nodeOs.tmpdir)(), 'agi-diff-'));
    const originalPath = (0, _nodePath.join)(tempDir, 'before.txt');
    const updatedPath = (0, _nodePath.join)(tempDir, 'after.txt');
    (0, _nodeFs.writeFileSync)(originalPath, before, 'utf8');
    (0, _nodeFs.writeFileSync)(updatedPath, after, 'utf8');
    const result = (0, _nodeChild_process.spawnSync)('git', ['--no-pager', 'diff', '--no-index', '--unified=0', '--color=never', '--', originalPath, updatedPath], {
      encoding: 'utf8'
    });
    if (result.error) {
      const code = result.error.code;
      if (code === 'ENOENT') {
        return null;
      }
      return null;
    }
    if (typeof result.status === 'number' && result.status > 1) {
      return null;
    }
    return parseUnifiedDiff(result.stdout);
  } catch {
    return null;
  } finally {
    if (tempDir) {
      (0, _nodeFs.rmSync)(tempDir, {
        recursive: true,
        force: true
      });
    }
  }
}
function parseUnifiedDiff(output) {
  if (!output.trim()) {
    return [];
  }
  const lines = output.split('\n');
  const segments = [];
  let oldLine = 0;
  let newLine = 0;
  for (const rawLine of lines) {
    const line = rawLine.replace(/\r$/, '');
    if (!line) {
      continue;
    }
    if (line.startsWith('@@')) {
      const match = /@@ -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@/.exec(line);
      if (match?.[1] && match?.[2]) {
        oldLine = parseInt(match[1], 10);
        newLine = parseInt(match[2], 10);
      }
      continue;
    }
    if (line.startsWith('+++') || line.startsWith('---') || line.startsWith('diff ') || line.startsWith('index ')) {
      continue;
    }
    if (line.startsWith('Binary ')) {
      continue;
    }
    if (line.startsWith('\\')) {
      continue;
    }
    if (line.startsWith('+')) {
      segments.push({
        type: 'added',
        lineNumber: newLine,
        content: line.slice(1)
      });
      newLine += 1;
      continue;
    }
    if (line.startsWith('-')) {
      segments.push({
        type: 'removed',
        lineNumber: oldLine,
        content: line.slice(1)
      });
      oldLine += 1;
      continue;
    }
    if (line.startsWith(' ')) {
      oldLine += 1;
      newLine += 1;
      continue;
    }
  }
  return segments;
}
function buildNaiveDiff(before, after) {
  const a = splitLines(before);
  const b = splitLines(after);
  const max = Math.max(a.length, b.length);
  const segments = [];

  // Limit diff output for very large files to prevent memory issues
  const MAX_DIFF_SEGMENTS = 500;
  const MAX_LINE_LENGTH = 1000;
  for (let index = 0; index < max; index += 1) {
    // Stop if we've collected too many segments
    if (segments.length >= MAX_DIFF_SEGMENTS) {
      segments.push({
        type: 'added',
        lineNumber: 0,
        content: `[Diff truncated - ${max - index} more lines not shown]`
      });
      break;
    }
    const left = a[index];
    const right = b[index];
    if (left === right) {
      continue;
    }
    if (typeof left === 'string') {
      // Truncate very long lines to prevent display issues
      const content = left.length > MAX_LINE_LENGTH ? `${left.slice(0, MAX_LINE_LENGTH)}...` : left;
      segments.push({
        type: 'removed',
        lineNumber: index + 1,
        content
      });
    }
    if (typeof right === 'string') {
      // Truncate very long lines to prevent display issues
      const content = right.length > MAX_LINE_LENGTH ? `${right.slice(0, MAX_LINE_LENGTH)}...` : right;
      segments.push({
        type: 'added',
        lineNumber: index + 1,
        content
      });
    }
  }
  return segments;
}
function normalizeNewlines(value) {
  return value.replace(/\r\n/g, '\n');
}
function splitLines(value) {
  if (!value) {
    return [];
  }
  const normalized = normalizeNewlines(value);
  return normalized.split('\n');
}

/**
 * Build a diff with context lines around changes (AGI CLI style).
 * Shows N lines before and after each change, with ... truncation for gaps.
 */
function buildDiffWithContext(previous, next, contextLines = 2) {
  const before = normalizeNewlines(previous);
  const after = normalizeNewlines(next);
  if (before === after) {
    return {
      segments: [],
      additions: 0,
      removals: 0
    };
  }
  const oldLines = splitLines(before);
  const newLines = splitLines(after);

  // First, identify all changed line indices
  const changes = [];

  // Simple LCS to find changes
  let i = 0;
  let j = 0;
  while (i < oldLines.length || j < newLines.length) {
    const oldLine = oldLines[i];
    const newLine = newLines[j];
    if (oldLine === newLine) {
      i++;
      j++;
      continue;
    }

    // Look ahead for matching lines
    const lookAhead = 15;
    let foundInNew = -1;
    let foundInOld = -1;
    for (let k = 1; k <= lookAhead && j + k < newLines.length; k++) {
      if (oldLine === newLines[j + k]) {
        foundInNew = j + k;
        break;
      }
    }
    for (let k = 1; k <= lookAhead && i + k < oldLines.length; k++) {
      if (newLine === oldLines[i + k]) {
        foundInOld = i + k;
        break;
      }
    }

    // Insertion
    if (foundInOld > 0 && (foundInNew < 0 || foundInNew > foundInOld)) {
      while (j < newLines.length && newLines[j] !== oldLines[i]) {
        changes.push({
          type: 'added',
          lineNumber: j + 1,
          content: newLines[j] || '',
          newLineIndex: j
        });
        j++;
      }
      continue;
    }

    // Deletion
    if (foundInNew > 0) {
      while (i < oldLines.length && oldLines[i] !== newLines[j]) {
        changes.push({
          type: 'removed',
          lineNumber: i + 1,
          content: oldLines[i] || '',
          oldLineIndex: i
        });
        i++;
      }
      continue;
    }

    // Modification
    if (typeof oldLine === 'string') {
      changes.push({
        type: 'removed',
        lineNumber: i + 1,
        content: oldLine,
        oldLineIndex: i
      });
      i++;
    }
    if (typeof newLine === 'string') {
      changes.push({
        type: 'added',
        lineNumber: j + 1,
        content: newLine,
        newLineIndex: j
      });
      j++;
    }
    if (i >= oldLines.length && j < newLines.length) {
      j++;
    } else if (j >= newLines.length && i < oldLines.length) {
      i++;
    }
  }

  // Count additions and removals
  const additions = changes.filter(c => c.type === 'added').length;
  const removals = changes.filter(c => c.type === 'removed').length;

  // Now build segments with context
  // Group changes that are close together
  const segments = [];
  const changeIndices = new Set();
  const removedIndices = new Set();
  for (const change of changes) {
    if (change.type === 'added' && change.newLineIndex !== undefined) {
      changeIndices.add(change.newLineIndex);
    }
    if (change.type === 'removed' && change.oldLineIndex !== undefined) {
      removedIndices.add(change.oldLineIndex);
    }
  }

  // For each change, include context lines
  const linesToShow = new Set();
  for (const change of changes) {
    if (change.type === 'added' && change.newLineIndex !== undefined) {
      const idx = change.newLineIndex;
      for (let k = Math.max(0, idx - contextLines); k <= Math.min(newLines.length - 1, idx + contextLines); k++) {
        linesToShow.add(k);
      }
    }
  }

  // Build final segments in order
  let lastLineShown = -1;
  const sortedLines = Array.from(linesToShow).sort((a, b) => a - b);
  for (const lineIdx of sortedLines) {
    // Add truncation marker if there's a gap
    if (lastLineShown >= 0 && lineIdx > lastLineShown + 1) {
      segments.push({
        type: 'context',
        lineNumber: 0,
        content: '...'
      });
    }
    if (changeIndices.has(lineIdx)) {
      segments.push({
        type: 'added',
        lineNumber: lineIdx + 1,
        content: newLines[lineIdx] || ''
      });
    } else {
      segments.push({
        type: 'context',
        lineNumber: lineIdx + 1,
        content: newLines[lineIdx] || ''
      });
    }
    lastLineShown = lineIdx;
  }

  // Add removed lines (show them before the context around their location)
  // Rebuild segments to interleave removals properly
  const finalSegments = [];
  let changeIdx = 0;
  for (const seg of segments) {
    // Insert any removals that come before this line
    while (changeIdx < changes.length) {
      const change = changes[changeIdx];
      if (!change) break;
      if (change.type === 'removed') {
        // Find where this removal should go - before the added line at same position
        const removedOldIdx = change.oldLineIndex ?? 0;
        // If we're showing an added line that replaced this removed line
        const matchingAdd = changes.find(c => c.type === 'added' && c.newLineIndex !== undefined && Math.abs(c.newLineIndex - removedOldIdx) <= 1);
        if (matchingAdd && seg.type === 'added' && seg.lineNumber === (matchingAdd.newLineIndex ?? 0) + 1) {
          finalSegments.push({
            type: 'removed',
            lineNumber: change.lineNumber,
            content: change.content
          });
          changeIdx++;
          continue;
        }
      }
      break;
    }
    finalSegments.push(seg);
  }

  // Add any remaining removals at the end
  while (changeIdx < changes.length) {
    const change = changes[changeIdx];
    if (!change) break;
    if (change.type === 'removed') {
      finalSegments.push({
        type: 'removed',
        lineNumber: change.lineNumber,
        content: change.content
      });
    }
    changeIdx++;
  }
  return {
    segments: finalSegments.length > 0 ? finalSegments : changes,
    additions,
    removals
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfbm9kZUNoaWxkX3Byb2Nlc3MiLCJyZXF1aXJlIiwiX25vZGVGcyIsIl9ub2RlT3MiLCJfbm9kZVBhdGgiLCJidWlsZERpZmZTZWdtZW50cyIsInByZXZpb3VzIiwibmV4dCIsImJlZm9yZSIsIm5vcm1hbGl6ZU5ld2xpbmVzIiwiYWZ0ZXIiLCJnaXRTZWdtZW50cyIsInRyeUJ1aWxkV2l0aEdpdCIsImJ1aWxkTmFpdmVEaWZmIiwiYnVpbGREaWZmU2VnbWVudHNGYXN0Iiwib2xkTGluZXMiLCJzcGxpdExpbmVzIiwibmV3TGluZXMiLCJzZWdtZW50cyIsIk1BWF9ESUZGX1NFR01FTlRTIiwiTUFYX0xJTkVfTEVOR1RIIiwiaSIsImoiLCJsZW5ndGgiLCJyZW1haW5pbmciLCJNYXRoIiwibWF4IiwicHVzaCIsInR5cGUiLCJsaW5lTnVtYmVyIiwiY29udGVudCIsIm9sZExpbmUiLCJuZXdMaW5lIiwibG9va0FoZWFkIiwiZm91bmRPbGQiLCJmb3VuZE5ldyIsImsiLCJzbGljZSIsIkFOU0lfUkVTRVQiLCJBTlNJX1JFRCIsIkFOU0lfR1JFRU4iLCJBTlNJX0RJTSIsImZvcm1hdERpZmZMaW5lcyIsImRpZmYiLCJ1c2VDb2xvcnMiLCJ3aWR0aCIsIm1hcCIsImVudHJ5IiwidG9TdHJpbmciLCJib2R5IiwicGFkZGVkTnVtYmVyIiwicGFkU3RhcnQiLCJwcmVmaXgiLCJmb3JtYXREaWZmQ2xhdWRlU3R5bGUiLCJtYXhMaW5lV2lkdGgiLCJ3cmFwV2lkdGgiLCJub3JtYWxpemVXcmFwV2lkdGgiLCJJTkRFTlQiLCJyZXN1bHQiLCJjb250aW51YXRpb25QYWQiLCJyZXBlYXQiLCJjb250aW51YXRpb25QcmVmaXgiLCJ3cmFwcGVkTGluZXMiLCJ3cmFwRGlmZkxpbmUiLCJsaW5lQ29udGVudCIsImlzRmlyc3RMaW5lIiwibGluZVByZWZpeCIsIk51bWJlciIsImlzRmluaXRlIiwiZmxvb3IiLCJ0ZXJtaW5hbFdpZHRoIiwicHJvY2VzcyIsInN0ZG91dCIsImNvbHVtbnMiLCJiYXNlV2lkdGgiLCJtaW4iLCJsaW5lIiwibWF4V2lkdGgiLCJicmVha1BvaW50IiwibGFzdEluZGV4T2YiLCJzdWJzdHJpbmciLCJ0cmltU3RhcnQiLCJ0ZW1wRGlyIiwibWtkdGVtcFN5bmMiLCJqb2luIiwidG1wZGlyIiwib3JpZ2luYWxQYXRoIiwidXBkYXRlZFBhdGgiLCJ3cml0ZUZpbGVTeW5jIiwic3Bhd25TeW5jIiwiZW5jb2RpbmciLCJlcnJvciIsImNvZGUiLCJzdGF0dXMiLCJwYXJzZVVuaWZpZWREaWZmIiwicm1TeW5jIiwicmVjdXJzaXZlIiwiZm9yY2UiLCJvdXRwdXQiLCJ0cmltIiwibGluZXMiLCJzcGxpdCIsInJhd0xpbmUiLCJyZXBsYWNlIiwic3RhcnRzV2l0aCIsIm1hdGNoIiwiZXhlYyIsInBhcnNlSW50IiwiYSIsImIiLCJpbmRleCIsImxlZnQiLCJyaWdodCIsInZhbHVlIiwibm9ybWFsaXplZCIsImJ1aWxkRGlmZldpdGhDb250ZXh0IiwiY29udGV4dExpbmVzIiwiYWRkaXRpb25zIiwicmVtb3ZhbHMiLCJjaGFuZ2VzIiwiZm91bmRJbk5ldyIsImZvdW5kSW5PbGQiLCJuZXdMaW5lSW5kZXgiLCJvbGRMaW5lSW5kZXgiLCJmaWx0ZXIiLCJjIiwiY2hhbmdlSW5kaWNlcyIsIlNldCIsInJlbW92ZWRJbmRpY2VzIiwiY2hhbmdlIiwidW5kZWZpbmVkIiwiYWRkIiwibGluZXNUb1Nob3ciLCJpZHgiLCJsYXN0TGluZVNob3duIiwic29ydGVkTGluZXMiLCJBcnJheSIsImZyb20iLCJzb3J0IiwibGluZUlkeCIsImhhcyIsImZpbmFsU2VnbWVudHMiLCJjaGFuZ2VJZHgiLCJzZWciLCJyZW1vdmVkT2xkSWR4IiwibWF0Y2hpbmdBZGQiLCJmaW5kIiwiYWJzIl0sInNvdXJjZXMiOlsiZGlmZlV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNwYXduU3luYyB9IGZyb20gJ25vZGU6Y2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgeyBta2R0ZW1wU3luYywgcm1TeW5jLCB3cml0ZUZpbGVTeW5jIH0gZnJvbSAnbm9kZTpmcyc7XG5pbXBvcnQgeyB0bXBkaXIgfSBmcm9tICdub2RlOm9zJztcbmltcG9ydCB7IGpvaW4gfSBmcm9tICdub2RlOnBhdGgnO1xuXG5leHBvcnQgaW50ZXJmYWNlIERpZmZTZWdtZW50IHtcbiAgdHlwZTogJ2FkZGVkJyB8ICdyZW1vdmVkJyB8ICdjb250ZXh0JztcbiAgbGluZU51bWJlcjogbnVtYmVyO1xuICBjb250ZW50OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVzdWx0IGZyb20gYnVpbGRpbmcgYSBkaWZmIHdpdGggY29udGV4dCBsaW5lc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIERpZmZXaXRoQ29udGV4dCB7XG4gIHNlZ21lbnRzOiBEaWZmU2VnbWVudFtdO1xuICBhZGRpdGlvbnM6IG51bWJlcjtcbiAgcmVtb3ZhbHM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRGlmZlNlZ21lbnRzKHByZXZpb3VzOiBzdHJpbmcsIG5leHQ6IHN0cmluZyk6IERpZmZTZWdtZW50W10ge1xuICBjb25zdCBiZWZvcmUgPSBub3JtYWxpemVOZXdsaW5lcyhwcmV2aW91cyk7XG4gIGNvbnN0IGFmdGVyID0gbm9ybWFsaXplTmV3bGluZXMobmV4dCk7XG5cbiAgaWYgKGJlZm9yZSA9PT0gYWZ0ZXIpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBnaXRTZWdtZW50cyA9IHRyeUJ1aWxkV2l0aEdpdChiZWZvcmUsIGFmdGVyKTtcbiAgaWYgKGdpdFNlZ21lbnRzKSB7XG4gICAgcmV0dXJuIGdpdFNlZ21lbnRzO1xuICB9XG5cbiAgcmV0dXJuIGJ1aWxkTmFpdmVEaWZmKGJlZm9yZSwgYWZ0ZXIpO1xufVxuXG4vKipcbiAqIEZhc3QgaW4tbWVtb3J5IGRpZmYgYWxnb3JpdGhtIC0gbm8gZ2l0IHNwYXduaW5nLCBubyB0ZW1wIGZpbGVzLlxuICogVXNlcyBlZmZpY2llbnQgbGluZS1ieS1saW5lIGNvbXBhcmlzb24gd2l0aCBjb250ZXh0IHRyYWNraW5nLlxuICogfjEweCBmYXN0ZXIgdGhhbiBnaXQtYmFzZWQgZGlmZiBmb3IgdHlwaWNhbCBlZGl0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRGlmZlNlZ21lbnRzRmFzdChwcmV2aW91czogc3RyaW5nLCBuZXh0OiBzdHJpbmcpOiBEaWZmU2VnbWVudFtdIHtcbiAgY29uc3QgYmVmb3JlID0gbm9ybWFsaXplTmV3bGluZXMocHJldmlvdXMpO1xuICBjb25zdCBhZnRlciA9IG5vcm1hbGl6ZU5ld2xpbmVzKG5leHQpO1xuXG4gIGlmIChiZWZvcmUgPT09IGFmdGVyKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3Qgb2xkTGluZXMgPSBzcGxpdExpbmVzKGJlZm9yZSk7XG4gIGNvbnN0IG5ld0xpbmVzID0gc3BsaXRMaW5lcyhhZnRlcik7XG4gIGNvbnN0IHNlZ21lbnRzOiBEaWZmU2VnbWVudFtdID0gW107XG5cbiAgLy8gTGltaXQgb3V0cHV0IGZvciB2ZXJ5IGxhcmdlIGZpbGVzXG4gIGNvbnN0IE1BWF9ESUZGX1NFR01FTlRTID0gMjAwO1xuICBjb25zdCBNQVhfTElORV9MRU5HVEggPSA1MDA7XG5cbiAgLy8gVXNlIHNpbXBsZSBMQ1MtYmFzZWQgYXBwcm9hY2ggb3B0aW1pemVkIGZvciB0eXBpY2FsIGNvZGUgZWRpdHNcbiAgLy8gTW9zdCBlZGl0cyBhcmUgc21hbGwsIHNvIHdlIHVzZSBhIGZhc3QgcGF0aCBmb3IgZGV0ZWN0aW5nIGNoYW5nZWQgcmVnaW9uc1xuICBsZXQgaSA9IDA7XG4gIGxldCBqID0gMDtcblxuICB3aGlsZSAoaSA8IG9sZExpbmVzLmxlbmd0aCB8fCBqIDwgbmV3TGluZXMubGVuZ3RoKSB7XG4gICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+PSBNQVhfRElGRl9TRUdNRU5UUykge1xuICAgICAgY29uc3QgcmVtYWluaW5nID0gTWF0aC5tYXgob2xkTGluZXMubGVuZ3RoIC0gaSwgbmV3TGluZXMubGVuZ3RoIC0gaik7XG4gICAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnYWRkZWQnLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IDAsXG4gICAgICAgICAgY29udGVudDogYFtEaWZmIHRydW5jYXRlZCAtICR7cmVtYWluaW5nfSBtb3JlIGxpbmVzIG5vdCBzaG93bl1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkTGluZSA9IG9sZExpbmVzW2ldO1xuICAgIGNvbnN0IG5ld0xpbmUgPSBuZXdMaW5lc1tqXTtcblxuICAgIC8vIEJvdGggbGluZXMgZXhpc3QgYW5kIG1hdGNoIC0gc2tpcFxuICAgIGlmIChvbGRMaW5lID09PSBuZXdMaW5lKSB7XG4gICAgICBpKys7XG4gICAgICBqKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBMb29rIGFoZWFkIHRvIGZpbmQgbWF0Y2hpbmcgbGluZXMgKGhhbmRsZXMgaW5zZXJ0aW9ucy9kZWxldGlvbnMpXG4gICAgY29uc3QgbG9va0FoZWFkID0gMTA7XG4gICAgbGV0IGZvdW5kT2xkID0gLTE7XG4gICAgbGV0IGZvdW5kTmV3ID0gLTE7XG5cbiAgICAvLyBDaGVjayBpZiBjdXJyZW50IG9sZCBsaW5lIGFwcGVhcnMgbGF0ZXIgaW4gbmV3IChkZWxldGlvbiBmb2xsb3dlZCBieSBzYW1lIGNvbnRlbnQpXG4gICAgZm9yIChsZXQgayA9IDE7IGsgPD0gbG9va0FoZWFkICYmIGogKyBrIDwgbmV3TGluZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgIGlmIChvbGRMaW5lID09PSBuZXdMaW5lc1tqICsga10pIHtcbiAgICAgICAgZm91bmROZXcgPSBqICsgaztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgY3VycmVudCBuZXcgbGluZSBhcHBlYXJzIGxhdGVyIGluIG9sZCAoaW5zZXJ0aW9uKVxuICAgIGZvciAobGV0IGsgPSAxOyBrIDw9IGxvb2tBaGVhZCAmJiBpICsgayA8IG9sZExpbmVzLmxlbmd0aDsgaysrKSB7XG4gICAgICBpZiAobmV3TGluZSA9PT0gb2xkTGluZXNbaSArIGtdKSB7XG4gICAgICAgIGZvdW5kT2xkID0gaSArIGs7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluc2VydGlvbjogbmV3IGxpbmVzIHdlcmUgYWRkZWRcbiAgICBpZiAoZm91bmRPbGQgPiAwICYmIChmb3VuZE5ldyA8IDAgfHwgZm91bmROZXcgPiBmb3VuZE9sZCkpIHtcbiAgICAgIHdoaWxlIChqIDwgbmV3TGluZXMubGVuZ3RoICYmIG5ld0xpbmVzW2pdICE9PSBvbGRMaW5lc1tpXSkge1xuICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID49IE1BWF9ESUZGX1NFR01FTlRTKSBicmVhaztcbiAgICAgICAgY29uc3QgY29udGVudCA9IG5ld0xpbmVzW2pdIHx8ICcnO1xuICAgICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnYWRkZWQnLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IGogKyAxLFxuICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQubGVuZ3RoID4gTUFYX0xJTkVfTEVOR1RIID8gYCR7Y29udGVudC5zbGljZSgwLCBNQVhfTElORV9MRU5HVEgpICB9Li4uYCA6IGNvbnRlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIERlbGV0aW9uOiBvbGQgbGluZXMgd2VyZSByZW1vdmVkXG4gICAgaWYgKGZvdW5kTmV3ID4gMCkge1xuICAgICAgd2hpbGUgKGkgPCBvbGRMaW5lcy5sZW5ndGggJiYgb2xkTGluZXNbaV0gIT09IG5ld0xpbmVzW2pdKSB7XG4gICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPj0gTUFYX0RJRkZfU0VHTUVOVFMpIGJyZWFrO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gb2xkTGluZXNbaV0gfHwgJyc7XG4gICAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdyZW1vdmVkJyxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBpICsgMSxcbiAgICAgICAgICBjb250ZW50OiBjb250ZW50Lmxlbmd0aCA+IE1BWF9MSU5FX0xFTkdUSCA/IGAke2NvbnRlbnQuc2xpY2UoMCwgTUFYX0xJTkVfTEVOR1RIKSAgfS4uLmAgOiBjb250ZW50XG4gICAgICAgIH0pO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBNb2RpZmljYXRpb246IGxpbmUgY2hhbmdlZFxuICAgIGlmICh0eXBlb2Ygb2xkTGluZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBvbGRMaW5lLmxlbmd0aCA+IE1BWF9MSU5FX0xFTkdUSCA/IGAke29sZExpbmUuc2xpY2UoMCwgTUFYX0xJTkVfTEVOR1RIKSAgfS4uLmAgOiBvbGRMaW5lO1xuICAgICAgc2VnbWVudHMucHVzaCh7IHR5cGU6ICdyZW1vdmVkJywgbGluZU51bWJlcjogaSArIDEsIGNvbnRlbnQgfSk7XG4gICAgICBpKys7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV3TGluZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBuZXdMaW5lLmxlbmd0aCA+IE1BWF9MSU5FX0xFTkdUSCA/IGAke25ld0xpbmUuc2xpY2UoMCwgTUFYX0xJTkVfTEVOR1RIKSAgfS4uLmAgOiBuZXdMaW5lO1xuICAgICAgc2VnbWVudHMucHVzaCh7IHR5cGU6ICdhZGRlZCcsIGxpbmVOdW1iZXI6IGogKyAxLCBjb250ZW50IH0pO1xuICAgICAgaisrO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBlbmQgb2Ygb25lIGFycmF5XG4gICAgaWYgKGkgPj0gb2xkTGluZXMubGVuZ3RoICYmIGogPCBuZXdMaW5lcy5sZW5ndGgpIHtcbiAgICAgIGorKztcbiAgICB9IGVsc2UgaWYgKGogPj0gbmV3TGluZXMubGVuZ3RoICYmIGkgPCBvbGRMaW5lcy5sZW5ndGgpIHtcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VnbWVudHM7XG59XG5cbi8vIEFOU0kgY29sb3IgY29kZXMgZm9yIHRlcm1pbmFsIG91dHB1dFxuY29uc3QgQU5TSV9SRVNFVCA9ICdcXHgxYlswbSc7XG5jb25zdCBBTlNJX1JFRCA9ICdcXHgxYlszMW0nO1xuY29uc3QgQU5TSV9HUkVFTiA9ICdcXHgxYlszMm0nO1xuY29uc3QgQU5TSV9ESU0gPSAnXFx4MWJbMm0nO1xuLy8gQmFja2dyb3VuZCBjb2xvcnMgZm9yIENsYXVkZSBDb2RlIHN0eWxlIGhpZ2hsaWdodGluZ1xuXG4vKipcbiAqIEZvcm1hdCBkaWZmIGxpbmVzIHdpdGggKyBhbmQgLSBwcmVmaXhlcyBmb3IgYWRkZWQvcmVtb3ZlZCBsaW5lcy5cbiAqIFN1cHBvcnRzIGNvbnRleHQgbGluZXMgKHVuY2hhbmdlZCBsaW5lcyBhcm91bmQgY2hhbmdlcykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREaWZmTGluZXMoZGlmZjogRGlmZlNlZ21lbnRbXSwgdXNlQ29sb3JzID0gdHJ1ZSk6IHN0cmluZ1tdIHtcbiAgaWYgKCFkaWZmLmxlbmd0aCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCB3aWR0aCA9IE1hdGgubWF4KFxuICAgIDEsXG4gICAgLi4uZGlmZi5tYXAoKGVudHJ5KSA9PiBNYXRoLm1heCgxLCBlbnRyeS5saW5lTnVtYmVyKS50b1N0cmluZygpLmxlbmd0aClcbiAgKTtcblxuICByZXR1cm4gZGlmZi5tYXAoKGVudHJ5KSA9PiB7XG4gICAgY29uc3QgbGluZU51bWJlciA9IE1hdGgubWF4KDEsIGVudHJ5LmxpbmVOdW1iZXIpO1xuICAgIGNvbnN0IGJvZHkgPSBlbnRyeS5jb250ZW50Lmxlbmd0aCA+IDAgPyBlbnRyeS5jb250ZW50IDogJ1tlbXB0eSBsaW5lXSc7XG4gICAgY29uc3QgcGFkZGVkTnVtYmVyID0gbGluZU51bWJlci50b1N0cmluZygpLnBhZFN0YXJ0KHdpZHRoLCAnICcpO1xuXG4gICAgaWYgKGVudHJ5LnR5cGUgPT09ICdhZGRlZCcpIHtcbiAgICAgIGNvbnN0IHByZWZpeCA9ICcrJztcbiAgICAgIGlmICh1c2VDb2xvcnMpIHtcbiAgICAgICAgcmV0dXJuIGAke0FOU0lfR1JFRU59JHtwcmVmaXh9IEwke3BhZGRlZE51bWJlcn0gfCAke2JvZHl9JHtBTlNJX1JFU0VUfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYCR7cHJlZml4fSBMJHtwYWRkZWROdW1iZXJ9IHwgJHtib2R5fWA7XG4gICAgfSBlbHNlIGlmIChlbnRyeS50eXBlID09PSAncmVtb3ZlZCcpIHtcbiAgICAgIGNvbnN0IHByZWZpeCA9ICctJztcbiAgICAgIGlmICh1c2VDb2xvcnMpIHtcbiAgICAgICAgcmV0dXJuIGAke0FOU0lfUkVEfSR7cHJlZml4fSBMJHtwYWRkZWROdW1iZXJ9IHwgJHtib2R5fSR7QU5TSV9SRVNFVH1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGAke3ByZWZpeH0gTCR7cGFkZGVkTnVtYmVyfSB8ICR7Ym9keX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb250ZXh0IGxpbmVcbiAgICAgIGlmICh1c2VDb2xvcnMpIHtcbiAgICAgICAgcmV0dXJuIGAke0FOU0lfRElNfSAgTCR7cGFkZGVkTnVtYmVyfSB8ICR7Ym9keX0ke0FOU0lfUkVTRVR9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgICBMJHtwYWRkZWROdW1iZXJ9IHwgJHtib2R5fWA7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgZGlmZiBpbiBDbGF1ZGUgQ29kZSBzdHlsZSB3aXRoIHByb3BlciBpbmRlbnRhdGlvbiBhbmQgbGluZSB3cmFwcGluZy5cbiAqIFNob3dzIGxpbmUgbnVtYmVycyBpbiBtYXJnaW4gd2l0aCArLy0gc3ltYm9scyBmb3IgY2hhbmdlcy5cbiAqIExvbmcgbGluZXMgYXJlIHdyYXBwZWQgd2l0aCBjb250aW51YXRpb24gbWFya2VycywgYnV0IHRoZSBkZWZhdWx0IHdpZHRoIGlzXG4gKiBkZWxpYmVyYXRlbHkgZ2VuZXJvdXMgc28gc2luZ2xlIGxvZ2ljYWwgbGluZXMgZG9uJ3QgbG9vayBsaWtlIG11bHRpcGxlIGVkaXRzLlxuICpcbiAqIEV4YW1wbGUgb3V0cHV0OlxuICogICAxODMyICsgICAgLyoqXG4gKiAgICAgICAgKyAgICAgKiBTaG93IGEgY29tcGFjdGluZ1xuICogICAgICAgICsgc3RhdHVzIHdpdGggYW5pbWF0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERpZmZDbGF1ZGVTdHlsZShcbiAgZGlmZjogRGlmZlNlZ21lbnRbXSxcbiAgdXNlQ29sb3JzID0gdHJ1ZSxcbiAgbWF4TGluZVdpZHRoPzogbnVtYmVyXG4pOiBzdHJpbmdbXSB7XG4gIGlmICghZGlmZi5sZW5ndGgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvLyBVc2UgdGVybWluYWwtYXdhcmUgd2lkdGggc28gc2luZ2xlIGxvZ2ljYWwgbGluZXMgZG9uJ3QgYXBwZWFyIHNwbGl0LlxuICBjb25zdCB3cmFwV2lkdGggPSBub3JtYWxpemVXcmFwV2lkdGgobWF4TGluZVdpZHRoKTtcblxuICBjb25zdCBJTkRFTlQgPSAnICAgICAgJzsgLy8gNiBzcGFjZXMgZm9yIGxpbmUgbnVtYmVyIGNvbHVtblxuICBjb25zdCB3aWR0aCA9IE1hdGgubWF4KFxuICAgIDEsXG4gICAgLi4uZGlmZi5tYXAoKGVudHJ5KSA9PiBNYXRoLm1heCgxLCBlbnRyeS5saW5lTnVtYmVyKS50b1N0cmluZygpLmxlbmd0aClcbiAgKTtcblxuICBjb25zdCByZXN1bHQ6IHN0cmluZ1tdID0gW107XG5cbiAgZm9yIChjb25zdCBlbnRyeSBvZiBkaWZmKSB7XG4gICAgY29uc3QgbGluZU51bWJlciA9IE1hdGgubWF4KDEsIGVudHJ5LmxpbmVOdW1iZXIpO1xuICAgIGNvbnN0IHBhZGRlZE51bWJlciA9IGxpbmVOdW1iZXIudG9TdHJpbmcoKS5wYWRTdGFydCh3aWR0aCwgJyAnKTtcbiAgICBjb25zdCBjb250aW51YXRpb25QYWQgPSAnICcucmVwZWF0KHdpZHRoKTsgLy8gU2FtZSB3aWR0aCBhcyBsaW5lIG51bWJlciBmb3IgY29udGludWF0aW9uXG5cbiAgICBpZiAoZW50cnkudHlwZSA9PT0gJ2FkZGVkJykge1xuICAgICAgY29uc3QgcHJlZml4ID0gYCAke3BhZGRlZE51bWJlcn0gK2A7XG4gICAgICBjb25zdCBjb250aW51YXRpb25QcmVmaXggPSBgJHtjb250aW51YXRpb25QYWR9ICAgICtgOyAvLyBBbGlnbiArIHdpdGggZmlyc3QgbGluZVxuICAgICAgY29uc3QgYm9keSA9IGVudHJ5LmNvbnRlbnQ7XG5cbiAgICAgIC8vIFdyYXAgbG9uZyBsaW5lcyB1c2luZyB0ZXJtaW5hbC1hd2FyZSB3aWR0aFxuICAgICAgY29uc3Qgd3JhcHBlZExpbmVzID0gd3JhcERpZmZMaW5lKGJvZHksIHdyYXBXaWR0aCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd3JhcHBlZExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxpbmVDb250ZW50ID0gd3JhcHBlZExpbmVzW2ldO1xuICAgICAgICBjb25zdCBpc0ZpcnN0TGluZSA9IGkgPT09IDA7XG4gICAgICAgIGNvbnN0IGxpbmVQcmVmaXggPSBpc0ZpcnN0TGluZSA/IHByZWZpeCA6IGNvbnRpbnVhdGlvblByZWZpeDtcblxuICAgICAgICBpZiAodXNlQ29sb3JzKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goYCR7QU5TSV9HUkVFTn0ke0lOREVOVH0ke2xpbmVQcmVmaXh9ICAgJHtsaW5lQ29udGVudH0ke0FOU0lfUkVTRVR9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goYCR7SU5ERU5UfSR7bGluZVByZWZpeH0gICAke2xpbmVDb250ZW50fWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbnRyeS50eXBlID09PSAncmVtb3ZlZCcpIHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGAgJHtwYWRkZWROdW1iZXJ9IC1gO1xuICAgICAgY29uc3QgY29udGludWF0aW9uUHJlZml4ID0gYCR7Y29udGludWF0aW9uUGFkfSAgICAtYDsgLy8gQWxpZ24gLSB3aXRoIGZpcnN0IGxpbmVcbiAgICAgIGNvbnN0IGJvZHkgPSBlbnRyeS5jb250ZW50O1xuXG4gICAgICAvLyBXcmFwIGxvbmcgbGluZXMgdXNpbmcgdGVybWluYWwtYXdhcmUgd2lkdGhcbiAgICAgIGNvbnN0IHdyYXBwZWRMaW5lcyA9IHdyYXBEaWZmTGluZShib2R5LCB3cmFwV2lkdGgpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyYXBwZWRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBsaW5lQ29udGVudCA9IHdyYXBwZWRMaW5lc1tpXTtcbiAgICAgICAgY29uc3QgaXNGaXJzdExpbmUgPSBpID09PSAwO1xuICAgICAgICBjb25zdCBsaW5lUHJlZml4ID0gaXNGaXJzdExpbmUgPyBwcmVmaXggOiBjb250aW51YXRpb25QcmVmaXg7XG5cbiAgICAgICAgaWYgKHVzZUNvbG9ycykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGAke0FOU0lfUkVEfSR7SU5ERU5UfSR7bGluZVByZWZpeH0gICAke2xpbmVDb250ZW50fSR7QU5TSV9SRVNFVH1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChgJHtJTkRFTlR9JHtsaW5lUHJlZml4fSAgICR7bGluZUNvbnRlbnR9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29udGV4dCBsaW5lIC0gbm8gd3JhcHBpbmcgZm9yIGNvbnRleHRcbiAgICAgIGNvbnN0IHByZWZpeCA9IGAgJHtwYWRkZWROdW1iZXJ9ICBgO1xuICAgICAgY29uc3QgYm9keSA9IGVudHJ5LmNvbnRlbnQ7XG4gICAgICBpZiAodXNlQ29sb3JzKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGAke0FOU0lfRElNfSR7SU5ERU5UfSR7cHJlZml4fSAgJHtib2R5fSR7QU5TSV9SRVNFVH1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGAke0lOREVOVH0ke3ByZWZpeH0gICR7Ym9keX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVXcmFwV2lkdGgobWF4TGluZVdpZHRoPzogbnVtYmVyKTogbnVtYmVyIHtcbiAgLy8gSG9ub3IgZXhwbGljaXQgd2lkdGggd2hlbiBwcm92aWRlZFxuICBpZiAodHlwZW9mIG1heExpbmVXaWR0aCA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzRmluaXRlKG1heExpbmVXaWR0aCkgJiYgbWF4TGluZVdpZHRoID4gMCkge1xuICAgIHJldHVybiBNYXRoLm1heCg0MCwgTWF0aC5mbG9vcihtYXhMaW5lV2lkdGgpKTtcbiAgfVxuXG4gIGNvbnN0IHRlcm1pbmFsV2lkdGggPSB0eXBlb2YgcHJvY2Vzcy5zdGRvdXQ/LmNvbHVtbnMgPT09ICdudW1iZXInICYmIHByb2Nlc3Muc3Rkb3V0LmNvbHVtbnMgPiAwXG4gICAgPyBwcm9jZXNzLnN0ZG91dC5jb2x1bW5zXG4gICAgOiBudWxsO1xuXG4gIC8vIERlZmF1bHQgdG8gYSBnZW5lcm91cyB3aWR0aCBzbyBzaW5nbGUgbG9naWNhbCBsaW5lcyBkb24ndCByZW5kZXIgYXMgbXVsdGlwbGUgZWRpdHMuXG4gIC8vIFdlIGludGVudGlvbmFsbHkgYXZvaWQgc2hyaW5raW5nIHRvIHRoZSB0ZXJtaW5hbCB3aWR0aDsgdGhlIHRlcm1pbmFsIGNhbiB3cmFwIG5hdHVyYWxseVxuICAvLyB3aXRob3V0IGFkZGluZyBleHRyYSArLy0gcHJlZml4ZXMgdGhhdCBsb29rIGxpa2UgbmV3IGxpbmVzLlxuICBjb25zdCBiYXNlV2lkdGggPSB0ZXJtaW5hbFdpZHRoID8gTWF0aC5tYXgodGVybWluYWxXaWR0aCAtIDgsIDEyMCkgOiAyNDA7XG5cbiAgLy8gQ2FwIHRvIGF2b2lkIHJ1bmF3YXkgd3JhcHBpbmcgZm9yIGV4dHJlbWVseSBsb25nIGxpbmVzIHdoaWxlIGtlZXBpbmcgbW9zdCBjb2RlIHVud3JhcHBlZC5cbiAgcmV0dXJuIE1hdGgubWF4KDIwMCwgTWF0aC5taW4oYmFzZVdpZHRoLCA1MDApKTtcbn1cblxuLyoqXG4gKiBXcmFwIGEgZGlmZiBsaW5lIGF0IHdvcmQgYm91bmRhcmllcyBpZiBpdCBleGNlZWRzIG1heFdpZHRoLlxuICogUHJlc2VydmVzIGxlYWRpbmcgd2hpdGVzcGFjZSBvbiBmaXJzdCBsaW5lLlxuICovXG5mdW5jdGlvbiB3cmFwRGlmZkxpbmUobGluZTogc3RyaW5nLCBtYXhXaWR0aDogbnVtYmVyKTogc3RyaW5nW10ge1xuICBjb25zdCB3aWR0aCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IobWF4V2lkdGgpKTtcblxuICBpZiAobGluZS5sZW5ndGggPD0gd2lkdGgpIHtcbiAgICByZXR1cm4gW2xpbmVdO1xuICB9XG5cbiAgY29uc3QgcmVzdWx0OiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgcmVtYWluaW5nID0gbGluZTtcblxuICB3aGlsZSAocmVtYWluaW5nLmxlbmd0aCA+IHdpZHRoKSB7XG4gICAgLy8gRmluZCBhIGdvb2QgYnJlYWsgcG9pbnQgKHNwYWNlLCBvciBmb3JjZSBicmVhayBhdCBtYXhXaWR0aClcbiAgICBsZXQgYnJlYWtQb2ludCA9IHJlbWFpbmluZy5sYXN0SW5kZXhPZignICcsIHdpZHRoKTtcbiAgICBpZiAoYnJlYWtQb2ludCA8PSAwKSB7XG4gICAgICAvLyBObyBzcGFjZSBmb3VuZCwgZm9yY2UgYnJlYWtcbiAgICAgIGJyZWFrUG9pbnQgPSB3aWR0aDtcbiAgICB9XG5cbiAgICByZXN1bHQucHVzaChyZW1haW5pbmcuc3Vic3RyaW5nKDAsIGJyZWFrUG9pbnQpKTtcbiAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyaW5nKGJyZWFrUG9pbnQpLnRyaW1TdGFydCgpO1xuICB9XG5cbiAgaWYgKHJlbWFpbmluZy5sZW5ndGggPiAwKSB7XG4gICAgcmVzdWx0LnB1c2gocmVtYWluaW5nKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQubGVuZ3RoID4gMCA/IHJlc3VsdCA6IFsnJ107XG59XG5cbmZ1bmN0aW9uIHRyeUJ1aWxkV2l0aEdpdChiZWZvcmU6IHN0cmluZywgYWZ0ZXI6IHN0cmluZyk6IERpZmZTZWdtZW50W10gfCBudWxsIHtcbiAgbGV0IHRlbXBEaXI6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICB0cnkge1xuICAgIHRlbXBEaXIgPSBta2R0ZW1wU3luYyhqb2luKHRtcGRpcigpLCAnYWdpLWRpZmYtJykpO1xuICAgIGNvbnN0IG9yaWdpbmFsUGF0aCA9IGpvaW4odGVtcERpciwgJ2JlZm9yZS50eHQnKTtcbiAgICBjb25zdCB1cGRhdGVkUGF0aCA9IGpvaW4odGVtcERpciwgJ2FmdGVyLnR4dCcpO1xuICAgIHdyaXRlRmlsZVN5bmMob3JpZ2luYWxQYXRoLCBiZWZvcmUsICd1dGY4Jyk7XG4gICAgd3JpdGVGaWxlU3luYyh1cGRhdGVkUGF0aCwgYWZ0ZXIsICd1dGY4Jyk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBzcGF3blN5bmMoXG4gICAgICAnZ2l0JyxcbiAgICAgIFsnLS1uby1wYWdlcicsICdkaWZmJywgJy0tbm8taW5kZXgnLCAnLS11bmlmaWVkPTAnLCAnLS1jb2xvcj1uZXZlcicsICctLScsIG9yaWdpbmFsUGF0aCwgdXBkYXRlZFBhdGhdLFxuICAgICAgeyBlbmNvZGluZzogJ3V0ZjgnIH1cbiAgICApO1xuXG4gICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgY29uc3QgY29kZSA9IChyZXN1bHQuZXJyb3IgYXMgTm9kZUpTLkVycm5vRXhjZXB0aW9uKS5jb2RlO1xuICAgICAgaWYgKGNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByZXN1bHQuc3RhdHVzID09PSAnbnVtYmVyJyAmJiByZXN1bHQuc3RhdHVzID4gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlVW5pZmllZERpZmYocmVzdWx0LnN0ZG91dCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9IGZpbmFsbHkge1xuICAgIGlmICh0ZW1wRGlyKSB7XG4gICAgICBybVN5bmModGVtcERpciwgeyByZWN1cnNpdmU6IHRydWUsIGZvcmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVVuaWZpZWREaWZmKG91dHB1dDogc3RyaW5nKTogRGlmZlNlZ21lbnRbXSB7XG4gIGlmICghb3V0cHV0LnRyaW0oKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IGxpbmVzID0gb3V0cHV0LnNwbGl0KCdcXG4nKTtcbiAgY29uc3Qgc2VnbWVudHM6IERpZmZTZWdtZW50W10gPSBbXTtcbiAgbGV0IG9sZExpbmUgPSAwO1xuICBsZXQgbmV3TGluZSA9IDA7XG5cbiAgZm9yIChjb25zdCByYXdMaW5lIG9mIGxpbmVzKSB7XG4gICAgY29uc3QgbGluZSA9IHJhd0xpbmUucmVwbGFjZSgvXFxyJC8sICcnKTtcbiAgICBpZiAoIWxpbmUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobGluZS5zdGFydHNXaXRoKCdAQCcpKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IC9AQCAtKFxcZCspKD86LFxcZCspPyBcXCsoXFxkKykoPzosXFxkKyk/IEBALy5leGVjKGxpbmUpO1xuICAgICAgaWYgKG1hdGNoPy5bMV0gJiYgbWF0Y2g/LlsyXSkge1xuICAgICAgICBvbGRMaW5lID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgICAgbmV3TGluZSA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGluZS5zdGFydHNXaXRoKCcrKysnKSB8fCBsaW5lLnN0YXJ0c1dpdGgoJy0tLScpIHx8IGxpbmUuc3RhcnRzV2l0aCgnZGlmZiAnKSB8fCBsaW5lLnN0YXJ0c1dpdGgoJ2luZGV4ICcpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGluZS5zdGFydHNXaXRoKCdCaW5hcnkgJykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJ1xcXFwnKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgnKycpKSB7XG4gICAgICBzZWdtZW50cy5wdXNoKHsgdHlwZTogJ2FkZGVkJywgbGluZU51bWJlcjogbmV3TGluZSwgY29udGVudDogbGluZS5zbGljZSgxKSB9KTtcbiAgICAgIG5ld0xpbmUgKz0gMTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJy0nKSkge1xuICAgICAgc2VnbWVudHMucHVzaCh7IHR5cGU6ICdyZW1vdmVkJywgbGluZU51bWJlcjogb2xkTGluZSwgY29udGVudDogbGluZS5zbGljZSgxKSB9KTtcbiAgICAgIG9sZExpbmUgKz0gMTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJyAnKSkge1xuICAgICAgb2xkTGluZSArPSAxO1xuICAgICAgbmV3TGluZSArPSAxO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnRzO1xufVxuXG5mdW5jdGlvbiBidWlsZE5haXZlRGlmZihiZWZvcmU6IHN0cmluZywgYWZ0ZXI6IHN0cmluZyk6IERpZmZTZWdtZW50W10ge1xuICBjb25zdCBhID0gc3BsaXRMaW5lcyhiZWZvcmUpO1xuICBjb25zdCBiID0gc3BsaXRMaW5lcyhhZnRlcik7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gIGNvbnN0IHNlZ21lbnRzOiBEaWZmU2VnbWVudFtdID0gW107XG5cbiAgLy8gTGltaXQgZGlmZiBvdXRwdXQgZm9yIHZlcnkgbGFyZ2UgZmlsZXMgdG8gcHJldmVudCBtZW1vcnkgaXNzdWVzXG4gIGNvbnN0IE1BWF9ESUZGX1NFR01FTlRTID0gNTAwO1xuICBjb25zdCBNQVhfTElORV9MRU5HVEggPSAxMDAwO1xuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBtYXg7IGluZGV4ICs9IDEpIHtcbiAgICAvLyBTdG9wIGlmIHdlJ3ZlIGNvbGxlY3RlZCB0b28gbWFueSBzZWdtZW50c1xuICAgIGlmIChzZWdtZW50cy5sZW5ndGggPj0gTUFYX0RJRkZfU0VHTUVOVFMpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnYWRkZWQnLFxuICAgICAgICBsaW5lTnVtYmVyOiAwLFxuICAgICAgICBjb250ZW50OiBgW0RpZmYgdHJ1bmNhdGVkIC0gJHttYXggLSBpbmRleH0gbW9yZSBsaW5lcyBub3Qgc2hvd25dYFxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb25zdCBsZWZ0ID0gYVtpbmRleF07XG4gICAgY29uc3QgcmlnaHQgPSBiW2luZGV4XTtcblxuICAgIGlmIChsZWZ0ID09PSByaWdodCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVHJ1bmNhdGUgdmVyeSBsb25nIGxpbmVzIHRvIHByZXZlbnQgZGlzcGxheSBpc3N1ZXNcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBsZWZ0Lmxlbmd0aCA+IE1BWF9MSU5FX0xFTkdUSFxuICAgICAgICA/IGAke2xlZnQuc2xpY2UoMCwgTUFYX0xJTkVfTEVOR1RIKSAgfS4uLmBcbiAgICAgICAgOiBsZWZ0O1xuICAgICAgc2VnbWVudHMucHVzaCh7IHR5cGU6ICdyZW1vdmVkJywgbGluZU51bWJlcjogaW5kZXggKyAxLCBjb250ZW50IH0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmlnaHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUcnVuY2F0ZSB2ZXJ5IGxvbmcgbGluZXMgdG8gcHJldmVudCBkaXNwbGF5IGlzc3Vlc1xuICAgICAgY29uc3QgY29udGVudCA9IHJpZ2h0Lmxlbmd0aCA+IE1BWF9MSU5FX0xFTkdUSFxuICAgICAgICA/IGAke3JpZ2h0LnNsaWNlKDAsIE1BWF9MSU5FX0xFTkdUSCkgIH0uLi5gXG4gICAgICAgIDogcmlnaHQ7XG4gICAgICBzZWdtZW50cy5wdXNoKHsgdHlwZTogJ2FkZGVkJywgbGluZU51bWJlcjogaW5kZXggKyAxLCBjb250ZW50IH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWdtZW50cztcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTmV3bGluZXModmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpO1xufVxuXG5mdW5jdGlvbiBzcGxpdExpbmVzKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZU5ld2xpbmVzKHZhbHVlKTtcbiAgcmV0dXJuIG5vcm1hbGl6ZWQuc3BsaXQoJ1xcbicpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgZGlmZiB3aXRoIGNvbnRleHQgbGluZXMgYXJvdW5kIGNoYW5nZXMgKEFHSSBDTEkgc3R5bGUpLlxuICogU2hvd3MgTiBsaW5lcyBiZWZvcmUgYW5kIGFmdGVyIGVhY2ggY2hhbmdlLCB3aXRoIC4uLiB0cnVuY2F0aW9uIGZvciBnYXBzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGREaWZmV2l0aENvbnRleHQoXG4gIHByZXZpb3VzOiBzdHJpbmcsXG4gIG5leHQ6IHN0cmluZyxcbiAgY29udGV4dExpbmVzID0gMlxuKTogRGlmZldpdGhDb250ZXh0IHtcbiAgY29uc3QgYmVmb3JlID0gbm9ybWFsaXplTmV3bGluZXMocHJldmlvdXMpO1xuICBjb25zdCBhZnRlciA9IG5vcm1hbGl6ZU5ld2xpbmVzKG5leHQpO1xuXG4gIGlmIChiZWZvcmUgPT09IGFmdGVyKSB7XG4gICAgcmV0dXJuIHsgc2VnbWVudHM6IFtdLCBhZGRpdGlvbnM6IDAsIHJlbW92YWxzOiAwIH07XG4gIH1cblxuICBjb25zdCBvbGRMaW5lcyA9IHNwbGl0TGluZXMoYmVmb3JlKTtcbiAgY29uc3QgbmV3TGluZXMgPSBzcGxpdExpbmVzKGFmdGVyKTtcblxuICAvLyBGaXJzdCwgaWRlbnRpZnkgYWxsIGNoYW5nZWQgbGluZSBpbmRpY2VzXG4gIGNvbnN0IGNoYW5nZXM6IEFycmF5PHtcbiAgICB0eXBlOiAnYWRkZWQnIHwgJ3JlbW92ZWQnO1xuICAgIGxpbmVOdW1iZXI6IG51bWJlcjtcbiAgICBjb250ZW50OiBzdHJpbmc7XG4gICAgbmV3TGluZUluZGV4PzogbnVtYmVyO1xuICAgIG9sZExpbmVJbmRleD86IG51bWJlcjtcbiAgfT4gPSBbXTtcblxuICAvLyBTaW1wbGUgTENTIHRvIGZpbmQgY2hhbmdlc1xuICBsZXQgaSA9IDA7XG4gIGxldCBqID0gMDtcblxuICB3aGlsZSAoaSA8IG9sZExpbmVzLmxlbmd0aCB8fCBqIDwgbmV3TGluZXMubGVuZ3RoKSB7XG4gICAgY29uc3Qgb2xkTGluZSA9IG9sZExpbmVzW2ldO1xuICAgIGNvbnN0IG5ld0xpbmUgPSBuZXdMaW5lc1tqXTtcblxuICAgIGlmIChvbGRMaW5lID09PSBuZXdMaW5lKSB7XG4gICAgICBpKys7XG4gICAgICBqKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBMb29rIGFoZWFkIGZvciBtYXRjaGluZyBsaW5lc1xuICAgIGNvbnN0IGxvb2tBaGVhZCA9IDE1O1xuICAgIGxldCBmb3VuZEluTmV3ID0gLTE7XG4gICAgbGV0IGZvdW5kSW5PbGQgPSAtMTtcblxuICAgIGZvciAobGV0IGsgPSAxOyBrIDw9IGxvb2tBaGVhZCAmJiBqICsgayA8IG5ld0xpbmVzLmxlbmd0aDsgaysrKSB7XG4gICAgICBpZiAob2xkTGluZSA9PT0gbmV3TGluZXNbaiArIGtdKSB7XG4gICAgICAgIGZvdW5kSW5OZXcgPSBqICsgaztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgayA9IDE7IGsgPD0gbG9va0FoZWFkICYmIGkgKyBrIDwgb2xkTGluZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgIGlmIChuZXdMaW5lID09PSBvbGRMaW5lc1tpICsga10pIHtcbiAgICAgICAgZm91bmRJbk9sZCA9IGkgKyBrO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbnNlcnRpb25cbiAgICBpZiAoZm91bmRJbk9sZCA+IDAgJiYgKGZvdW5kSW5OZXcgPCAwIHx8IGZvdW5kSW5OZXcgPiBmb3VuZEluT2xkKSkge1xuICAgICAgd2hpbGUgKGogPCBuZXdMaW5lcy5sZW5ndGggJiYgbmV3TGluZXNbal0gIT09IG9sZExpbmVzW2ldKSB7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ2FkZGVkJyxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBqICsgMSxcbiAgICAgICAgICBjb250ZW50OiBuZXdMaW5lc1tqXSB8fCAnJyxcbiAgICAgICAgICBuZXdMaW5lSW5kZXg6IGosXG4gICAgICAgIH0pO1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBEZWxldGlvblxuICAgIGlmIChmb3VuZEluTmV3ID4gMCkge1xuICAgICAgd2hpbGUgKGkgPCBvbGRMaW5lcy5sZW5ndGggJiYgb2xkTGluZXNbaV0gIT09IG5ld0xpbmVzW2pdKSB7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJ3JlbW92ZWQnLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IGkgKyAxLFxuICAgICAgICAgIGNvbnRlbnQ6IG9sZExpbmVzW2ldIHx8ICcnLFxuICAgICAgICAgIG9sZExpbmVJbmRleDogaSxcbiAgICAgICAgfSk7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIE1vZGlmaWNhdGlvblxuICAgIGlmICh0eXBlb2Ygb2xkTGluZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdyZW1vdmVkJyxcbiAgICAgICAgbGluZU51bWJlcjogaSArIDEsXG4gICAgICAgIGNvbnRlbnQ6IG9sZExpbmUsXG4gICAgICAgIG9sZExpbmVJbmRleDogaSxcbiAgICAgIH0pO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5ld0xpbmUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICB0eXBlOiAnYWRkZWQnLFxuICAgICAgICBsaW5lTnVtYmVyOiBqICsgMSxcbiAgICAgICAgY29udGVudDogbmV3TGluZSxcbiAgICAgICAgbmV3TGluZUluZGV4OiBqLFxuICAgICAgfSk7XG4gICAgICBqKys7XG4gICAgfVxuXG4gICAgaWYgKGkgPj0gb2xkTGluZXMubGVuZ3RoICYmIGogPCBuZXdMaW5lcy5sZW5ndGgpIHtcbiAgICAgIGorKztcbiAgICB9IGVsc2UgaWYgKGogPj0gbmV3TGluZXMubGVuZ3RoICYmIGkgPCBvbGRMaW5lcy5sZW5ndGgpIHtcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cblxuICAvLyBDb3VudCBhZGRpdGlvbnMgYW5kIHJlbW92YWxzXG4gIGNvbnN0IGFkZGl0aW9ucyA9IGNoYW5nZXMuZmlsdGVyKChjKSA9PiBjLnR5cGUgPT09ICdhZGRlZCcpLmxlbmd0aDtcbiAgY29uc3QgcmVtb3ZhbHMgPSBjaGFuZ2VzLmZpbHRlcigoYykgPT4gYy50eXBlID09PSAncmVtb3ZlZCcpLmxlbmd0aDtcblxuICAvLyBOb3cgYnVpbGQgc2VnbWVudHMgd2l0aCBjb250ZXh0XG4gIC8vIEdyb3VwIGNoYW5nZXMgdGhhdCBhcmUgY2xvc2UgdG9nZXRoZXJcbiAgY29uc3Qgc2VnbWVudHM6IERpZmZTZWdtZW50W10gPSBbXTtcbiAgY29uc3QgY2hhbmdlSW5kaWNlcyA9IG5ldyBTZXQ8bnVtYmVyPigpO1xuICBjb25zdCByZW1vdmVkSW5kaWNlcyA9IG5ldyBTZXQ8bnVtYmVyPigpO1xuXG4gIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICBpZiAoY2hhbmdlLnR5cGUgPT09ICdhZGRlZCcgJiYgY2hhbmdlLm5ld0xpbmVJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjaGFuZ2VJbmRpY2VzLmFkZChjaGFuZ2UubmV3TGluZUluZGV4KTtcbiAgICB9XG4gICAgaWYgKGNoYW5nZS50eXBlID09PSAncmVtb3ZlZCcgJiYgY2hhbmdlLm9sZExpbmVJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZW1vdmVkSW5kaWNlcy5hZGQoY2hhbmdlLm9sZExpbmVJbmRleCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRm9yIGVhY2ggY2hhbmdlLCBpbmNsdWRlIGNvbnRleHQgbGluZXNcbiAgY29uc3QgbGluZXNUb1Nob3cgPSBuZXcgU2V0PG51bWJlcj4oKTtcbiAgZm9yIChjb25zdCBjaGFuZ2Ugb2YgY2hhbmdlcykge1xuICAgIGlmIChjaGFuZ2UudHlwZSA9PT0gJ2FkZGVkJyAmJiBjaGFuZ2UubmV3TGluZUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGlkeCA9IGNoYW5nZS5uZXdMaW5lSW5kZXg7XG4gICAgICBmb3IgKGxldCBrID0gTWF0aC5tYXgoMCwgaWR4IC0gY29udGV4dExpbmVzKTsgayA8PSBNYXRoLm1pbihuZXdMaW5lcy5sZW5ndGggLSAxLCBpZHggKyBjb250ZXh0TGluZXMpOyBrKyspIHtcbiAgICAgICAgbGluZXNUb1Nob3cuYWRkKGspO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEJ1aWxkIGZpbmFsIHNlZ21lbnRzIGluIG9yZGVyXG4gIGxldCBsYXN0TGluZVNob3duID0gLTE7XG4gIGNvbnN0IHNvcnRlZExpbmVzID0gQXJyYXkuZnJvbShsaW5lc1RvU2hvdykuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuXG4gIGZvciAoY29uc3QgbGluZUlkeCBvZiBzb3J0ZWRMaW5lcykge1xuICAgIC8vIEFkZCB0cnVuY2F0aW9uIG1hcmtlciBpZiB0aGVyZSdzIGEgZ2FwXG4gICAgaWYgKGxhc3RMaW5lU2hvd24gPj0gMCAmJiBsaW5lSWR4ID4gbGFzdExpbmVTaG93biArIDEpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnY29udGV4dCcsXG4gICAgICAgIGxpbmVOdW1iZXI6IDAsXG4gICAgICAgIGNvbnRlbnQ6ICcuLi4nLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZUluZGljZXMuaGFzKGxpbmVJZHgpKSB7XG4gICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2FkZGVkJyxcbiAgICAgICAgbGluZU51bWJlcjogbGluZUlkeCArIDEsXG4gICAgICAgIGNvbnRlbnQ6IG5ld0xpbmVzW2xpbmVJZHhdIHx8ICcnLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnY29udGV4dCcsXG4gICAgICAgIGxpbmVOdW1iZXI6IGxpbmVJZHggKyAxLFxuICAgICAgICBjb250ZW50OiBuZXdMaW5lc1tsaW5lSWR4XSB8fCAnJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsYXN0TGluZVNob3duID0gbGluZUlkeDtcbiAgfVxuXG4gIC8vIEFkZCByZW1vdmVkIGxpbmVzIChzaG93IHRoZW0gYmVmb3JlIHRoZSBjb250ZXh0IGFyb3VuZCB0aGVpciBsb2NhdGlvbilcbiAgLy8gUmVidWlsZCBzZWdtZW50cyB0byBpbnRlcmxlYXZlIHJlbW92YWxzIHByb3Blcmx5XG4gIGNvbnN0IGZpbmFsU2VnbWVudHM6IERpZmZTZWdtZW50W10gPSBbXTtcbiAgbGV0IGNoYW5nZUlkeCA9IDA7XG5cbiAgZm9yIChjb25zdCBzZWcgb2Ygc2VnbWVudHMpIHtcbiAgICAvLyBJbnNlcnQgYW55IHJlbW92YWxzIHRoYXQgY29tZSBiZWZvcmUgdGhpcyBsaW5lXG4gICAgd2hpbGUgKGNoYW5nZUlkeCA8IGNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBjaGFuZ2UgPSBjaGFuZ2VzW2NoYW5nZUlkeF07XG4gICAgICBpZiAoIWNoYW5nZSkgYnJlYWs7XG4gICAgICBpZiAoY2hhbmdlLnR5cGUgPT09ICdyZW1vdmVkJykge1xuICAgICAgICAvLyBGaW5kIHdoZXJlIHRoaXMgcmVtb3ZhbCBzaG91bGQgZ28gLSBiZWZvcmUgdGhlIGFkZGVkIGxpbmUgYXQgc2FtZSBwb3NpdGlvblxuICAgICAgICBjb25zdCByZW1vdmVkT2xkSWR4ID0gY2hhbmdlLm9sZExpbmVJbmRleCA/PyAwO1xuICAgICAgICAvLyBJZiB3ZSdyZSBzaG93aW5nIGFuIGFkZGVkIGxpbmUgdGhhdCByZXBsYWNlZCB0aGlzIHJlbW92ZWQgbGluZVxuICAgICAgICBjb25zdCBtYXRjaGluZ0FkZCA9IGNoYW5nZXMuZmluZChcbiAgICAgICAgICAoYykgPT4gYy50eXBlID09PSAnYWRkZWQnICYmIGMubmV3TGluZUluZGV4ICE9PSB1bmRlZmluZWQgJiYgTWF0aC5hYnMoKGMubmV3TGluZUluZGV4KSAtIHJlbW92ZWRPbGRJZHgpIDw9IDFcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG1hdGNoaW5nQWRkICYmIHNlZy50eXBlID09PSAnYWRkZWQnICYmIHNlZy5saW5lTnVtYmVyID09PSAobWF0Y2hpbmdBZGQubmV3TGluZUluZGV4ID8/IDApICsgMSkge1xuICAgICAgICAgIGZpbmFsU2VnbWVudHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlZCcsXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBjaGFuZ2UubGluZU51bWJlcixcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNoYW5nZS5jb250ZW50LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNoYW5nZUlkeCsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZmluYWxTZWdtZW50cy5wdXNoKHNlZyk7XG4gIH1cblxuICAvLyBBZGQgYW55IHJlbWFpbmluZyByZW1vdmFscyBhdCB0aGUgZW5kXG4gIHdoaWxlIChjaGFuZ2VJZHggPCBjaGFuZ2VzLmxlbmd0aCkge1xuICAgIGNvbnN0IGNoYW5nZSA9IGNoYW5nZXNbY2hhbmdlSWR4XTtcbiAgICBpZiAoIWNoYW5nZSkgYnJlYWs7XG4gICAgaWYgKGNoYW5nZS50eXBlID09PSAncmVtb3ZlZCcpIHtcbiAgICAgIGZpbmFsU2VnbWVudHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdyZW1vdmVkJyxcbiAgICAgICAgbGluZU51bWJlcjogY2hhbmdlLmxpbmVOdW1iZXIsXG4gICAgICAgIGNvbnRlbnQ6IGNoYW5nZS5jb250ZW50LFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNoYW5nZUlkeCsrO1xuICB9XG5cbiAgcmV0dXJuIHsgc2VnbWVudHM6IGZpbmFsU2VnbWVudHMubGVuZ3RoID4gMCA/IGZpbmFsU2VnbWVudHMgOiBjaGFuZ2VzLCBhZGRpdGlvbnMsIHJlbW92YWxzIH07XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxJQUFBQSxrQkFBQSxHQUFBQyxPQUFBO0FBQ0EsSUFBQUMsT0FBQSxHQUFBRCxPQUFBO0FBQ0EsSUFBQUUsT0FBQSxHQUFBRixPQUFBO0FBQ0EsSUFBQUcsU0FBQSxHQUFBSCxPQUFBO0FBUUE7QUFDQTtBQUNBOztBQU9PLFNBQVNJLGlCQUFpQkEsQ0FBQ0MsUUFBZ0IsRUFBRUMsSUFBWSxFQUFpQjtFQUMvRSxNQUFNQyxNQUFNLEdBQUdDLGlCQUFpQixDQUFDSCxRQUFRLENBQUM7RUFDMUMsTUFBTUksS0FBSyxHQUFHRCxpQkFBaUIsQ0FBQ0YsSUFBSSxDQUFDO0VBRXJDLElBQUlDLE1BQU0sS0FBS0UsS0FBSyxFQUFFO0lBQ3BCLE9BQU8sRUFBRTtFQUNYO0VBRUEsTUFBTUMsV0FBVyxHQUFHQyxlQUFlLENBQUNKLE1BQU0sRUFBRUUsS0FBSyxDQUFDO0VBQ2xELElBQUlDLFdBQVcsRUFBRTtJQUNmLE9BQU9BLFdBQVc7RUFDcEI7RUFFQSxPQUFPRSxjQUFjLENBQUNMLE1BQU0sRUFBRUUsS0FBSyxDQUFDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTSSxxQkFBcUJBLENBQUNSLFFBQWdCLEVBQUVDLElBQVksRUFBaUI7RUFDbkYsTUFBTUMsTUFBTSxHQUFHQyxpQkFBaUIsQ0FBQ0gsUUFBUSxDQUFDO0VBQzFDLE1BQU1JLEtBQUssR0FBR0QsaUJBQWlCLENBQUNGLElBQUksQ0FBQztFQUVyQyxJQUFJQyxNQUFNLEtBQUtFLEtBQUssRUFBRTtJQUNwQixPQUFPLEVBQUU7RUFDWDtFQUVBLE1BQU1LLFFBQVEsR0FBR0MsVUFBVSxDQUFDUixNQUFNLENBQUM7RUFDbkMsTUFBTVMsUUFBUSxHQUFHRCxVQUFVLENBQUNOLEtBQUssQ0FBQztFQUNsQyxNQUFNUSxRQUF1QixHQUFHLEVBQUU7O0VBRWxDO0VBQ0EsTUFBTUMsaUJBQWlCLEdBQUcsR0FBRztFQUM3QixNQUFNQyxlQUFlLEdBQUcsR0FBRzs7RUFFM0I7RUFDQTtFQUNBLElBQUlDLENBQUMsR0FBRyxDQUFDO0VBQ1QsSUFBSUMsQ0FBQyxHQUFHLENBQUM7RUFFVCxPQUFPRCxDQUFDLEdBQUdOLFFBQVEsQ0FBQ1EsTUFBTSxJQUFJRCxDQUFDLEdBQUdMLFFBQVEsQ0FBQ00sTUFBTSxFQUFFO0lBQ2pELElBQUlMLFFBQVEsQ0FBQ0ssTUFBTSxJQUFJSixpQkFBaUIsRUFBRTtNQUN4QyxNQUFNSyxTQUFTLEdBQUdDLElBQUksQ0FBQ0MsR0FBRyxDQUFDWCxRQUFRLENBQUNRLE1BQU0sR0FBR0YsQ0FBQyxFQUFFSixRQUFRLENBQUNNLE1BQU0sR0FBR0QsQ0FBQyxDQUFDO01BQ3BFLElBQUlFLFNBQVMsR0FBRyxDQUFDLEVBQUU7UUFDakJOLFFBQVEsQ0FBQ1MsSUFBSSxDQUFDO1VBQ1pDLElBQUksRUFBRSxPQUFPO1VBQ2JDLFVBQVUsRUFBRSxDQUFDO1VBQ2JDLE9BQU8sRUFBRSxxQkFBcUJOLFNBQVM7UUFDekMsQ0FBQyxDQUFDO01BQ0o7TUFDQTtJQUNGO0lBRUEsTUFBTU8sT0FBTyxHQUFHaEIsUUFBUSxDQUFDTSxDQUFDLENBQUM7SUFDM0IsTUFBTVcsT0FBTyxHQUFHZixRQUFRLENBQUNLLENBQUMsQ0FBQzs7SUFFM0I7SUFDQSxJQUFJUyxPQUFPLEtBQUtDLE9BQU8sRUFBRTtNQUN2QlgsQ0FBQyxFQUFFO01BQ0hDLENBQUMsRUFBRTtNQUNIO0lBQ0Y7O0lBRUE7SUFDQSxNQUFNVyxTQUFTLEdBQUcsRUFBRTtJQUNwQixJQUFJQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLElBQUlDLFFBQVEsR0FBRyxDQUFDLENBQUM7O0lBRWpCO0lBQ0EsS0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLElBQUlILFNBQVMsSUFBSVgsQ0FBQyxHQUFHYyxDQUFDLEdBQUduQixRQUFRLENBQUNNLE1BQU0sRUFBRWEsQ0FBQyxFQUFFLEVBQUU7TUFDOUQsSUFBSUwsT0FBTyxLQUFLZCxRQUFRLENBQUNLLENBQUMsR0FBR2MsQ0FBQyxDQUFDLEVBQUU7UUFDL0JELFFBQVEsR0FBR2IsQ0FBQyxHQUFHYyxDQUFDO1FBQ2hCO01BQ0Y7SUFDRjs7SUFFQTtJQUNBLEtBQUssSUFBSUEsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxJQUFJSCxTQUFTLElBQUlaLENBQUMsR0FBR2UsQ0FBQyxHQUFHckIsUUFBUSxDQUFDUSxNQUFNLEVBQUVhLENBQUMsRUFBRSxFQUFFO01BQzlELElBQUlKLE9BQU8sS0FBS2pCLFFBQVEsQ0FBQ00sQ0FBQyxHQUFHZSxDQUFDLENBQUMsRUFBRTtRQUMvQkYsUUFBUSxHQUFHYixDQUFDLEdBQUdlLENBQUM7UUFDaEI7TUFDRjtJQUNGOztJQUVBO0lBQ0EsSUFBSUYsUUFBUSxHQUFHLENBQUMsS0FBS0MsUUFBUSxHQUFHLENBQUMsSUFBSUEsUUFBUSxHQUFHRCxRQUFRLENBQUMsRUFBRTtNQUN6RCxPQUFPWixDQUFDLEdBQUdMLFFBQVEsQ0FBQ00sTUFBTSxJQUFJTixRQUFRLENBQUNLLENBQUMsQ0FBQyxLQUFLUCxRQUFRLENBQUNNLENBQUMsQ0FBQyxFQUFFO1FBQ3pELElBQUlILFFBQVEsQ0FBQ0ssTUFBTSxJQUFJSixpQkFBaUIsRUFBRTtRQUMxQyxNQUFNVyxPQUFPLEdBQUdiLFFBQVEsQ0FBQ0ssQ0FBQyxDQUFDLElBQUksRUFBRTtRQUNqQ0osUUFBUSxDQUFDUyxJQUFJLENBQUM7VUFDWkMsSUFBSSxFQUFFLE9BQU87VUFDYkMsVUFBVSxFQUFFUCxDQUFDLEdBQUcsQ0FBQztVQUNqQlEsT0FBTyxFQUFFQSxPQUFPLENBQUNQLE1BQU0sR0FBR0gsZUFBZSxHQUFHLEdBQUdVLE9BQU8sQ0FBQ08sS0FBSyxDQUFDLENBQUMsRUFBRWpCLGVBQWUsQ0FBQyxLQUFPLEdBQUdVO1FBQzVGLENBQUMsQ0FBQztRQUNGUixDQUFDLEVBQUU7TUFDTDtNQUNBO0lBQ0Y7O0lBRUE7SUFDQSxJQUFJYSxRQUFRLEdBQUcsQ0FBQyxFQUFFO01BQ2hCLE9BQU9kLENBQUMsR0FBR04sUUFBUSxDQUFDUSxNQUFNLElBQUlSLFFBQVEsQ0FBQ00sQ0FBQyxDQUFDLEtBQUtKLFFBQVEsQ0FBQ0ssQ0FBQyxDQUFDLEVBQUU7UUFDekQsSUFBSUosUUFBUSxDQUFDSyxNQUFNLElBQUlKLGlCQUFpQixFQUFFO1FBQzFDLE1BQU1XLE9BQU8sR0FBR2YsUUFBUSxDQUFDTSxDQUFDLENBQUMsSUFBSSxFQUFFO1FBQ2pDSCxRQUFRLENBQUNTLElBQUksQ0FBQztVQUNaQyxJQUFJLEVBQUUsU0FBUztVQUNmQyxVQUFVLEVBQUVSLENBQUMsR0FBRyxDQUFDO1VBQ2pCUyxPQUFPLEVBQUVBLE9BQU8sQ0FBQ1AsTUFBTSxHQUFHSCxlQUFlLEdBQUcsR0FBR1UsT0FBTyxDQUFDTyxLQUFLLENBQUMsQ0FBQyxFQUFFakIsZUFBZSxDQUFDLEtBQU8sR0FBR1U7UUFDNUYsQ0FBQyxDQUFDO1FBQ0ZULENBQUMsRUFBRTtNQUNMO01BQ0E7SUFDRjs7SUFFQTtJQUNBLElBQUksT0FBT1UsT0FBTyxLQUFLLFFBQVEsRUFBRTtNQUMvQixNQUFNRCxPQUFPLEdBQUdDLE9BQU8sQ0FBQ1IsTUFBTSxHQUFHSCxlQUFlLEdBQUcsR0FBR1csT0FBTyxDQUFDTSxLQUFLLENBQUMsQ0FBQyxFQUFFakIsZUFBZSxDQUFDLEtBQU8sR0FBR1csT0FBTztNQUN4R2IsUUFBUSxDQUFDUyxJQUFJLENBQUM7UUFBRUMsSUFBSSxFQUFFLFNBQVM7UUFBRUMsVUFBVSxFQUFFUixDQUFDLEdBQUcsQ0FBQztRQUFFUztNQUFRLENBQUMsQ0FBQztNQUM5RFQsQ0FBQyxFQUFFO0lBQ0w7SUFDQSxJQUFJLE9BQU9XLE9BQU8sS0FBSyxRQUFRLEVBQUU7TUFDL0IsTUFBTUYsT0FBTyxHQUFHRSxPQUFPLENBQUNULE1BQU0sR0FBR0gsZUFBZSxHQUFHLEdBQUdZLE9BQU8sQ0FBQ0ssS0FBSyxDQUFDLENBQUMsRUFBRWpCLGVBQWUsQ0FBQyxLQUFPLEdBQUdZLE9BQU87TUFDeEdkLFFBQVEsQ0FBQ1MsSUFBSSxDQUFDO1FBQUVDLElBQUksRUFBRSxPQUFPO1FBQUVDLFVBQVUsRUFBRVAsQ0FBQyxHQUFHLENBQUM7UUFBRVE7TUFBUSxDQUFDLENBQUM7TUFDNURSLENBQUMsRUFBRTtJQUNMOztJQUVBO0lBQ0EsSUFBSUQsQ0FBQyxJQUFJTixRQUFRLENBQUNRLE1BQU0sSUFBSUQsQ0FBQyxHQUFHTCxRQUFRLENBQUNNLE1BQU0sRUFBRTtNQUMvQ0QsQ0FBQyxFQUFFO0lBQ0wsQ0FBQyxNQUFNLElBQUlBLENBQUMsSUFBSUwsUUFBUSxDQUFDTSxNQUFNLElBQUlGLENBQUMsR0FBR04sUUFBUSxDQUFDUSxNQUFNLEVBQUU7TUFDdERGLENBQUMsRUFBRTtJQUNMO0VBQ0Y7RUFFQSxPQUFPSCxRQUFRO0FBQ2pCOztBQUVBO0FBQ0EsTUFBTW9CLFVBQVUsR0FBRyxTQUFTO0FBQzVCLE1BQU1DLFFBQVEsR0FBRyxVQUFVO0FBQzNCLE1BQU1DLFVBQVUsR0FBRyxVQUFVO0FBQzdCLE1BQU1DLFFBQVEsR0FBRyxTQUFTO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU0MsZUFBZUEsQ0FBQ0MsSUFBbUIsRUFBRUMsU0FBUyxHQUFHLElBQUksRUFBWTtFQUMvRSxJQUFJLENBQUNELElBQUksQ0FBQ3BCLE1BQU0sRUFBRTtJQUNoQixPQUFPLEVBQUU7RUFDWDtFQUNBLE1BQU1zQixLQUFLLEdBQUdwQixJQUFJLENBQUNDLEdBQUcsQ0FDcEIsQ0FBQyxFQUNELEdBQUdpQixJQUFJLENBQUNHLEdBQUcsQ0FBRUMsS0FBSyxJQUFLdEIsSUFBSSxDQUFDQyxHQUFHLENBQUMsQ0FBQyxFQUFFcUIsS0FBSyxDQUFDbEIsVUFBVSxDQUFDLENBQUNtQixRQUFRLENBQUMsQ0FBQyxDQUFDekIsTUFBTSxDQUN4RSxDQUFDO0VBRUQsT0FBT29CLElBQUksQ0FBQ0csR0FBRyxDQUFFQyxLQUFLLElBQUs7SUFDekIsTUFBTWxCLFVBQVUsR0FBR0osSUFBSSxDQUFDQyxHQUFHLENBQUMsQ0FBQyxFQUFFcUIsS0FBSyxDQUFDbEIsVUFBVSxDQUFDO0lBQ2hELE1BQU1vQixJQUFJLEdBQUdGLEtBQUssQ0FBQ2pCLE9BQU8sQ0FBQ1AsTUFBTSxHQUFHLENBQUMsR0FBR3dCLEtBQUssQ0FBQ2pCLE9BQU8sR0FBRyxjQUFjO0lBQ3RFLE1BQU1vQixZQUFZLEdBQUdyQixVQUFVLENBQUNtQixRQUFRLENBQUMsQ0FBQyxDQUFDRyxRQUFRLENBQUNOLEtBQUssRUFBRSxHQUFHLENBQUM7SUFFL0QsSUFBSUUsS0FBSyxDQUFDbkIsSUFBSSxLQUFLLE9BQU8sRUFBRTtNQUMxQixNQUFNd0IsTUFBTSxHQUFHLEdBQUc7TUFDbEIsSUFBSVIsU0FBUyxFQUFFO1FBQ2IsT0FBTyxHQUFHSixVQUFVLEdBQUdZLE1BQU0sS0FBS0YsWUFBWSxNQUFNRCxJQUFJLEdBQUdYLFVBQVUsRUFBRTtNQUN6RTtNQUNBLE9BQU8sR0FBR2MsTUFBTSxLQUFLRixZQUFZLE1BQU1ELElBQUksRUFBRTtJQUMvQyxDQUFDLE1BQU0sSUFBSUYsS0FBSyxDQUFDbkIsSUFBSSxLQUFLLFNBQVMsRUFBRTtNQUNuQyxNQUFNd0IsTUFBTSxHQUFHLEdBQUc7TUFDbEIsSUFBSVIsU0FBUyxFQUFFO1FBQ2IsT0FBTyxHQUFHTCxRQUFRLEdBQUdhLE1BQU0sS0FBS0YsWUFBWSxNQUFNRCxJQUFJLEdBQUdYLFVBQVUsRUFBRTtNQUN2RTtNQUNBLE9BQU8sR0FBR2MsTUFBTSxLQUFLRixZQUFZLE1BQU1ELElBQUksRUFBRTtJQUMvQyxDQUFDLE1BQU07TUFDTDtNQUNBLElBQUlMLFNBQVMsRUFBRTtRQUNiLE9BQU8sR0FBR0gsUUFBUSxNQUFNUyxZQUFZLE1BQU1ELElBQUksR0FBR1gsVUFBVSxFQUFFO01BQy9EO01BQ0EsT0FBTyxNQUFNWSxZQUFZLE1BQU1ELElBQUksRUFBRTtJQUN2QztFQUNGLENBQUMsQ0FBQztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTSSxxQkFBcUJBLENBQ25DVixJQUFtQixFQUNuQkMsU0FBUyxHQUFHLElBQUksRUFDaEJVLFlBQXFCLEVBQ1g7RUFDVixJQUFJLENBQUNYLElBQUksQ0FBQ3BCLE1BQU0sRUFBRTtJQUNoQixPQUFPLEVBQUU7RUFDWDs7RUFFQTtFQUNBLE1BQU1nQyxTQUFTLEdBQUdDLGtCQUFrQixDQUFDRixZQUFZLENBQUM7RUFFbEQsTUFBTUcsTUFBTSxHQUFHLFFBQVEsQ0FBQyxDQUFDO0VBQ3pCLE1BQU1aLEtBQUssR0FBR3BCLElBQUksQ0FBQ0MsR0FBRyxDQUNwQixDQUFDLEVBQ0QsR0FBR2lCLElBQUksQ0FBQ0csR0FBRyxDQUFFQyxLQUFLLElBQUt0QixJQUFJLENBQUNDLEdBQUcsQ0FBQyxDQUFDLEVBQUVxQixLQUFLLENBQUNsQixVQUFVLENBQUMsQ0FBQ21CLFFBQVEsQ0FBQyxDQUFDLENBQUN6QixNQUFNLENBQ3hFLENBQUM7RUFFRCxNQUFNbUMsTUFBZ0IsR0FBRyxFQUFFO0VBRTNCLEtBQUssTUFBTVgsS0FBSyxJQUFJSixJQUFJLEVBQUU7SUFDeEIsTUFBTWQsVUFBVSxHQUFHSixJQUFJLENBQUNDLEdBQUcsQ0FBQyxDQUFDLEVBQUVxQixLQUFLLENBQUNsQixVQUFVLENBQUM7SUFDaEQsTUFBTXFCLFlBQVksR0FBR3JCLFVBQVUsQ0FBQ21CLFFBQVEsQ0FBQyxDQUFDLENBQUNHLFFBQVEsQ0FBQ04sS0FBSyxFQUFFLEdBQUcsQ0FBQztJQUMvRCxNQUFNYyxlQUFlLEdBQUcsR0FBRyxDQUFDQyxNQUFNLENBQUNmLEtBQUssQ0FBQyxDQUFDLENBQUM7O0lBRTNDLElBQUlFLEtBQUssQ0FBQ25CLElBQUksS0FBSyxPQUFPLEVBQUU7TUFDMUIsTUFBTXdCLE1BQU0sR0FBRyxJQUFJRixZQUFZLElBQUk7TUFDbkMsTUFBTVcsa0JBQWtCLEdBQUcsR0FBR0YsZUFBZSxPQUFPLENBQUMsQ0FBQztNQUN0RCxNQUFNVixJQUFJLEdBQUdGLEtBQUssQ0FBQ2pCLE9BQU87O01BRTFCO01BQ0EsTUFBTWdDLFlBQVksR0FBR0MsWUFBWSxDQUFDZCxJQUFJLEVBQUVNLFNBQVMsQ0FBQztNQUVsRCxLQUFLLElBQUlsQyxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUd5QyxZQUFZLENBQUN2QyxNQUFNLEVBQUVGLENBQUMsRUFBRSxFQUFFO1FBQzVDLE1BQU0yQyxXQUFXLEdBQUdGLFlBQVksQ0FBQ3pDLENBQUMsQ0FBQztRQUNuQyxNQUFNNEMsV0FBVyxHQUFHNUMsQ0FBQyxLQUFLLENBQUM7UUFDM0IsTUFBTTZDLFVBQVUsR0FBR0QsV0FBVyxHQUFHYixNQUFNLEdBQUdTLGtCQUFrQjtRQUU1RCxJQUFJakIsU0FBUyxFQUFFO1VBQ2JjLE1BQU0sQ0FBQy9CLElBQUksQ0FBQyxHQUFHYSxVQUFVLEdBQUdpQixNQUFNLEdBQUdTLFVBQVUsTUFBTUYsV0FBVyxHQUFHMUIsVUFBVSxFQUFFLENBQUM7UUFDbEYsQ0FBQyxNQUFNO1VBQ0xvQixNQUFNLENBQUMvQixJQUFJLENBQUMsR0FBRzhCLE1BQU0sR0FBR1MsVUFBVSxNQUFNRixXQUFXLEVBQUUsQ0FBQztRQUN4RDtNQUNGO0lBQ0YsQ0FBQyxNQUFNLElBQUlqQixLQUFLLENBQUNuQixJQUFJLEtBQUssU0FBUyxFQUFFO01BQ25DLE1BQU13QixNQUFNLEdBQUcsSUFBSUYsWUFBWSxJQUFJO01BQ25DLE1BQU1XLGtCQUFrQixHQUFHLEdBQUdGLGVBQWUsT0FBTyxDQUFDLENBQUM7TUFDdEQsTUFBTVYsSUFBSSxHQUFHRixLQUFLLENBQUNqQixPQUFPOztNQUUxQjtNQUNBLE1BQU1nQyxZQUFZLEdBQUdDLFlBQVksQ0FBQ2QsSUFBSSxFQUFFTSxTQUFTLENBQUM7TUFFbEQsS0FBSyxJQUFJbEMsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHeUMsWUFBWSxDQUFDdkMsTUFBTSxFQUFFRixDQUFDLEVBQUUsRUFBRTtRQUM1QyxNQUFNMkMsV0FBVyxHQUFHRixZQUFZLENBQUN6QyxDQUFDLENBQUM7UUFDbkMsTUFBTTRDLFdBQVcsR0FBRzVDLENBQUMsS0FBSyxDQUFDO1FBQzNCLE1BQU02QyxVQUFVLEdBQUdELFdBQVcsR0FBR2IsTUFBTSxHQUFHUyxrQkFBa0I7UUFFNUQsSUFBSWpCLFNBQVMsRUFBRTtVQUNiYyxNQUFNLENBQUMvQixJQUFJLENBQUMsR0FBR1ksUUFBUSxHQUFHa0IsTUFBTSxHQUFHUyxVQUFVLE1BQU1GLFdBQVcsR0FBRzFCLFVBQVUsRUFBRSxDQUFDO1FBQ2hGLENBQUMsTUFBTTtVQUNMb0IsTUFBTSxDQUFDL0IsSUFBSSxDQUFDLEdBQUc4QixNQUFNLEdBQUdTLFVBQVUsTUFBTUYsV0FBVyxFQUFFLENBQUM7UUFDeEQ7TUFDRjtJQUNGLENBQUMsTUFBTTtNQUNMO01BQ0EsTUFBTVosTUFBTSxHQUFHLElBQUlGLFlBQVksSUFBSTtNQUNuQyxNQUFNRCxJQUFJLEdBQUdGLEtBQUssQ0FBQ2pCLE9BQU87TUFDMUIsSUFBSWMsU0FBUyxFQUFFO1FBQ2JjLE1BQU0sQ0FBQy9CLElBQUksQ0FBQyxHQUFHYyxRQUFRLEdBQUdnQixNQUFNLEdBQUdMLE1BQU0sS0FBS0gsSUFBSSxHQUFHWCxVQUFVLEVBQUUsQ0FBQztNQUNwRSxDQUFDLE1BQU07UUFDTG9CLE1BQU0sQ0FBQy9CLElBQUksQ0FBQyxHQUFHOEIsTUFBTSxHQUFHTCxNQUFNLEtBQUtILElBQUksRUFBRSxDQUFDO01BQzVDO0lBQ0Y7RUFDRjtFQUVBLE9BQU9TLE1BQU07QUFDZjtBQUVBLFNBQVNGLGtCQUFrQkEsQ0FBQ0YsWUFBcUIsRUFBVTtFQUN6RDtFQUNBLElBQUksT0FBT0EsWUFBWSxLQUFLLFFBQVEsSUFBSWEsTUFBTSxDQUFDQyxRQUFRLENBQUNkLFlBQVksQ0FBQyxJQUFJQSxZQUFZLEdBQUcsQ0FBQyxFQUFFO0lBQ3pGLE9BQU83QixJQUFJLENBQUNDLEdBQUcsQ0FBQyxFQUFFLEVBQUVELElBQUksQ0FBQzRDLEtBQUssQ0FBQ2YsWUFBWSxDQUFDLENBQUM7RUFDL0M7RUFFQSxNQUFNZ0IsYUFBYSxHQUFHLE9BQU9DLE9BQU8sQ0FBQ0MsTUFBTSxFQUFFQyxPQUFPLEtBQUssUUFBUSxJQUFJRixPQUFPLENBQUNDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHLENBQUMsR0FDM0ZGLE9BQU8sQ0FBQ0MsTUFBTSxDQUFDQyxPQUFPLEdBQ3RCLElBQUk7O0VBRVI7RUFDQTtFQUNBO0VBQ0EsTUFBTUMsU0FBUyxHQUFHSixhQUFhLEdBQUc3QyxJQUFJLENBQUNDLEdBQUcsQ0FBQzRDLGFBQWEsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRzs7RUFFeEU7RUFDQSxPQUFPN0MsSUFBSSxDQUFDQyxHQUFHLENBQUMsR0FBRyxFQUFFRCxJQUFJLENBQUNrRCxHQUFHLENBQUNELFNBQVMsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNYLFlBQVlBLENBQUNhLElBQVksRUFBRUMsUUFBZ0IsRUFBWTtFQUM5RCxNQUFNaEMsS0FBSyxHQUFHcEIsSUFBSSxDQUFDQyxHQUFHLENBQUMsQ0FBQyxFQUFFRCxJQUFJLENBQUM0QyxLQUFLLENBQUNRLFFBQVEsQ0FBQyxDQUFDO0VBRS9DLElBQUlELElBQUksQ0FBQ3JELE1BQU0sSUFBSXNCLEtBQUssRUFBRTtJQUN4QixPQUFPLENBQUMrQixJQUFJLENBQUM7RUFDZjtFQUVBLE1BQU1sQixNQUFnQixHQUFHLEVBQUU7RUFDM0IsSUFBSWxDLFNBQVMsR0FBR29ELElBQUk7RUFFcEIsT0FBT3BELFNBQVMsQ0FBQ0QsTUFBTSxHQUFHc0IsS0FBSyxFQUFFO0lBQy9CO0lBQ0EsSUFBSWlDLFVBQVUsR0FBR3RELFNBQVMsQ0FBQ3VELFdBQVcsQ0FBQyxHQUFHLEVBQUVsQyxLQUFLLENBQUM7SUFDbEQsSUFBSWlDLFVBQVUsSUFBSSxDQUFDLEVBQUU7TUFDbkI7TUFDQUEsVUFBVSxHQUFHakMsS0FBSztJQUNwQjtJQUVBYSxNQUFNLENBQUMvQixJQUFJLENBQUNILFNBQVMsQ0FBQ3dELFNBQVMsQ0FBQyxDQUFDLEVBQUVGLFVBQVUsQ0FBQyxDQUFDO0lBQy9DdEQsU0FBUyxHQUFHQSxTQUFTLENBQUN3RCxTQUFTLENBQUNGLFVBQVUsQ0FBQyxDQUFDRyxTQUFTLENBQUMsQ0FBQztFQUN6RDtFQUVBLElBQUl6RCxTQUFTLENBQUNELE1BQU0sR0FBRyxDQUFDLEVBQUU7SUFDeEJtQyxNQUFNLENBQUMvQixJQUFJLENBQUNILFNBQVMsQ0FBQztFQUN4QjtFQUVBLE9BQU9rQyxNQUFNLENBQUNuQyxNQUFNLEdBQUcsQ0FBQyxHQUFHbUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO0FBQzFDO0FBRUEsU0FBUzlDLGVBQWVBLENBQUNKLE1BQWMsRUFBRUUsS0FBYSxFQUF3QjtFQUM1RSxJQUFJd0UsT0FBc0IsR0FBRyxJQUFJO0VBQ2pDLElBQUk7SUFDRkEsT0FBTyxHQUFHLElBQUFDLG1CQUFXLEVBQUMsSUFBQUMsY0FBSSxFQUFDLElBQUFDLGNBQU0sRUFBQyxDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDbEQsTUFBTUMsWUFBWSxHQUFHLElBQUFGLGNBQUksRUFBQ0YsT0FBTyxFQUFFLFlBQVksQ0FBQztJQUNoRCxNQUFNSyxXQUFXLEdBQUcsSUFBQUgsY0FBSSxFQUFDRixPQUFPLEVBQUUsV0FBVyxDQUFDO0lBQzlDLElBQUFNLHFCQUFhLEVBQUNGLFlBQVksRUFBRTlFLE1BQU0sRUFBRSxNQUFNLENBQUM7SUFDM0MsSUFBQWdGLHFCQUFhLEVBQUNELFdBQVcsRUFBRTdFLEtBQUssRUFBRSxNQUFNLENBQUM7SUFFekMsTUFBTWdELE1BQU0sR0FBRyxJQUFBK0IsNEJBQVMsRUFDdEIsS0FBSyxFQUNMLENBQUMsWUFBWSxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsYUFBYSxFQUFFLGVBQWUsRUFBRSxJQUFJLEVBQUVILFlBQVksRUFBRUMsV0FBVyxDQUFDLEVBQ3JHO01BQUVHLFFBQVEsRUFBRTtJQUFPLENBQ3JCLENBQUM7SUFFRCxJQUFJaEMsTUFBTSxDQUFDaUMsS0FBSyxFQUFFO01BQ2hCLE1BQU1DLElBQUksR0FBSWxDLE1BQU0sQ0FBQ2lDLEtBQUssQ0FBMkJDLElBQUk7TUFDekQsSUFBSUEsSUFBSSxLQUFLLFFBQVEsRUFBRTtRQUNyQixPQUFPLElBQUk7TUFDYjtNQUNBLE9BQU8sSUFBSTtJQUNiO0lBRUEsSUFBSSxPQUFPbEMsTUFBTSxDQUFDbUMsTUFBTSxLQUFLLFFBQVEsSUFBSW5DLE1BQU0sQ0FBQ21DLE1BQU0sR0FBRyxDQUFDLEVBQUU7TUFDMUQsT0FBTyxJQUFJO0lBQ2I7SUFFQSxPQUFPQyxnQkFBZ0IsQ0FBQ3BDLE1BQU0sQ0FBQ2MsTUFBTSxDQUFDO0VBQ3hDLENBQUMsQ0FBQyxNQUFNO0lBQ04sT0FBTyxJQUFJO0VBQ2IsQ0FBQyxTQUFTO0lBQ1IsSUFBSVUsT0FBTyxFQUFFO01BQ1gsSUFBQWEsY0FBTSxFQUFDYixPQUFPLEVBQUU7UUFBRWMsU0FBUyxFQUFFLElBQUk7UUFBRUMsS0FBSyxFQUFFO01BQUssQ0FBQyxDQUFDO0lBQ25EO0VBQ0Y7QUFDRjtBQUVBLFNBQVNILGdCQUFnQkEsQ0FBQ0ksTUFBYyxFQUFpQjtFQUN2RCxJQUFJLENBQUNBLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDLENBQUMsRUFBRTtJQUNsQixPQUFPLEVBQUU7RUFDWDtFQUVBLE1BQU1DLEtBQUssR0FBR0YsTUFBTSxDQUFDRyxLQUFLLENBQUMsSUFBSSxDQUFDO0VBQ2hDLE1BQU1uRixRQUF1QixHQUFHLEVBQUU7RUFDbEMsSUFBSWEsT0FBTyxHQUFHLENBQUM7RUFDZixJQUFJQyxPQUFPLEdBQUcsQ0FBQztFQUVmLEtBQUssTUFBTXNFLE9BQU8sSUFBSUYsS0FBSyxFQUFFO0lBQzNCLE1BQU14QixJQUFJLEdBQUcwQixPQUFPLENBQUNDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO0lBQ3ZDLElBQUksQ0FBQzNCLElBQUksRUFBRTtNQUNUO0lBQ0Y7SUFDQSxJQUFJQSxJQUFJLENBQUM0QixVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUU7TUFDekIsTUFBTUMsS0FBSyxHQUFHLHdDQUF3QyxDQUFDQyxJQUFJLENBQUM5QixJQUFJLENBQUM7TUFDakUsSUFBSTZCLEtBQUssR0FBRyxDQUFDLENBQUMsSUFBSUEsS0FBSyxHQUFHLENBQUMsQ0FBQyxFQUFFO1FBQzVCMUUsT0FBTyxHQUFHNEUsUUFBUSxDQUFDRixLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQ2hDekUsT0FBTyxHQUFHMkUsUUFBUSxDQUFDRixLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO01BQ2xDO01BQ0E7SUFDRjtJQUVBLElBQUk3QixJQUFJLENBQUM0QixVQUFVLENBQUMsS0FBSyxDQUFDLElBQUk1QixJQUFJLENBQUM0QixVQUFVLENBQUMsS0FBSyxDQUFDLElBQUk1QixJQUFJLENBQUM0QixVQUFVLENBQUMsT0FBTyxDQUFDLElBQUk1QixJQUFJLENBQUM0QixVQUFVLENBQUMsUUFBUSxDQUFDLEVBQUU7TUFDN0c7SUFDRjtJQUVBLElBQUk1QixJQUFJLENBQUM0QixVQUFVLENBQUMsU0FBUyxDQUFDLEVBQUU7TUFDOUI7SUFDRjtJQUVBLElBQUk1QixJQUFJLENBQUM0QixVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUU7TUFDekI7SUFDRjtJQUVBLElBQUk1QixJQUFJLENBQUM0QixVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUU7TUFDeEJ0RixRQUFRLENBQUNTLElBQUksQ0FBQztRQUFFQyxJQUFJLEVBQUUsT0FBTztRQUFFQyxVQUFVLEVBQUVHLE9BQU87UUFBRUYsT0FBTyxFQUFFOEMsSUFBSSxDQUFDdkMsS0FBSyxDQUFDLENBQUM7TUFBRSxDQUFDLENBQUM7TUFDN0VMLE9BQU8sSUFBSSxDQUFDO01BQ1o7SUFDRjtJQUVBLElBQUk0QyxJQUFJLENBQUM0QixVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUU7TUFDeEJ0RixRQUFRLENBQUNTLElBQUksQ0FBQztRQUFFQyxJQUFJLEVBQUUsU0FBUztRQUFFQyxVQUFVLEVBQUVFLE9BQU87UUFBRUQsT0FBTyxFQUFFOEMsSUFBSSxDQUFDdkMsS0FBSyxDQUFDLENBQUM7TUFBRSxDQUFDLENBQUM7TUFDL0VOLE9BQU8sSUFBSSxDQUFDO01BQ1o7SUFDRjtJQUVBLElBQUk2QyxJQUFJLENBQUM0QixVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUU7TUFDeEJ6RSxPQUFPLElBQUksQ0FBQztNQUNaQyxPQUFPLElBQUksQ0FBQztNQUNaO0lBQ0Y7RUFDRjtFQUVBLE9BQU9kLFFBQVE7QUFDakI7QUFFQSxTQUFTTCxjQUFjQSxDQUFDTCxNQUFjLEVBQUVFLEtBQWEsRUFBaUI7RUFDcEUsTUFBTWtHLENBQUMsR0FBRzVGLFVBQVUsQ0FBQ1IsTUFBTSxDQUFDO0VBQzVCLE1BQU1xRyxDQUFDLEdBQUc3RixVQUFVLENBQUNOLEtBQUssQ0FBQztFQUMzQixNQUFNZ0IsR0FBRyxHQUFHRCxJQUFJLENBQUNDLEdBQUcsQ0FBQ2tGLENBQUMsQ0FBQ3JGLE1BQU0sRUFBRXNGLENBQUMsQ0FBQ3RGLE1BQU0sQ0FBQztFQUN4QyxNQUFNTCxRQUF1QixHQUFHLEVBQUU7O0VBRWxDO0VBQ0EsTUFBTUMsaUJBQWlCLEdBQUcsR0FBRztFQUM3QixNQUFNQyxlQUFlLEdBQUcsSUFBSTtFQUU1QixLQUFLLElBQUkwRixLQUFLLEdBQUcsQ0FBQyxFQUFFQSxLQUFLLEdBQUdwRixHQUFHLEVBQUVvRixLQUFLLElBQUksQ0FBQyxFQUFFO0lBQzNDO0lBQ0EsSUFBSTVGLFFBQVEsQ0FBQ0ssTUFBTSxJQUFJSixpQkFBaUIsRUFBRTtNQUN4Q0QsUUFBUSxDQUFDUyxJQUFJLENBQUM7UUFDWkMsSUFBSSxFQUFFLE9BQU87UUFDYkMsVUFBVSxFQUFFLENBQUM7UUFDYkMsT0FBTyxFQUFFLHFCQUFxQkosR0FBRyxHQUFHb0YsS0FBSztNQUMzQyxDQUFDLENBQUM7TUFDRjtJQUNGO0lBRUEsTUFBTUMsSUFBSSxHQUFHSCxDQUFDLENBQUNFLEtBQUssQ0FBQztJQUNyQixNQUFNRSxLQUFLLEdBQUdILENBQUMsQ0FBQ0MsS0FBSyxDQUFDO0lBRXRCLElBQUlDLElBQUksS0FBS0MsS0FBSyxFQUFFO01BQ2xCO0lBQ0Y7SUFFQSxJQUFJLE9BQU9ELElBQUksS0FBSyxRQUFRLEVBQUU7TUFDNUI7TUFDQSxNQUFNakYsT0FBTyxHQUFHaUYsSUFBSSxDQUFDeEYsTUFBTSxHQUFHSCxlQUFlLEdBQ3pDLEdBQUcyRixJQUFJLENBQUMxRSxLQUFLLENBQUMsQ0FBQyxFQUFFakIsZUFBZSxDQUFDLEtBQU8sR0FDeEMyRixJQUFJO01BQ1I3RixRQUFRLENBQUNTLElBQUksQ0FBQztRQUFFQyxJQUFJLEVBQUUsU0FBUztRQUFFQyxVQUFVLEVBQUVpRixLQUFLLEdBQUcsQ0FBQztRQUFFaEY7TUFBUSxDQUFDLENBQUM7SUFDcEU7SUFFQSxJQUFJLE9BQU9rRixLQUFLLEtBQUssUUFBUSxFQUFFO01BQzdCO01BQ0EsTUFBTWxGLE9BQU8sR0FBR2tGLEtBQUssQ0FBQ3pGLE1BQU0sR0FBR0gsZUFBZSxHQUMxQyxHQUFHNEYsS0FBSyxDQUFDM0UsS0FBSyxDQUFDLENBQUMsRUFBRWpCLGVBQWUsQ0FBQyxLQUFPLEdBQ3pDNEYsS0FBSztNQUNUOUYsUUFBUSxDQUFDUyxJQUFJLENBQUM7UUFBRUMsSUFBSSxFQUFFLE9BQU87UUFBRUMsVUFBVSxFQUFFaUYsS0FBSyxHQUFHLENBQUM7UUFBRWhGO01BQVEsQ0FBQyxDQUFDO0lBQ2xFO0VBQ0Y7RUFFQSxPQUFPWixRQUFRO0FBQ2pCO0FBRUEsU0FBU1QsaUJBQWlCQSxDQUFDd0csS0FBYSxFQUFVO0VBQ2hELE9BQU9BLEtBQUssQ0FBQ1YsT0FBTyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUM7QUFDckM7QUFFQSxTQUFTdkYsVUFBVUEsQ0FBQ2lHLEtBQWEsRUFBWTtFQUMzQyxJQUFJLENBQUNBLEtBQUssRUFBRTtJQUNWLE9BQU8sRUFBRTtFQUNYO0VBQ0EsTUFBTUMsVUFBVSxHQUFHekcsaUJBQWlCLENBQUN3RyxLQUFLLENBQUM7RUFDM0MsT0FBT0MsVUFBVSxDQUFDYixLQUFLLENBQUMsSUFBSSxDQUFDO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU2Msb0JBQW9CQSxDQUNsQzdHLFFBQWdCLEVBQ2hCQyxJQUFZLEVBQ1o2RyxZQUFZLEdBQUcsQ0FBQyxFQUNDO0VBQ2pCLE1BQU01RyxNQUFNLEdBQUdDLGlCQUFpQixDQUFDSCxRQUFRLENBQUM7RUFDMUMsTUFBTUksS0FBSyxHQUFHRCxpQkFBaUIsQ0FBQ0YsSUFBSSxDQUFDO0VBRXJDLElBQUlDLE1BQU0sS0FBS0UsS0FBSyxFQUFFO0lBQ3BCLE9BQU87TUFBRVEsUUFBUSxFQUFFLEVBQUU7TUFBRW1HLFNBQVMsRUFBRSxDQUFDO01BQUVDLFFBQVEsRUFBRTtJQUFFLENBQUM7RUFDcEQ7RUFFQSxNQUFNdkcsUUFBUSxHQUFHQyxVQUFVLENBQUNSLE1BQU0sQ0FBQztFQUNuQyxNQUFNUyxRQUFRLEdBQUdELFVBQVUsQ0FBQ04sS0FBSyxDQUFDOztFQUVsQztFQUNBLE1BQU02RyxPQU1KLEdBQUcsRUFBRTs7RUFFUDtFQUNBLElBQUlsRyxDQUFDLEdBQUcsQ0FBQztFQUNULElBQUlDLENBQUMsR0FBRyxDQUFDO0VBRVQsT0FBT0QsQ0FBQyxHQUFHTixRQUFRLENBQUNRLE1BQU0sSUFBSUQsQ0FBQyxHQUFHTCxRQUFRLENBQUNNLE1BQU0sRUFBRTtJQUNqRCxNQUFNUSxPQUFPLEdBQUdoQixRQUFRLENBQUNNLENBQUMsQ0FBQztJQUMzQixNQUFNVyxPQUFPLEdBQUdmLFFBQVEsQ0FBQ0ssQ0FBQyxDQUFDO0lBRTNCLElBQUlTLE9BQU8sS0FBS0MsT0FBTyxFQUFFO01BQ3ZCWCxDQUFDLEVBQUU7TUFDSEMsQ0FBQyxFQUFFO01BQ0g7SUFDRjs7SUFFQTtJQUNBLE1BQU1XLFNBQVMsR0FBRyxFQUFFO0lBQ3BCLElBQUl1RixVQUFVLEdBQUcsQ0FBQyxDQUFDO0lBQ25CLElBQUlDLFVBQVUsR0FBRyxDQUFDLENBQUM7SUFFbkIsS0FBSyxJQUFJckYsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxJQUFJSCxTQUFTLElBQUlYLENBQUMsR0FBR2MsQ0FBQyxHQUFHbkIsUUFBUSxDQUFDTSxNQUFNLEVBQUVhLENBQUMsRUFBRSxFQUFFO01BQzlELElBQUlMLE9BQU8sS0FBS2QsUUFBUSxDQUFDSyxDQUFDLEdBQUdjLENBQUMsQ0FBQyxFQUFFO1FBQy9Cb0YsVUFBVSxHQUFHbEcsQ0FBQyxHQUFHYyxDQUFDO1FBQ2xCO01BQ0Y7SUFDRjtJQUVBLEtBQUssSUFBSUEsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxJQUFJSCxTQUFTLElBQUlaLENBQUMsR0FBR2UsQ0FBQyxHQUFHckIsUUFBUSxDQUFDUSxNQUFNLEVBQUVhLENBQUMsRUFBRSxFQUFFO01BQzlELElBQUlKLE9BQU8sS0FBS2pCLFFBQVEsQ0FBQ00sQ0FBQyxHQUFHZSxDQUFDLENBQUMsRUFBRTtRQUMvQnFGLFVBQVUsR0FBR3BHLENBQUMsR0FBR2UsQ0FBQztRQUNsQjtNQUNGO0lBQ0Y7O0lBRUE7SUFDQSxJQUFJcUYsVUFBVSxHQUFHLENBQUMsS0FBS0QsVUFBVSxHQUFHLENBQUMsSUFBSUEsVUFBVSxHQUFHQyxVQUFVLENBQUMsRUFBRTtNQUNqRSxPQUFPbkcsQ0FBQyxHQUFHTCxRQUFRLENBQUNNLE1BQU0sSUFBSU4sUUFBUSxDQUFDSyxDQUFDLENBQUMsS0FBS1AsUUFBUSxDQUFDTSxDQUFDLENBQUMsRUFBRTtRQUN6RGtHLE9BQU8sQ0FBQzVGLElBQUksQ0FBQztVQUNYQyxJQUFJLEVBQUUsT0FBTztVQUNiQyxVQUFVLEVBQUVQLENBQUMsR0FBRyxDQUFDO1VBQ2pCUSxPQUFPLEVBQUViLFFBQVEsQ0FBQ0ssQ0FBQyxDQUFDLElBQUksRUFBRTtVQUMxQm9HLFlBQVksRUFBRXBHO1FBQ2hCLENBQUMsQ0FBQztRQUNGQSxDQUFDLEVBQUU7TUFDTDtNQUNBO0lBQ0Y7O0lBRUE7SUFDQSxJQUFJa0csVUFBVSxHQUFHLENBQUMsRUFBRTtNQUNsQixPQUFPbkcsQ0FBQyxHQUFHTixRQUFRLENBQUNRLE1BQU0sSUFBSVIsUUFBUSxDQUFDTSxDQUFDLENBQUMsS0FBS0osUUFBUSxDQUFDSyxDQUFDLENBQUMsRUFBRTtRQUN6RGlHLE9BQU8sQ0FBQzVGLElBQUksQ0FBQztVQUNYQyxJQUFJLEVBQUUsU0FBUztVQUNmQyxVQUFVLEVBQUVSLENBQUMsR0FBRyxDQUFDO1VBQ2pCUyxPQUFPLEVBQUVmLFFBQVEsQ0FBQ00sQ0FBQyxDQUFDLElBQUksRUFBRTtVQUMxQnNHLFlBQVksRUFBRXRHO1FBQ2hCLENBQUMsQ0FBQztRQUNGQSxDQUFDLEVBQUU7TUFDTDtNQUNBO0lBQ0Y7O0lBRUE7SUFDQSxJQUFJLE9BQU9VLE9BQU8sS0FBSyxRQUFRLEVBQUU7TUFDL0J3RixPQUFPLENBQUM1RixJQUFJLENBQUM7UUFDWEMsSUFBSSxFQUFFLFNBQVM7UUFDZkMsVUFBVSxFQUFFUixDQUFDLEdBQUcsQ0FBQztRQUNqQlMsT0FBTyxFQUFFQyxPQUFPO1FBQ2hCNEYsWUFBWSxFQUFFdEc7TUFDaEIsQ0FBQyxDQUFDO01BQ0ZBLENBQUMsRUFBRTtJQUNMO0lBQ0EsSUFBSSxPQUFPVyxPQUFPLEtBQUssUUFBUSxFQUFFO01BQy9CdUYsT0FBTyxDQUFDNUYsSUFBSSxDQUFDO1FBQ1hDLElBQUksRUFBRSxPQUFPO1FBQ2JDLFVBQVUsRUFBRVAsQ0FBQyxHQUFHLENBQUM7UUFDakJRLE9BQU8sRUFBRUUsT0FBTztRQUNoQjBGLFlBQVksRUFBRXBHO01BQ2hCLENBQUMsQ0FBQztNQUNGQSxDQUFDLEVBQUU7SUFDTDtJQUVBLElBQUlELENBQUMsSUFBSU4sUUFBUSxDQUFDUSxNQUFNLElBQUlELENBQUMsR0FBR0wsUUFBUSxDQUFDTSxNQUFNLEVBQUU7TUFDL0NELENBQUMsRUFBRTtJQUNMLENBQUMsTUFBTSxJQUFJQSxDQUFDLElBQUlMLFFBQVEsQ0FBQ00sTUFBTSxJQUFJRixDQUFDLEdBQUdOLFFBQVEsQ0FBQ1EsTUFBTSxFQUFFO01BQ3RERixDQUFDLEVBQUU7SUFDTDtFQUNGOztFQUVBO0VBQ0EsTUFBTWdHLFNBQVMsR0FBR0UsT0FBTyxDQUFDSyxNQUFNLENBQUVDLENBQUMsSUFBS0EsQ0FBQyxDQUFDakcsSUFBSSxLQUFLLE9BQU8sQ0FBQyxDQUFDTCxNQUFNO0VBQ2xFLE1BQU0rRixRQUFRLEdBQUdDLE9BQU8sQ0FBQ0ssTUFBTSxDQUFFQyxDQUFDLElBQUtBLENBQUMsQ0FBQ2pHLElBQUksS0FBSyxTQUFTLENBQUMsQ0FBQ0wsTUFBTTs7RUFFbkU7RUFDQTtFQUNBLE1BQU1MLFFBQXVCLEdBQUcsRUFBRTtFQUNsQyxNQUFNNEcsYUFBYSxHQUFHLElBQUlDLEdBQUcsQ0FBUyxDQUFDO0VBQ3ZDLE1BQU1DLGNBQWMsR0FBRyxJQUFJRCxHQUFHLENBQVMsQ0FBQztFQUV4QyxLQUFLLE1BQU1FLE1BQU0sSUFBSVYsT0FBTyxFQUFFO0lBQzVCLElBQUlVLE1BQU0sQ0FBQ3JHLElBQUksS0FBSyxPQUFPLElBQUlxRyxNQUFNLENBQUNQLFlBQVksS0FBS1EsU0FBUyxFQUFFO01BQ2hFSixhQUFhLENBQUNLLEdBQUcsQ0FBQ0YsTUFBTSxDQUFDUCxZQUFZLENBQUM7SUFDeEM7SUFDQSxJQUFJTyxNQUFNLENBQUNyRyxJQUFJLEtBQUssU0FBUyxJQUFJcUcsTUFBTSxDQUFDTixZQUFZLEtBQUtPLFNBQVMsRUFBRTtNQUNsRUYsY0FBYyxDQUFDRyxHQUFHLENBQUNGLE1BQU0sQ0FBQ04sWUFBWSxDQUFDO0lBQ3pDO0VBQ0Y7O0VBRUE7RUFDQSxNQUFNUyxXQUFXLEdBQUcsSUFBSUwsR0FBRyxDQUFTLENBQUM7RUFDckMsS0FBSyxNQUFNRSxNQUFNLElBQUlWLE9BQU8sRUFBRTtJQUM1QixJQUFJVSxNQUFNLENBQUNyRyxJQUFJLEtBQUssT0FBTyxJQUFJcUcsTUFBTSxDQUFDUCxZQUFZLEtBQUtRLFNBQVMsRUFBRTtNQUNoRSxNQUFNRyxHQUFHLEdBQUdKLE1BQU0sQ0FBQ1AsWUFBWTtNQUMvQixLQUFLLElBQUl0RixDQUFDLEdBQUdYLElBQUksQ0FBQ0MsR0FBRyxDQUFDLENBQUMsRUFBRTJHLEdBQUcsR0FBR2pCLFlBQVksQ0FBQyxFQUFFaEYsQ0FBQyxJQUFJWCxJQUFJLENBQUNrRCxHQUFHLENBQUMxRCxRQUFRLENBQUNNLE1BQU0sR0FBRyxDQUFDLEVBQUU4RyxHQUFHLEdBQUdqQixZQUFZLENBQUMsRUFBRWhGLENBQUMsRUFBRSxFQUFFO1FBQ3pHZ0csV0FBVyxDQUFDRCxHQUFHLENBQUMvRixDQUFDLENBQUM7TUFDcEI7SUFDRjtFQUNGOztFQUVBO0VBQ0EsSUFBSWtHLGFBQWEsR0FBRyxDQUFDLENBQUM7RUFDdEIsTUFBTUMsV0FBVyxHQUFHQyxLQUFLLENBQUNDLElBQUksQ0FBQ0wsV0FBVyxDQUFDLENBQUNNLElBQUksQ0FBQyxDQUFDOUIsQ0FBQyxFQUFFQyxDQUFDLEtBQUtELENBQUMsR0FBR0MsQ0FBQyxDQUFDO0VBRWpFLEtBQUssTUFBTThCLE9BQU8sSUFBSUosV0FBVyxFQUFFO0lBQ2pDO0lBQ0EsSUFBSUQsYUFBYSxJQUFJLENBQUMsSUFBSUssT0FBTyxHQUFHTCxhQUFhLEdBQUcsQ0FBQyxFQUFFO01BQ3JEcEgsUUFBUSxDQUFDUyxJQUFJLENBQUM7UUFDWkMsSUFBSSxFQUFFLFNBQVM7UUFDZkMsVUFBVSxFQUFFLENBQUM7UUFDYkMsT0FBTyxFQUFFO01BQ1gsQ0FBQyxDQUFDO0lBQ0o7SUFFQSxJQUFJZ0csYUFBYSxDQUFDYyxHQUFHLENBQUNELE9BQU8sQ0FBQyxFQUFFO01BQzlCekgsUUFBUSxDQUFDUyxJQUFJLENBQUM7UUFDWkMsSUFBSSxFQUFFLE9BQU87UUFDYkMsVUFBVSxFQUFFOEcsT0FBTyxHQUFHLENBQUM7UUFDdkI3RyxPQUFPLEVBQUViLFFBQVEsQ0FBQzBILE9BQU8sQ0FBQyxJQUFJO01BQ2hDLENBQUMsQ0FBQztJQUNKLENBQUMsTUFBTTtNQUNMekgsUUFBUSxDQUFDUyxJQUFJLENBQUM7UUFDWkMsSUFBSSxFQUFFLFNBQVM7UUFDZkMsVUFBVSxFQUFFOEcsT0FBTyxHQUFHLENBQUM7UUFDdkI3RyxPQUFPLEVBQUViLFFBQVEsQ0FBQzBILE9BQU8sQ0FBQyxJQUFJO01BQ2hDLENBQUMsQ0FBQztJQUNKO0lBQ0FMLGFBQWEsR0FBR0ssT0FBTztFQUN6Qjs7RUFFQTtFQUNBO0VBQ0EsTUFBTUUsYUFBNEIsR0FBRyxFQUFFO0VBQ3ZDLElBQUlDLFNBQVMsR0FBRyxDQUFDO0VBRWpCLEtBQUssTUFBTUMsR0FBRyxJQUFJN0gsUUFBUSxFQUFFO0lBQzFCO0lBQ0EsT0FBTzRILFNBQVMsR0FBR3ZCLE9BQU8sQ0FBQ2hHLE1BQU0sRUFBRTtNQUNqQyxNQUFNMEcsTUFBTSxHQUFHVixPQUFPLENBQUN1QixTQUFTLENBQUM7TUFDakMsSUFBSSxDQUFDYixNQUFNLEVBQUU7TUFDYixJQUFJQSxNQUFNLENBQUNyRyxJQUFJLEtBQUssU0FBUyxFQUFFO1FBQzdCO1FBQ0EsTUFBTW9ILGFBQWEsR0FBR2YsTUFBTSxDQUFDTixZQUFZLElBQUksQ0FBQztRQUM5QztRQUNBLE1BQU1zQixXQUFXLEdBQUcxQixPQUFPLENBQUMyQixJQUFJLENBQzdCckIsQ0FBQyxJQUFLQSxDQUFDLENBQUNqRyxJQUFJLEtBQUssT0FBTyxJQUFJaUcsQ0FBQyxDQUFDSCxZQUFZLEtBQUtRLFNBQVMsSUFBSXpHLElBQUksQ0FBQzBILEdBQUcsQ0FBRXRCLENBQUMsQ0FBQ0gsWUFBWSxHQUFJc0IsYUFBYSxDQUFDLElBQUksQ0FDN0csQ0FBQztRQUNELElBQUlDLFdBQVcsSUFBSUYsR0FBRyxDQUFDbkgsSUFBSSxLQUFLLE9BQU8sSUFBSW1ILEdBQUcsQ0FBQ2xILFVBQVUsS0FBSyxDQUFDb0gsV0FBVyxDQUFDdkIsWUFBWSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUU7VUFDakdtQixhQUFhLENBQUNsSCxJQUFJLENBQUM7WUFDakJDLElBQUksRUFBRSxTQUFTO1lBQ2ZDLFVBQVUsRUFBRW9HLE1BQU0sQ0FBQ3BHLFVBQVU7WUFDN0JDLE9BQU8sRUFBRW1HLE1BQU0sQ0FBQ25HO1VBQ2xCLENBQUMsQ0FBQztVQUNGZ0gsU0FBUyxFQUFFO1VBQ1g7UUFDRjtNQUNGO01BQ0E7SUFDRjtJQUNBRCxhQUFhLENBQUNsSCxJQUFJLENBQUNvSCxHQUFHLENBQUM7RUFDekI7O0VBRUE7RUFDQSxPQUFPRCxTQUFTLEdBQUd2QixPQUFPLENBQUNoRyxNQUFNLEVBQUU7SUFDakMsTUFBTTBHLE1BQU0sR0FBR1YsT0FBTyxDQUFDdUIsU0FBUyxDQUFDO0lBQ2pDLElBQUksQ0FBQ2IsTUFBTSxFQUFFO0lBQ2IsSUFBSUEsTUFBTSxDQUFDckcsSUFBSSxLQUFLLFNBQVMsRUFBRTtNQUM3QmlILGFBQWEsQ0FBQ2xILElBQUksQ0FBQztRQUNqQkMsSUFBSSxFQUFFLFNBQVM7UUFDZkMsVUFBVSxFQUFFb0csTUFBTSxDQUFDcEcsVUFBVTtRQUM3QkMsT0FBTyxFQUFFbUcsTUFBTSxDQUFDbkc7TUFDbEIsQ0FBQyxDQUFDO0lBQ0o7SUFDQWdILFNBQVMsRUFBRTtFQUNiO0VBRUEsT0FBTztJQUFFNUgsUUFBUSxFQUFFMkgsYUFBYSxDQUFDdEgsTUFBTSxHQUFHLENBQUMsR0FBR3NILGFBQWEsR0FBR3RCLE9BQU87SUFBRUYsU0FBUztJQUFFQztFQUFTLENBQUM7QUFDOUYiLCJpZ25vcmVMaXN0IjpbXX0=