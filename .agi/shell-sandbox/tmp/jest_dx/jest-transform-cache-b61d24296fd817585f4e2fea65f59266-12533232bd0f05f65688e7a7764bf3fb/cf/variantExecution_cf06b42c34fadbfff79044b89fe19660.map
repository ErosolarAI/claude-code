{"version":3,"names":["canRunVariantsParallel","modeDefinition","context","parallelVariants","variants","includes","refinerRoot","variantWorkspaceRoots","refiner","primaryRoot","primary","Boolean","resolveWorkspaceRoot","variant","executeVariants","params","module","step","mode","emit","executeVariant","results","parallel","length","type","timestamp","Date","now","data","moduleId","id","stepId","promises","map","result","previousResult","undefined","workspaceRoot","repoPolicy","resolved","Promise","all"],"sources":["variantExecution.ts"],"sourcesContent":["import type {\n  RepoUpgradeMode,\n  RepoUpgradeModeDefinition,\n  RepoUpgradeModule,\n  RepoUpgradeStep,\n  UpgradeStepExecutionInput,\n  UpgradeStepResult,\n  UpgradeVariant,\n} from './repoUpgradeOrchestrator.js';\n\nexport interface VariantExecutionContext {\n  parallelVariants: boolean;\n  variantWorkspaceRoots?: Partial<Record<UpgradeVariant, string>>;\n  repoPolicy?: string;\n}\n\nexport type VariantExecutor = (input: UpgradeStepExecutionInput) => Promise<UpgradeStepResult>;\n\nexport interface ExecuteVariantsParams {\n  module: RepoUpgradeModule;\n  step: RepoUpgradeStep;\n  mode: RepoUpgradeMode;\n  modeDefinition: RepoUpgradeModeDefinition;\n  context: VariantExecutionContext;\n  executeVariant: VariantExecutor;\n  emit?: (event: { type: string; timestamp: number; data: Record<string, unknown> }) => void;\n}\n\n/**\n * Decide if variants can run safely in parallel.\n */\nexport function canRunVariantsParallel(\n  modeDefinition: RepoUpgradeModeDefinition,\n  context: VariantExecutionContext\n): boolean {\n  if (!context.parallelVariants) return false;\n  if (!modeDefinition.variants.includes('refiner')) return false;\n  const refinerRoot = context.variantWorkspaceRoots?.refiner;\n  const primaryRoot = context.variantWorkspaceRoots?.primary;\n  return Boolean(refinerRoot && primaryRoot && refinerRoot !== primaryRoot);\n}\n\n/**\n * Resolve the workspace root for a variant, falling back to the primary root.\n */\nexport function resolveWorkspaceRoot(\n  variant: UpgradeVariant,\n  context: VariantExecutionContext\n): string | undefined {\n  return context.variantWorkspaceRoots?.[variant] ?? context.variantWorkspaceRoots?.primary;\n}\n\n/**\n * Execute primary/refiner variants either in parallel or sequentially, preserving\n * the original behavior where refiner sees the primary result in sequential mode.\n */\nexport async function executeVariants(params: ExecuteVariantsParams): Promise<\n  Partial<Record<UpgradeVariant, UpgradeStepResult>>\n> {\n  const { module, step, mode, modeDefinition, context, emit, executeVariant } = params;\n  const results: Partial<Record<UpgradeVariant, UpgradeStepResult>> = {};\n  const parallel = canRunVariantsParallel(modeDefinition, context);\n\n  if (parallel && modeDefinition.variants.length > 1) {\n    emit?.({\n      type: 'upgrade.step.variants.parallel',\n      timestamp: Date.now(),\n      data: { moduleId: module.id, stepId: step.id, variants: modeDefinition.variants },\n    });\n\n    const promises = modeDefinition.variants.map(async (variant) => {\n      const result = await executeVariant({\n        module,\n        step,\n        mode,\n        variant,\n        previousResult: undefined,\n        workspaceRoot: resolveWorkspaceRoot(variant, context),\n        repoPolicy: context.repoPolicy,\n      });\n      return { variant, result };\n    });\n\n    const resolved = await Promise.all(promises);\n    for (const { variant, result } of resolved) {\n      results[variant] = result;\n    }\n    return results;\n  }\n\n  for (const variant of modeDefinition.variants) {\n    const previousResult = variant === 'refiner' ? results.primary : undefined;\n    const result = await executeVariant({\n      module,\n      step,\n      mode,\n      variant,\n      previousResult,\n      workspaceRoot: resolveWorkspaceRoot(variant, context),\n      repoPolicy: context.repoPolicy,\n    });\n    results[variant] = result;\n  }\n\n  return results;\n}\n"],"mappings":";;;;;;;;AA4BA;AACA;AACA;AACO,SAASA,sBAAsBA,CACpCC,cAAyC,EACzCC,OAAgC,EACvB;EACT,IAAI,CAACA,OAAO,CAACC,gBAAgB,EAAE,OAAO,KAAK;EAC3C,IAAI,CAACF,cAAc,CAACG,QAAQ,CAACC,QAAQ,CAAC,SAAS,CAAC,EAAE,OAAO,KAAK;EAC9D,MAAMC,WAAW,GAAGJ,OAAO,CAACK,qBAAqB,EAAEC,OAAO;EAC1D,MAAMC,WAAW,GAAGP,OAAO,CAACK,qBAAqB,EAAEG,OAAO;EAC1D,OAAOC,OAAO,CAACL,WAAW,IAAIG,WAAW,IAAIH,WAAW,KAAKG,WAAW,CAAC;AAC3E;;AAEA;AACA;AACA;AACO,SAASG,oBAAoBA,CAClCC,OAAuB,EACvBX,OAAgC,EACZ;EACpB,OAAOA,OAAO,CAACK,qBAAqB,GAAGM,OAAO,CAAC,IAAIX,OAAO,CAACK,qBAAqB,EAAEG,OAAO;AAC3F;;AAEA;AACA;AACA;AACA;AACO,eAAeI,eAAeA,CAACC,MAA6B,EAEjE;EACA,MAAM;IAAEC,MAAM;IAAEC,IAAI;IAAEC,IAAI;IAAEjB,cAAc;IAAEC,OAAO;IAAEiB,IAAI;IAAEC;EAAe,CAAC,GAAGL,MAAM;EACpF,MAAMM,OAA2D,GAAG,CAAC,CAAC;EACtE,MAAMC,QAAQ,GAAGtB,sBAAsB,CAACC,cAAc,EAAEC,OAAO,CAAC;EAEhE,IAAIoB,QAAQ,IAAIrB,cAAc,CAACG,QAAQ,CAACmB,MAAM,GAAG,CAAC,EAAE;IAClDJ,IAAI,GAAG;MACLK,IAAI,EAAE,gCAAgC;MACtCC,SAAS,EAAEC,IAAI,CAACC,GAAG,CAAC,CAAC;MACrBC,IAAI,EAAE;QAAEC,QAAQ,EAAEb,MAAM,CAACc,EAAE;QAAEC,MAAM,EAAEd,IAAI,CAACa,EAAE;QAAE1B,QAAQ,EAAEH,cAAc,CAACG;MAAS;IAClF,CAAC,CAAC;IAEF,MAAM4B,QAAQ,GAAG/B,cAAc,CAACG,QAAQ,CAAC6B,GAAG,CAAC,MAAOpB,OAAO,IAAK;MAC9D,MAAMqB,MAAM,GAAG,MAAMd,cAAc,CAAC;QAClCJ,MAAM;QACNC,IAAI;QACJC,IAAI;QACJL,OAAO;QACPsB,cAAc,EAAEC,SAAS;QACzBC,aAAa,EAAEzB,oBAAoB,CAACC,OAAO,EAAEX,OAAO,CAAC;QACrDoC,UAAU,EAAEpC,OAAO,CAACoC;MACtB,CAAC,CAAC;MACF,OAAO;QAAEzB,OAAO;QAAEqB;MAAO,CAAC;IAC5B,CAAC,CAAC;IAEF,MAAMK,QAAQ,GAAG,MAAMC,OAAO,CAACC,GAAG,CAACT,QAAQ,CAAC;IAC5C,KAAK,MAAM;MAAEnB,OAAO;MAAEqB;IAAO,CAAC,IAAIK,QAAQ,EAAE;MAC1ClB,OAAO,CAACR,OAAO,CAAC,GAAGqB,MAAM;IAC3B;IACA,OAAOb,OAAO;EAChB;EAEA,KAAK,MAAMR,OAAO,IAAIZ,cAAc,CAACG,QAAQ,EAAE;IAC7C,MAAM+B,cAAc,GAAGtB,OAAO,KAAK,SAAS,GAAGQ,OAAO,CAACX,OAAO,GAAG0B,SAAS;IAC1E,MAAMF,MAAM,GAAG,MAAMd,cAAc,CAAC;MAClCJ,MAAM;MACNC,IAAI;MACJC,IAAI;MACJL,OAAO;MACPsB,cAAc;MACdE,aAAa,EAAEzB,oBAAoB,CAACC,OAAO,EAAEX,OAAO,CAAC;MACrDoC,UAAU,EAAEpC,OAAO,CAACoC;IACtB,CAAC,CAAC;IACFjB,OAAO,CAACR,OAAO,CAAC,GAAGqB,MAAM;EAC3B;EAEA,OAAOb,OAAO;AAChB","ignoreList":[]}