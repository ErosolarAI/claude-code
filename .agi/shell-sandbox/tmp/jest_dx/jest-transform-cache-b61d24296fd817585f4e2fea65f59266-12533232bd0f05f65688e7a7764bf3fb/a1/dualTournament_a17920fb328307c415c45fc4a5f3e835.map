{"version":3,"names":["DEFAULT_HUMAN_REWARD_WEIGHTS","exports","alpha","beta","gamma","runDualTournament","task","candidates","options","maxCandidates","boundedCandidates","slice","Math","max","length","solo","correctness","scoreCorrectness","metrics","quality","scoreQuality","preferSmallerDiff","learned","scoreLearnedSignals","signals","aggregateScore","combineReward","rewardWeights","ranked","candidateId","id","humanAccuracy","rank","correctnessScore","qualityScore","learnedScore","evaluatorScore","pairwise","evaluatorBreakdown","evaluatorWeights","Map","evaluator","evaluators","eloWeight","elo","set","weight","aggregatedEvaluatorScores","aggregateEvaluatorScores","map","candidate","rewardScore","get","clamp","sort","a","b","forEach","entry","idx","computeHumanAccuracy","execution","executionSuccess","tests","testsPassed","failures","testsFailed","toolSuccess","toolSuccesses","min","score","staticAnalysis","codeQuality","complexityComponent","complexityDelta","blastRadius","diffSize","dependencyPenalty","dependenciesAdded","warningPenalty","warnings","rewardModel","rewardModelScore","human","humanPreference","self","selfAssessment","base","blendedHuman","withSelf","weights","weighted","total","aggregated","twoCandidateFastPath","candidateIds","c","other","scoresByEvaluator","evaluatorScores","has","evaluatorId","push","notes","size","fallback","totalBordaWeight","rawScores","entries","filter","_candidateId","rest","bordaPoints","higher","lower","i","j","points","value","Number","isNaN","rankIndex","maxIndex","relative"],"sources":["dualTournament.ts"],"sourcesContent":["/**\n * Dual Tournament Engine\n *\n * Shared scoring/ranking utilities used by dual tournaments in both /upgrade and /attack flows.\n * Encodes policy vs evaluator tournaments with human-like reward heuristics and multi-evaluator\n * aggregation to approximate human code review preferences.\n */\n\nexport type PolicyId = string;\n\nexport interface TournamentPolicy {\n  id: PolicyId;\n  label?: string;\n  kind?: 'primary' | 'refiner' | 'checkpoint' | 'attack';\n  elo?: number;\n}\n\nexport interface TournamentEvaluator {\n  id: string;\n  label?: string;\n  /** Weight used when combining evaluator rankings (can be influenced by historical ELO). */\n  weight?: number;\n  kind?: 'hard' | 'soft' | 'hybrid';\n  elo?: number;\n}\n\nexport interface TournamentTask {\n  id: string;\n  goal: string;\n  repoSnapshot?: string;\n  tests?: string[];\n  constraints?: string[];\n  metadata?: Record<string, unknown>;\n}\n\nexport interface CandidateMetrics {\n  executionSuccess?: number; // 0-1\n  testsPassed?: number; // 0-1\n  testsFailed?: number; // count\n  staticAnalysis?: number; // 0-1\n  codeQuality?: number; // 0-1\n  blastRadius?: number; // 0-1 (smaller diff => higher)\n  diffSize?: number; // lines changed\n  complexityDelta?: number; // negative better\n  dependenciesAdded?: number; // count\n  speedBonus?: number; // 0-1\n  toolSuccesses?: number; // count\n  toolFailures?: number; // count\n  warnings?: number; // count\n}\n\nexport interface CandidateSignals {\n  /** Learned reward model / preference score (0-1) */\n  rewardModelScore?: number;\n  /** Self-assessed confidence from the agent (0-1) */\n  selfAssessment?: number;\n  /** Optional human preference label (0-1) */\n  humanPreference?: number;\n}\n\nexport interface EvaluatorScore {\n  evaluatorId: string;\n  score: number;\n  weight?: number;\n  notes?: string;\n}\n\ntype CandidateEvaluatorScore = EvaluatorScore & { candidateId: string };\n\nexport interface TournamentCandidate {\n  id: string;\n  policyId: PolicyId;\n  patchSummary?: string;\n  diffSummary?: string;\n  metrics?: CandidateMetrics;\n  signals?: CandidateSignals;\n  evaluatorScores?: EvaluatorScore[];\n  rawOutput?: string;\n}\n\nexport interface HumanRewardWeights {\n  /** Correctness weight */\n  alpha: number;\n  /** Code quality / robustness weight */\n  beta: number;\n  /** Learned reward / human preference weight */\n  gamma: number;\n}\n\nexport const DEFAULT_HUMAN_REWARD_WEIGHTS: HumanRewardWeights = {\n  alpha: 0.6,\n  beta: 0.25,\n  gamma: 0.15,\n};\n\nexport interface RankedCandidate {\n  candidateId: string;\n  aggregateScore: number;\n  /** Relative human-like accuracy (1 = best rank, 0 = worst rank) */\n  humanAccuracy: number;\n  rank: number;\n  correctnessScore: number;\n  qualityScore: number;\n  learnedScore: number;\n  evaluatorScore: number;\n}\n\nexport type PairwiseWins = Record<string, Record<string, number>>;\n\nexport interface TournamentOutcome {\n  task: TournamentTask;\n  ranked: RankedCandidate[];\n  pairwise: PairwiseWins;\n  evaluatorBreakdown: Record<string, EvaluatorScore[]>;\n}\n\nexport interface TournamentOptions {\n  rewardWeights?: HumanRewardWeights;\n  evaluators?: TournamentEvaluator[];\n  /** When true, prefer smaller diffs by default if diffSize is provided */\n  preferSmallerDiff?: boolean;\n  /** Maximum candidates to evaluate (caps O(n^2) work) */\n  maxCandidates?: number;\n}\n\n/**\n  * Run a dual tournament over candidate patches/agents, combining hard metrics,\n  * human-like reward heuristics, and evaluator rankings.\n  */\nexport function runDualTournament(\n  task: TournamentTask,\n  candidates: TournamentCandidate[],\n  options: TournamentOptions = {}\n): TournamentOutcome {\n  const maxCandidates = options.maxCandidates ?? 8;\n  const boundedCandidates = candidates.slice(0, Math.max(1, maxCandidates));\n\n  // Fast path: single candidate - avoid unnecessary aggregation work\n  if (boundedCandidates.length === 1) {\n    const solo = boundedCandidates[0]!;\n    const correctness = scoreCorrectness(solo.metrics);\n    const quality = scoreQuality(solo.metrics, options.preferSmallerDiff ?? true);\n    const learned = scoreLearnedSignals(solo.signals);\n    const aggregateScore = combineReward(correctness, quality, learned, options.rewardWeights ?? DEFAULT_HUMAN_REWARD_WEIGHTS);\n\n    const ranked: RankedCandidate[] = [{\n      candidateId: solo.id,\n      aggregateScore,\n      humanAccuracy: 1,\n      rank: 1,\n      correctnessScore: correctness,\n      qualityScore: quality,\n      learnedScore: learned,\n      evaluatorScore: aggregateScore,\n    }];\n\n    return {\n      task,\n      ranked,\n      pairwise: {},\n      evaluatorBreakdown: {},\n    };\n  }\n\n  const rewardWeights = options.rewardWeights ?? DEFAULT_HUMAN_REWARD_WEIGHTS;\n  const evaluatorWeights = new Map<string, number>();\n  for (const evaluator of options.evaluators ?? []) {\n    const eloWeight = evaluator.elo ? 1 + Math.max(0, (evaluator.elo - 1200) / 2400) : 1;\n    evaluatorWeights.set(evaluator.id, (evaluator.weight ?? 1) * eloWeight);\n  }\n\n  // Compute evaluator aggregates and pairwise wins first (needed for composite score)\n  const { aggregatedEvaluatorScores, pairwise, evaluatorBreakdown } = aggregateEvaluatorScores(\n    boundedCandidates,\n    evaluatorWeights\n  );\n\n  const ranked: RankedCandidate[] = boundedCandidates.map((candidate) => {\n    const correctness = scoreCorrectness(candidate.metrics);\n    const quality = scoreQuality(candidate.metrics, options.preferSmallerDiff ?? true);\n    const learned = scoreLearnedSignals(candidate.signals);\n    const rewardScore = combineReward(correctness, quality, learned, rewardWeights);\n    const evaluatorScore = aggregatedEvaluatorScores.get(candidate.id) ?? rewardScore;\n\n    // Combine human-like reward with evaluator aggregate (relative preference)\n    const aggregateScore = clamp(0.55 * rewardScore + 0.45 * evaluatorScore);\n\n    return {\n      candidateId: candidate.id,\n      aggregateScore,\n      humanAccuracy: 0,\n      rank: 0, // set after sorting\n      correctnessScore: correctness,\n      qualityScore: quality,\n      learnedScore: learned,\n      evaluatorScore,\n    };\n  });\n\n  ranked.sort((a, b) => b.aggregateScore - a.aggregateScore);\n  ranked.forEach((entry, idx) => {\n    entry.rank = idx + 1;\n    entry.humanAccuracy = computeHumanAccuracy(idx, ranked.length);\n  });\n\n  return {\n    task,\n    ranked,\n    pairwise,\n    evaluatorBreakdown,\n  };\n}\n\n// ════════════════════════════════════════════════════════════════════════════\n// Internal scoring helpers\n// ════════════════════════════════════════════════════════════════════════════\n\nfunction scoreCorrectness(metrics?: CandidateMetrics): number {\n  if (!metrics) return 0.5;\n\n  const execution = metrics.executionSuccess ?? 0;\n  const tests = metrics.testsPassed ?? 0;\n  const failures = metrics.testsFailed ?? 0;\n  const toolSuccess = metrics.toolSuccesses ? Math.min(1, metrics.toolSuccesses / 3) : 0;\n\n  let score = execution * 0.35 + tests * 0.45 + toolSuccess * 0.2;\n  if (failures > 0) {\n    score -= Math.min(0.35, failures * 0.1);\n  }\n\n  return clamp(score);\n}\n\nfunction scoreQuality(metrics?: CandidateMetrics, preferSmallerDiff = true): number {\n  if (!metrics) return 0.5;\n\n  const staticAnalysis = metrics.staticAnalysis ?? 0.5;\n  const codeQuality = metrics.codeQuality ?? 0.5;\n  const complexityComponent =\n    typeof metrics.complexityDelta === 'number'\n      ? metrics.complexityDelta < 0\n        ? 0.7\n        : 0.45\n      : 0.55;\n\n  const blastRadius =\n    metrics.blastRadius ??\n    (preferSmallerDiff && metrics.diffSize ? 1 - clamp(metrics.diffSize / 500) : 0.55);\n\n  const dependencyPenalty = metrics.dependenciesAdded ? Math.min(0.3, metrics.dependenciesAdded * 0.05) : 0;\n  const warningPenalty = metrics.warnings ? Math.min(0.2, metrics.warnings * 0.05) : 0;\n\n  let score = staticAnalysis * 0.35 + codeQuality * 0.25 + blastRadius * 0.25 + complexityComponent * 0.15;\n  score -= dependencyPenalty + warningPenalty;\n\n  return clamp(score);\n}\n\nfunction scoreLearnedSignals(signals?: CandidateSignals): number {\n  if (!signals) return 0.5;\n\n  const rewardModel = signals.rewardModelScore;\n  const human = signals.humanPreference;\n  const self = signals.selfAssessment;\n\n  const base = typeof rewardModel === 'number' ? rewardModel : 0.5;\n  const blendedHuman = typeof human === 'number' ? (base + human) / 2 : base;\n  const withSelf = typeof self === 'number' ? 0.7 * blendedHuman + 0.3 * self : blendedHuman;\n\n  return clamp(withSelf);\n}\n\nfunction combineReward(\n  correctness: number,\n  quality: number,\n  learned: number,\n  weights: HumanRewardWeights\n): number {\n  const weighted =\n    weights.alpha * correctness +\n    weights.beta * quality +\n    weights.gamma * learned;\n  const total = weights.alpha + weights.beta + weights.gamma;\n  return total > 0 ? clamp(weighted / total) : clamp(weighted);\n}\n\nfunction aggregateEvaluatorScores(\n  candidates: TournamentCandidate[],\n  evaluatorWeights: Map<string, number>\n): {\n  aggregatedEvaluatorScores: Map<string, number>;\n  pairwise: PairwiseWins;\n  evaluatorBreakdown: Record<string, EvaluatorScore[]>;\n} {\n  const pairwise: PairwiseWins = {};\n  const aggregated = new Map<string, number>();\n  const evaluatorBreakdown: Record<string, EvaluatorScore[]> = {};\n\n  if (candidates.length === 0) {\n    return { aggregatedEvaluatorScores: aggregated, pairwise, evaluatorBreakdown };\n  }\n\n  // Pre-size for small tournaments to avoid unnecessary O(n^2) when not needed\n  const twoCandidateFastPath = candidates.length <= 2;\n\n  const candidateIds = candidates.map((c) => c.id);\n  for (const id of candidateIds) {\n    pairwise[id] = {};\n    for (const other of candidateIds) {\n      if (id !== other) pairwise[id][other] = 0;\n    }\n  }\n\n  // Collect scores per evaluator\n  const scoresByEvaluator = new Map<string, CandidateEvaluatorScore[]>();\n  for (const candidate of candidates) {\n    for (const score of candidate.evaluatorScores ?? []) {\n      if (!scoresByEvaluator.has(score.evaluatorId)) {\n        scoresByEvaluator.set(score.evaluatorId, []);\n      }\n      scoresByEvaluator.get(score.evaluatorId)!.push({\n        evaluatorId: score.evaluatorId,\n        score: clamp(score.score),\n        weight: score.weight,\n        notes: score.notes,\n        candidateId: candidate.id,\n      });\n    }\n  }\n\n  // If no evaluator scores provided, fall back to neutral rankings\n  if (scoresByEvaluator.size === 0) {\n    const fallback: CandidateEvaluatorScore[] = [];\n    for (const candidate of candidates) {\n      fallback.push({\n        evaluatorId: 'reward-fallback',\n        score: 0.5,\n        weight: 1,\n        candidateId: candidate.id,\n      });\n    }\n    scoresByEvaluator.set('reward-fallback', fallback);\n  }\n\n  let totalBordaWeight = 0;\n\n  for (const [evaluatorId, rawScores] of scoresByEvaluator.entries()) {\n    const weight = evaluatorWeights.get(evaluatorId) ?? 1;\n    totalBordaWeight += weight * Math.max(1, candidates.length - 1);\n\n    // Sort descending by score to assign ranks (Borda)\n    const ranked = rawScores\n      .filter((entry) => typeof entry.score === 'number')\n      .sort((a, b) => (b.score ?? 0) - (a.score ?? 0));\n\n    evaluatorBreakdown[evaluatorId] = ranked.map(({ candidateId: _candidateId, ...rest }) => rest as EvaluatorScore);\n\n    ranked.forEach((entry, idx) => {\n      const candidateId = (entry as unknown as { candidateId: string }).candidateId;\n      const bordaPoints = (candidates.length - idx - 1) * weight;\n      aggregated.set(candidateId, (aggregated.get(candidateId) ?? 0) + bordaPoints);\n    });\n\n    // Pairwise wins for this evaluator (lightweight path for <=2 candidates)\n    if (twoCandidateFastPath && ranked.length === 2) {\n      const higher = ranked[0] as unknown as { candidateId: string; score: number };\n      const lower = ranked[1] as unknown as { candidateId: string; score: number };\n      if (higher.score === lower.score) {\n        pairwise[higher.candidateId][lower.candidateId] += weight * 0.5;\n        pairwise[lower.candidateId][higher.candidateId] += weight * 0.5;\n      } else {\n        pairwise[higher.candidateId][lower.candidateId] += weight;\n      }\n    } else {\n      for (let i = 0; i < ranked.length; i++) {\n        for (let j = i + 1; j < ranked.length; j++) {\n          const higher = ranked[i] as unknown as { candidateId: string; score: number };\n          const lower = ranked[j] as unknown as { candidateId: string; score: number };\n          if (higher.score === lower.score) {\n            pairwise[higher.candidateId][lower.candidateId] += weight * 0.5;\n            pairwise[lower.candidateId][higher.candidateId] += weight * 0.5;\n          } else {\n            pairwise[higher.candidateId][lower.candidateId] += weight;\n          }\n        }\n      }\n    }\n  }\n\n  // Normalize aggregated Borda scores into [0,1]\n  if (totalBordaWeight > 0) {\n    for (const [candidateId, points] of aggregated.entries()) {\n      aggregated.set(candidateId, clamp(points / totalBordaWeight));\n    }\n  }\n\n  // Ensure every candidate has an entry\n  for (const candidateId of candidateIds) {\n    if (!aggregated.has(candidateId)) {\n      aggregated.set(candidateId, 0.5);\n    }\n  }\n\n  return { aggregatedEvaluatorScores: aggregated, pairwise, evaluatorBreakdown };\n}\n\nfunction clamp(value: number, min = 0, max = 1): number {\n  if (Number.isNaN(value)) return min;\n  return Math.max(min, Math.min(max, value));\n}\n\nfunction computeHumanAccuracy(rankIndex: number, total: number): number {\n  if (total <= 1) return 1;\n  const maxIndex = Math.max(1, total - 1);\n  const relative = 1 - rankIndex / maxIndex;\n  return clamp(relative);\n}\n"],"mappings":"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","ignoreList":[]}