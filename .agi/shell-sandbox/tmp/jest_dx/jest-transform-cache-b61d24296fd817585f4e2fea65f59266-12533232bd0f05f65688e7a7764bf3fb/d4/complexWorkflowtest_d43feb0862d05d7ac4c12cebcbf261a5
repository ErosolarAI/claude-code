13b269f414daad89df4ef65b0adf227c
"use strict";

var _globals = require("@jest/globals");
var _nodeFs = require("node:fs");
var _nodePath = require("node:path");
var _nodeOs = require("node:os");
/**
 * Complex Workflow Integration Tests
 * Tests real-world multi-step workflows that exercise multiple tools
 */

(0, _globals.describe)('Complex Workflow Integration', () => {
  const testWorkspace = (0, _nodePath.join)((0, _nodeOs.tmpdir)(), 'erosolar-test-workspace');
  beforeEach(() => {
    // Create clean test workspace
    if ((0, _nodeFs.existsSync)(testWorkspace)) {
      (0, _nodeFs.rmSync)(testWorkspace, {
        recursive: true,
        force: true
      });
    }
    (0, _nodeFs.mkdirSync)(testWorkspace, {
      recursive: true
    });
  });
  afterEach(() => {
    // Cleanup
    if ((0, _nodeFs.existsSync)(testWorkspace)) {
      (0, _nodeFs.rmSync)(testWorkspace, {
        recursive: true,
        force: true
      });
    }
  });
  (0, _globals.test)('Multi-file code refactoring workflow', () => {
    // Workflow: Search → Read → Edit → Verify
    // Simulates: "Find all instances of 'foo' and rename to 'bar'"

    // Setup: Create test files
    const file1 = (0, _nodePath.join)(testWorkspace, 'file1.ts');
    const file2 = (0, _nodePath.join)(testWorkspace, 'file2.ts');
    (0, _nodeFs.writeFileSync)(file1, `
export function foo(x: number): number {
  return x + 1;
}

export const fooValue = foo(42);
`.trim());
    (0, _nodeFs.writeFileSync)(file2, `
import { foo } from './file1';

export function useFoo() {
  return foo(10);
}
`.trim());

    // Step 1: Search for 'foo'
    const searchResults = [file1, file2]; // Simulated grep results
    (0, _globals.expect)(searchResults).toHaveLength(2);

    // Step 2: Read files
    const content1 = (0, _nodeFs.readFileSync)(file1, 'utf-8');
    const content2 = (0, _nodeFs.readFileSync)(file2, 'utf-8');
    (0, _globals.expect)(content1).toContain('foo');
    (0, _globals.expect)(content2).toContain('foo');

    // Step 3: Edit files (simulated)
    const edited1 = content1.replace(/foo/g, 'bar');
    const edited2 = content2.replace(/foo/g, 'bar');
    (0, _nodeFs.writeFileSync)(file1, edited1);
    (0, _nodeFs.writeFileSync)(file2, edited2);

    // Step 4: Verify changes
    const verified1 = (0, _nodeFs.readFileSync)(file1, 'utf-8');
    const verified2 = (0, _nodeFs.readFileSync)(file2, 'utf-8');
    (0, _globals.expect)(verified1).not.toContain('foo');
    (0, _globals.expect)(verified1).toContain('bar');
    (0, _globals.expect)(verified2).not.toContain('foo');
    (0, _globals.expect)(verified2).toContain('bar');
  });
  (0, _globals.test)('Bug investigation and fix workflow', () => {
    // Workflow: Explore → Grep → Read → Edit → Test
    // Simulates: "Find and fix a type error in the codebase"

    // Setup: Create files with a bug
    const srcDir = (0, _nodePath.join)(testWorkspace, 'src');
    (0, _nodeFs.mkdirSync)(srcDir, {
      recursive: true
    });
    const buggyFile = (0, _nodePath.join)(srcDir, 'calculator.ts');
    (0, _nodeFs.writeFileSync)(buggyFile, `
export class Calculator {
  add(a: number, b: number): number {
    return a + b;
  }

  // Bug: returns string instead of number
  multiply(a: number, b: number): string {
    return (a * b).toString();
  }
}
`.trim());
    const testFile = (0, _nodePath.join)(srcDir, 'calculator.test.ts');
    (0, _nodeFs.writeFileSync)(testFile, `
import { Calculator } from './calculator';

const calc = new Calculator();
const result: number = calc.multiply(3, 4); // Type error!
`.trim());

    // Step 1: Explore - find TypeScript files
    const tsFiles = [buggyFile, testFile]; // Simulated glob results
    (0, _globals.expect)(tsFiles).toHaveLength(2);

    // Step 2: Grep - search for type errors (simulated type check)
    const typeErrors = ['calculator.ts:7 - Type error: Type \'string\' is not assignable to type \'number\''];
    (0, _globals.expect)(typeErrors).toHaveLength(1);

    // Step 3: Read the buggy file
    const buggyContent = (0, _nodeFs.readFileSync)(buggyFile, 'utf-8');
    (0, _globals.expect)(buggyContent).toContain('multiply(a: number, b: number): string');

    // Step 4: Fix the bug
    const fixed = buggyContent.replace('multiply(a: number, b: number): string {\n    return (a * b).toString();', 'multiply(a: number, b: number): number {\n    return a * b;');
    (0, _nodeFs.writeFileSync)(buggyFile, fixed);

    // Step 5: Verify fix
    const fixedContent = (0, _nodeFs.readFileSync)(buggyFile, 'utf-8');
    (0, _globals.expect)(fixedContent).toContain('multiply(a: number, b: number): number');
    (0, _globals.expect)(fixedContent).not.toContain('.toString()');
  });
  (0, _globals.test)('Feature implementation workflow', () => {
    // Workflow: Plan → Read → Write → Edit → Test
    // Simulates: "Add a new feature with tests"

    const srcDir = (0, _nodePath.join)(testWorkspace, 'src');
    const testDir = (0, _nodePath.join)(testWorkspace, 'test');
    (0, _nodeFs.mkdirSync)(srcDir, {
      recursive: true
    });
    (0, _nodeFs.mkdirSync)(testDir, {
      recursive: true
    });

    // Step 1: Plan (simulated todo list)
    const plan = ['Create UserService class', 'Add getUser method', 'Add createUser method', 'Write unit tests'];
    (0, _globals.expect)(plan).toHaveLength(4);

    // Step 2: Write new file
    const serviceFile = (0, _nodePath.join)(srcDir, 'UserService.ts');
    (0, _nodeFs.writeFileSync)(serviceFile, `
export interface User {
  id: string;
  name: string;
  email: string;
}

export class UserService {
  private users: Map<string, User> = new Map();

  getUser(id: string): User | undefined {
    return this.users.get(id);
  }

  createUser(name: string, email: string): User {
    const id = Math.random().toString(36).substr(2, 9);
    const user: User = { id, name, email };
    this.users.set(id, user);
    return user;
  }
}
`.trim());
    (0, _globals.expect)((0, _nodeFs.existsSync)(serviceFile)).toBe(true);

    // Step 3: Write tests
    const testFilePath = (0, _nodePath.join)(testDir, 'UserService.test.ts');
    (0, _nodeFs.writeFileSync)(testFilePath, `
import { UserService } from '../src/UserService';

describe('UserService', () => {
  test('should create and retrieve user', () => {
    const service = new UserService();
    const user = service.createUser('Alice', 'alice@example.com');

    expect(user.name).toBe('Alice');
    expect(user.email).toBe('alice@example.com');
    expect(user.id).toBeTruthy();

    const retrieved = service.getUser(user.id);
    expect(retrieved).toEqual(user);
  });

  test('should return undefined for non-existent user', () => {
    const service = new UserService();
    const user = service.getUser('nonexistent');
    expect(user).toBeUndefined();
  });
});
`.trim());
    (0, _globals.expect)((0, _nodeFs.existsSync)(testFilePath)).toBe(true);

    // Step 4: Read back and verify
    const serviceContent = (0, _nodeFs.readFileSync)(serviceFile, 'utf-8');
    const testContent = (0, _nodeFs.readFileSync)(testFilePath, 'utf-8');
    (0, _globals.expect)(serviceContent).toContain('class UserService');
    (0, _globals.expect)(serviceContent).toContain('getUser');
    (0, _globals.expect)(serviceContent).toContain('createUser');
    (0, _globals.expect)(testContent).toContain('describe(\'UserService\'');
    (0, _globals.expect)(testContent).toContain('should create and retrieve user');
  });
  (0, _globals.test)('Documentation generation workflow', () => {
    // Workflow: Explore → Read → Analyze → Write
    // Simulates: "Generate README from source files"

    const srcDir = (0, _nodePath.join)(testWorkspace, 'src');
    (0, _nodeFs.mkdirSync)(srcDir, {
      recursive: true
    });

    // Create source files
    const api = (0, _nodePath.join)(srcDir, 'api.ts');
    (0, _nodeFs.writeFileSync)(api, `
/**
 * Main API client for the service
 */
export class ApiClient {
  /**
   * Fetch data from the API
   * @param endpoint The API endpoint
   * @returns Promise with the response data
   */
  async fetch(endpoint: string): Promise<any> {
    // Implementation
    return {};
  }
}
`.trim());
    const utils = (0, _nodePath.join)(srcDir, 'utils.ts');
    (0, _nodeFs.writeFileSync)(utils, `
/**
 * Utility functions
 */

/**
 * Format a date string
 * @param date The date to format
 * @returns Formatted date string
 */
export function formatDate(date: Date): string {
  return date.toISOString();
}
`.trim());

    // Step 1: Explore - find all source files
    const sourceFiles = [api, utils];
    (0, _globals.expect)(sourceFiles).toHaveLength(2);

    // Step 2: Read and extract documentation
    const apiContent = (0, _nodeFs.readFileSync)(api, 'utf-8');
    const utilsContent = (0, _nodeFs.readFileSync)(utils, 'utf-8');
    const apiDocs = apiContent.match(/\/\*\*[\s\S]*?\*\//g) || [];
    const utilsDocs = utilsContent.match(/\/\*\*[\s\S]*?\*\//g) || [];
    (0, _globals.expect)(apiDocs.length).toBeGreaterThan(0);
    (0, _globals.expect)(utilsDocs.length).toBeGreaterThan(0);

    // Step 3: Generate README
    const readme = (0, _nodePath.join)(testWorkspace, 'README.md');
    (0, _nodeFs.writeFileSync)(readme, `
# Project Documentation

## API Client

Main API client for the service.

### Methods

- \`fetch(endpoint: string)\` - Fetch data from the API

## Utilities

### Functions

- \`formatDate(date: Date)\` - Format a date string

`.trim());

    // Step 4: Verify README exists and has content
    const readmeContent = (0, _nodeFs.readFileSync)(readme, 'utf-8');
    (0, _globals.expect)(readmeContent).toContain('API Client');
    (0, _globals.expect)(readmeContent).toContain('Utilities');
    (0, _globals.expect)(readmeContent).toContain('fetch');
    (0, _globals.expect)(readmeContent).toContain('formatDate');
  });
  (0, _globals.test)('Code quality improvement workflow', () => {
    // Workflow: Analyze → Identify Issues → Fix → Verify
    // Simulates: "Find and fix code quality issues"

    const srcDir = (0, _nodePath.join)(testWorkspace, 'src');
    (0, _nodeFs.mkdirSync)(srcDir, {
      recursive: true
    });

    // Create file with quality issues
    const messyFile = (0, _nodePath.join)(srcDir, 'messy.ts');
    (0, _nodeFs.writeFileSync)(messyFile, `
export function processData(data: any): any {
  // TODO: Add proper types
  var result = [];  // Use const instead of var
  for (var i = 0; i < data.length; i++) {  // Use for-of instead
    if (data[i] != null) {  // Use !== instead of !=
      result.push(data[i]);
    }
  }
  return result;
}
`.trim());

    // Step 1: Analyze - detect issues
    const content = (0, _nodeFs.readFileSync)(messyFile, 'utf-8');
    const issues = ['Line 1: Using "any" type', 'Line 3: Using "var" instead of "const"', 'Line 4: Using for loop instead of for-of', 'Line 5: Using != instead of !=='];
    (0, _globals.expect)(issues.length).toBeGreaterThan(0);

    // Step 2: Fix issues
    const improved = `
export function processData(data: unknown[]): unknown[] {
  const result: unknown[] = [];
  for (const item of data) {
    if (item !== null && item !== undefined) {
      result.push(item);
    }
  }
  return result;
}
`.trim();
    (0, _nodeFs.writeFileSync)(messyFile, improved);

    // Step 3: Verify improvements
    const fixedContent = (0, _nodeFs.readFileSync)(messyFile, 'utf-8');
    (0, _globals.expect)(fixedContent).not.toContain('any');
    (0, _globals.expect)(fixedContent).not.toContain('var ');
    (0, _globals.expect)(fixedContent).toContain('const');
    (0, _globals.expect)(fixedContent).toContain('!==');
    (0, _globals.expect)(fixedContent).toContain('for (const');
  });
  (0, _globals.test)('Dependency update workflow', () => {
    // Workflow: Check Dependencies → Read Changelog → Update → Test
    // Simulates: "Update dependencies safely"

    const packageJson = (0, _nodePath.join)(testWorkspace, 'package.json');
    (0, _nodeFs.writeFileSync)(packageJson, JSON.stringify({
      name: 'test-project',
      version: '1.0.0',
      dependencies: {
        'old-lib': '^1.0.0'
      },
      devDependencies: {
        'test-lib': '^2.0.0'
      }
    }, null, 2));

    // Step 1: Read current dependencies
    const pkgContent = JSON.parse((0, _nodeFs.readFileSync)(packageJson, 'utf-8'));
    (0, _globals.expect)(pkgContent.dependencies['old-lib']).toBe('^1.0.0');

    // Step 2: Update versions (simulated)
    pkgContent.dependencies['old-lib'] = '^2.0.0';
    pkgContent.devDependencies['test-lib'] = '^3.0.0';
    (0, _nodeFs.writeFileSync)(packageJson, JSON.stringify(pkgContent, null, 2));

    // Step 3: Verify updates
    const updated = JSON.parse((0, _nodeFs.readFileSync)(packageJson, 'utf-8'));
    (0, _globals.expect)(updated.dependencies['old-lib']).toBe('^2.0.0');
    (0, _globals.expect)(updated.devDependencies['test-lib']).toBe('^3.0.0');
  });
  (0, _globals.test)('Error recovery and retry workflow', () => {
    // Workflow: Attempt → Fail → Analyze → Fix → Retry
    // Simulates: "Handle and recover from errors gracefully"

    const testFile = (0, _nodePath.join)(testWorkspace, 'config.json');

    // Step 1: Attempt to read non-existent file
    let content = null;
    let error = null;
    try {
      content = (0, _nodeFs.readFileSync)(testFile, 'utf-8');
    } catch (err) {
      error = err;
    }
    (0, _globals.expect)(content).toBeNull();
    (0, _globals.expect)(error).not.toBeNull();
    (0, _globals.expect)(error?.message).toContain('ENOENT');

    // Step 2: Analyze error - file doesn't exist
    const fileExists = (0, _nodeFs.existsSync)(testFile);
    (0, _globals.expect)(fileExists).toBe(false);

    // Step 3: Fix - create the file
    (0, _nodeFs.writeFileSync)(testFile, JSON.stringify({
      setting: 'value'
    }, null, 2));

    // Step 4: Retry - should succeed now
    content = null;
    error = null;
    try {
      content = (0, _nodeFs.readFileSync)(testFile, 'utf-8');
    } catch (err) {
      error = err;
    }
    (0, _globals.expect)(content).not.toBeNull();
    (0, _globals.expect)(error).toBeNull();
    (0, _globals.expect)(JSON.parse(content)).toEqual({
      setting: 'value'
    });
  });
  (0, _globals.test)('Concurrent file operations workflow', async () => {
    // Workflow: Multiple parallel operations
    // Simulates: "Process multiple files concurrently"

    const files = ['file1.txt', 'file2.txt', 'file3.txt', 'file4.txt'];
    const operations = files.map((filename, index) => Promise.resolve().then(() => {
      const filepath = (0, _nodePath.join)(testWorkspace, filename);
      (0, _nodeFs.writeFileSync)(filepath, `Content for file ${index + 1}`);
    }));

    // Wait for all writes to complete
    await Promise.all(operations);

    // Step 2: Read all files concurrently
    const contents = await Promise.all(files.map(filename => Promise.resolve().then(() => {
      const filepath = (0, _nodePath.join)(testWorkspace, filename);
      return (0, _nodeFs.readFileSync)(filepath, 'utf-8');
    })));

    // Step 3: Verify all files were written correctly
    (0, _globals.expect)(contents).toHaveLength(files.length);
    contents.forEach((content, index) => {
      (0, _globals.expect)(content).toBe(`Content for file ${index + 1}`);
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZ2xvYmFscyIsInJlcXVpcmUiLCJfbm9kZUZzIiwiX25vZGVQYXRoIiwiX25vZGVPcyIsImRlc2NyaWJlIiwidGVzdFdvcmtzcGFjZSIsImpvaW4iLCJ0bXBkaXIiLCJiZWZvcmVFYWNoIiwiZXhpc3RzU3luYyIsInJtU3luYyIsInJlY3Vyc2l2ZSIsImZvcmNlIiwibWtkaXJTeW5jIiwiYWZ0ZXJFYWNoIiwidGVzdCIsImZpbGUxIiwiZmlsZTIiLCJ3cml0ZUZpbGVTeW5jIiwidHJpbSIsInNlYXJjaFJlc3VsdHMiLCJleHBlY3QiLCJ0b0hhdmVMZW5ndGgiLCJjb250ZW50MSIsInJlYWRGaWxlU3luYyIsImNvbnRlbnQyIiwidG9Db250YWluIiwiZWRpdGVkMSIsInJlcGxhY2UiLCJlZGl0ZWQyIiwidmVyaWZpZWQxIiwidmVyaWZpZWQyIiwibm90Iiwic3JjRGlyIiwiYnVnZ3lGaWxlIiwidGVzdEZpbGUiLCJ0c0ZpbGVzIiwidHlwZUVycm9ycyIsImJ1Z2d5Q29udGVudCIsImZpeGVkIiwiZml4ZWRDb250ZW50IiwidGVzdERpciIsInBsYW4iLCJzZXJ2aWNlRmlsZSIsInRvQmUiLCJ0ZXN0RmlsZVBhdGgiLCJzZXJ2aWNlQ29udGVudCIsInRlc3RDb250ZW50IiwiYXBpIiwidXRpbHMiLCJzb3VyY2VGaWxlcyIsImFwaUNvbnRlbnQiLCJ1dGlsc0NvbnRlbnQiLCJhcGlEb2NzIiwibWF0Y2giLCJ1dGlsc0RvY3MiLCJsZW5ndGgiLCJ0b0JlR3JlYXRlclRoYW4iLCJyZWFkbWUiLCJyZWFkbWVDb250ZW50IiwibWVzc3lGaWxlIiwiY29udGVudCIsImlzc3VlcyIsImltcHJvdmVkIiwicGFja2FnZUpzb24iLCJKU09OIiwic3RyaW5naWZ5IiwibmFtZSIsInZlcnNpb24iLCJkZXBlbmRlbmNpZXMiLCJkZXZEZXBlbmRlbmNpZXMiLCJwa2dDb250ZW50IiwicGFyc2UiLCJ1cGRhdGVkIiwiZXJyb3IiLCJlcnIiLCJ0b0JlTnVsbCIsIm1lc3NhZ2UiLCJmaWxlRXhpc3RzIiwic2V0dGluZyIsInRvRXF1YWwiLCJmaWxlcyIsIm9wZXJhdGlvbnMiLCJtYXAiLCJmaWxlbmFtZSIsImluZGV4IiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiZmlsZXBhdGgiLCJhbGwiLCJjb250ZW50cyIsImZvckVhY2giXSwic291cmNlcyI6WyJjb21wbGV4V29ya2Zsb3cudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbXBsZXggV29ya2Zsb3cgSW50ZWdyYXRpb24gVGVzdHNcbiAqIFRlc3RzIHJlYWwtd29ybGQgbXVsdGktc3RlcCB3b3JrZmxvd3MgdGhhdCBleGVyY2lzZSBtdWx0aXBsZSB0b29sc1xuICovXG5cbmltcG9ydCB7IGRlc2NyaWJlLCB0ZXN0LCBleHBlY3QgfSBmcm9tICdAamVzdC9nbG9iYWxzJztcbmltcG9ydCB7IHJlYWRGaWxlU3luYywgZXhpc3RzU3luYywgbWtkaXJTeW5jLCB3cml0ZUZpbGVTeW5jLCBybVN5bmMgfSBmcm9tICdub2RlOmZzJztcbmltcG9ydCB7IGpvaW4gfSBmcm9tICdub2RlOnBhdGgnO1xuaW1wb3J0IHsgdG1wZGlyIH0gZnJvbSAnbm9kZTpvcyc7XG5cbmRlc2NyaWJlKCdDb21wbGV4IFdvcmtmbG93IEludGVncmF0aW9uJywgKCkgPT4ge1xuICBjb25zdCB0ZXN0V29ya3NwYWNlID0gam9pbih0bXBkaXIoKSwgJ2Vyb3NvbGFyLXRlc3Qtd29ya3NwYWNlJyk7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgLy8gQ3JlYXRlIGNsZWFuIHRlc3Qgd29ya3NwYWNlXG4gICAgaWYgKGV4aXN0c1N5bmModGVzdFdvcmtzcGFjZSkpIHtcbiAgICAgIHJtU3luYyh0ZXN0V29ya3NwYWNlLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSk7XG4gICAgfVxuICAgIG1rZGlyU3luYyh0ZXN0V29ya3NwYWNlLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAvLyBDbGVhbnVwXG4gICAgaWYgKGV4aXN0c1N5bmModGVzdFdvcmtzcGFjZSkpIHtcbiAgICAgIHJtU3luYyh0ZXN0V29ya3NwYWNlLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcblxuICB0ZXN0KCdNdWx0aS1maWxlIGNvZGUgcmVmYWN0b3Jpbmcgd29ya2Zsb3cnLCAoKSA9PiB7XG4gICAgLy8gV29ya2Zsb3c6IFNlYXJjaCDihpIgUmVhZCDihpIgRWRpdCDihpIgVmVyaWZ5XG4gICAgLy8gU2ltdWxhdGVzOiBcIkZpbmQgYWxsIGluc3RhbmNlcyBvZiAnZm9vJyBhbmQgcmVuYW1lIHRvICdiYXInXCJcblxuICAgIC8vIFNldHVwOiBDcmVhdGUgdGVzdCBmaWxlc1xuICAgIGNvbnN0IGZpbGUxID0gam9pbih0ZXN0V29ya3NwYWNlLCAnZmlsZTEudHMnKTtcbiAgICBjb25zdCBmaWxlMiA9IGpvaW4odGVzdFdvcmtzcGFjZSwgJ2ZpbGUyLnRzJyk7XG5cbiAgICB3cml0ZUZpbGVTeW5jKGZpbGUxLCBgXG5leHBvcnQgZnVuY3Rpb24gZm9vKHg6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiB4ICsgMTtcbn1cblxuZXhwb3J0IGNvbnN0IGZvb1ZhbHVlID0gZm9vKDQyKTtcbmAudHJpbSgpKTtcblxuICAgIHdyaXRlRmlsZVN5bmMoZmlsZTIsIGBcbmltcG9ydCB7IGZvbyB9IGZyb20gJy4vZmlsZTEnO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9vKCkge1xuICByZXR1cm4gZm9vKDEwKTtcbn1cbmAudHJpbSgpKTtcblxuICAgIC8vIFN0ZXAgMTogU2VhcmNoIGZvciAnZm9vJ1xuICAgIGNvbnN0IHNlYXJjaFJlc3VsdHMgPSBbZmlsZTEsIGZpbGUyXTsgLy8gU2ltdWxhdGVkIGdyZXAgcmVzdWx0c1xuICAgIGV4cGVjdChzZWFyY2hSZXN1bHRzKS50b0hhdmVMZW5ndGgoMik7XG5cbiAgICAvLyBTdGVwIDI6IFJlYWQgZmlsZXNcbiAgICBjb25zdCBjb250ZW50MSA9IHJlYWRGaWxlU3luYyhmaWxlMSwgJ3V0Zi04Jyk7XG4gICAgY29uc3QgY29udGVudDIgPSByZWFkRmlsZVN5bmMoZmlsZTIsICd1dGYtOCcpO1xuXG4gICAgZXhwZWN0KGNvbnRlbnQxKS50b0NvbnRhaW4oJ2ZvbycpO1xuICAgIGV4cGVjdChjb250ZW50MikudG9Db250YWluKCdmb28nKTtcblxuICAgIC8vIFN0ZXAgMzogRWRpdCBmaWxlcyAoc2ltdWxhdGVkKVxuICAgIGNvbnN0IGVkaXRlZDEgPSBjb250ZW50MS5yZXBsYWNlKC9mb28vZywgJ2JhcicpO1xuICAgIGNvbnN0IGVkaXRlZDIgPSBjb250ZW50Mi5yZXBsYWNlKC9mb28vZywgJ2JhcicpO1xuXG4gICAgd3JpdGVGaWxlU3luYyhmaWxlMSwgZWRpdGVkMSk7XG4gICAgd3JpdGVGaWxlU3luYyhmaWxlMiwgZWRpdGVkMik7XG5cbiAgICAvLyBTdGVwIDQ6IFZlcmlmeSBjaGFuZ2VzXG4gICAgY29uc3QgdmVyaWZpZWQxID0gcmVhZEZpbGVTeW5jKGZpbGUxLCAndXRmLTgnKTtcbiAgICBjb25zdCB2ZXJpZmllZDIgPSByZWFkRmlsZVN5bmMoZmlsZTIsICd1dGYtOCcpO1xuXG4gICAgZXhwZWN0KHZlcmlmaWVkMSkubm90LnRvQ29udGFpbignZm9vJyk7XG4gICAgZXhwZWN0KHZlcmlmaWVkMSkudG9Db250YWluKCdiYXInKTtcbiAgICBleHBlY3QodmVyaWZpZWQyKS5ub3QudG9Db250YWluKCdmb28nKTtcbiAgICBleHBlY3QodmVyaWZpZWQyKS50b0NvbnRhaW4oJ2JhcicpO1xuICB9KTtcblxuICB0ZXN0KCdCdWcgaW52ZXN0aWdhdGlvbiBhbmQgZml4IHdvcmtmbG93JywgKCkgPT4ge1xuICAgIC8vIFdvcmtmbG93OiBFeHBsb3JlIOKGkiBHcmVwIOKGkiBSZWFkIOKGkiBFZGl0IOKGkiBUZXN0XG4gICAgLy8gU2ltdWxhdGVzOiBcIkZpbmQgYW5kIGZpeCBhIHR5cGUgZXJyb3IgaW4gdGhlIGNvZGViYXNlXCJcblxuICAgIC8vIFNldHVwOiBDcmVhdGUgZmlsZXMgd2l0aCBhIGJ1Z1xuICAgIGNvbnN0IHNyY0RpciA9IGpvaW4odGVzdFdvcmtzcGFjZSwgJ3NyYycpO1xuICAgIG1rZGlyU3luYyhzcmNEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuXG4gICAgY29uc3QgYnVnZ3lGaWxlID0gam9pbihzcmNEaXIsICdjYWxjdWxhdG9yLnRzJyk7XG4gICAgd3JpdGVGaWxlU3luYyhidWdneUZpbGUsIGBcbmV4cG9ydCBjbGFzcyBDYWxjdWxhdG9yIHtcbiAgYWRkKGE6IG51bWJlciwgYjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gYSArIGI7XG4gIH1cblxuICAvLyBCdWc6IHJldHVybnMgc3RyaW5nIGluc3RlYWQgb2YgbnVtYmVyXG4gIG11bHRpcGx5KGE6IG51bWJlciwgYjogbnVtYmVyKTogc3RyaW5nIHtcbiAgICByZXR1cm4gKGEgKiBiKS50b1N0cmluZygpO1xuICB9XG59XG5gLnRyaW0oKSk7XG5cbiAgICBjb25zdCB0ZXN0RmlsZSA9IGpvaW4oc3JjRGlyLCAnY2FsY3VsYXRvci50ZXN0LnRzJyk7XG4gICAgd3JpdGVGaWxlU3luYyh0ZXN0RmlsZSwgYFxuaW1wb3J0IHsgQ2FsY3VsYXRvciB9IGZyb20gJy4vY2FsY3VsYXRvcic7XG5cbmNvbnN0IGNhbGMgPSBuZXcgQ2FsY3VsYXRvcigpO1xuY29uc3QgcmVzdWx0OiBudW1iZXIgPSBjYWxjLm11bHRpcGx5KDMsIDQpOyAvLyBUeXBlIGVycm9yIVxuYC50cmltKCkpO1xuXG4gICAgLy8gU3RlcCAxOiBFeHBsb3JlIC0gZmluZCBUeXBlU2NyaXB0IGZpbGVzXG4gICAgY29uc3QgdHNGaWxlcyA9IFtidWdneUZpbGUsIHRlc3RGaWxlXTsgLy8gU2ltdWxhdGVkIGdsb2IgcmVzdWx0c1xuICAgIGV4cGVjdCh0c0ZpbGVzKS50b0hhdmVMZW5ndGgoMik7XG5cbiAgICAvLyBTdGVwIDI6IEdyZXAgLSBzZWFyY2ggZm9yIHR5cGUgZXJyb3JzIChzaW11bGF0ZWQgdHlwZSBjaGVjaylcbiAgICBjb25zdCB0eXBlRXJyb3JzID0gWydjYWxjdWxhdG9yLnRzOjcgLSBUeXBlIGVycm9yOiBUeXBlIFxcJ3N0cmluZ1xcJyBpcyBub3QgYXNzaWduYWJsZSB0byB0eXBlIFxcJ251bWJlclxcJyddO1xuICAgIGV4cGVjdCh0eXBlRXJyb3JzKS50b0hhdmVMZW5ndGgoMSk7XG5cbiAgICAvLyBTdGVwIDM6IFJlYWQgdGhlIGJ1Z2d5IGZpbGVcbiAgICBjb25zdCBidWdneUNvbnRlbnQgPSByZWFkRmlsZVN5bmMoYnVnZ3lGaWxlLCAndXRmLTgnKTtcbiAgICBleHBlY3QoYnVnZ3lDb250ZW50KS50b0NvbnRhaW4oJ211bHRpcGx5KGE6IG51bWJlciwgYjogbnVtYmVyKTogc3RyaW5nJyk7XG5cbiAgICAvLyBTdGVwIDQ6IEZpeCB0aGUgYnVnXG4gICAgY29uc3QgZml4ZWQgPSBidWdneUNvbnRlbnQucmVwbGFjZShcbiAgICAgICdtdWx0aXBseShhOiBudW1iZXIsIGI6IG51bWJlcik6IHN0cmluZyB7XFxuICAgIHJldHVybiAoYSAqIGIpLnRvU3RyaW5nKCk7JyxcbiAgICAgICdtdWx0aXBseShhOiBudW1iZXIsIGI6IG51bWJlcik6IG51bWJlciB7XFxuICAgIHJldHVybiBhICogYjsnXG4gICAgKTtcbiAgICB3cml0ZUZpbGVTeW5jKGJ1Z2d5RmlsZSwgZml4ZWQpO1xuXG4gICAgLy8gU3RlcCA1OiBWZXJpZnkgZml4XG4gICAgY29uc3QgZml4ZWRDb250ZW50ID0gcmVhZEZpbGVTeW5jKGJ1Z2d5RmlsZSwgJ3V0Zi04Jyk7XG4gICAgZXhwZWN0KGZpeGVkQ29udGVudCkudG9Db250YWluKCdtdWx0aXBseShhOiBudW1iZXIsIGI6IG51bWJlcik6IG51bWJlcicpO1xuICAgIGV4cGVjdChmaXhlZENvbnRlbnQpLm5vdC50b0NvbnRhaW4oJy50b1N0cmluZygpJyk7XG4gIH0pO1xuXG4gIHRlc3QoJ0ZlYXR1cmUgaW1wbGVtZW50YXRpb24gd29ya2Zsb3cnLCAoKSA9PiB7XG4gICAgLy8gV29ya2Zsb3c6IFBsYW4g4oaSIFJlYWQg4oaSIFdyaXRlIOKGkiBFZGl0IOKGkiBUZXN0XG4gICAgLy8gU2ltdWxhdGVzOiBcIkFkZCBhIG5ldyBmZWF0dXJlIHdpdGggdGVzdHNcIlxuXG4gICAgY29uc3Qgc3JjRGlyID0gam9pbih0ZXN0V29ya3NwYWNlLCAnc3JjJyk7XG4gICAgY29uc3QgdGVzdERpciA9IGpvaW4odGVzdFdvcmtzcGFjZSwgJ3Rlc3QnKTtcbiAgICBta2RpclN5bmMoc3JjRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICBta2RpclN5bmModGVzdERpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG5cbiAgICAvLyBTdGVwIDE6IFBsYW4gKHNpbXVsYXRlZCB0b2RvIGxpc3QpXG4gICAgY29uc3QgcGxhbiA9IFtcbiAgICAgICdDcmVhdGUgVXNlclNlcnZpY2UgY2xhc3MnLFxuICAgICAgJ0FkZCBnZXRVc2VyIG1ldGhvZCcsXG4gICAgICAnQWRkIGNyZWF0ZVVzZXIgbWV0aG9kJyxcbiAgICAgICdXcml0ZSB1bml0IHRlc3RzJyxcbiAgICBdO1xuICAgIGV4cGVjdChwbGFuKS50b0hhdmVMZW5ndGgoNCk7XG5cbiAgICAvLyBTdGVwIDI6IFdyaXRlIG5ldyBmaWxlXG4gICAgY29uc3Qgc2VydmljZUZpbGUgPSBqb2luKHNyY0RpciwgJ1VzZXJTZXJ2aWNlLnRzJyk7XG4gICAgd3JpdGVGaWxlU3luYyhzZXJ2aWNlRmlsZSwgYFxuZXhwb3J0IGludGVyZmFjZSBVc2VyIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgVXNlclNlcnZpY2Uge1xuICBwcml2YXRlIHVzZXJzOiBNYXA8c3RyaW5nLCBVc2VyPiA9IG5ldyBNYXAoKTtcblxuICBnZXRVc2VyKGlkOiBzdHJpbmcpOiBVc2VyIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy51c2Vycy5nZXQoaWQpO1xuICB9XG5cbiAgY3JlYXRlVXNlcihuYW1lOiBzdHJpbmcsIGVtYWlsOiBzdHJpbmcpOiBVc2VyIHtcbiAgICBjb25zdCBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KTtcbiAgICBjb25zdCB1c2VyOiBVc2VyID0geyBpZCwgbmFtZSwgZW1haWwgfTtcbiAgICB0aGlzLnVzZXJzLnNldChpZCwgdXNlcik7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbn1cbmAudHJpbSgpKTtcblxuICAgIGV4cGVjdChleGlzdHNTeW5jKHNlcnZpY2VGaWxlKSkudG9CZSh0cnVlKTtcblxuICAgIC8vIFN0ZXAgMzogV3JpdGUgdGVzdHNcbiAgICBjb25zdCB0ZXN0RmlsZVBhdGggPSBqb2luKHRlc3REaXIsICdVc2VyU2VydmljZS50ZXN0LnRzJyk7XG4gICAgd3JpdGVGaWxlU3luYyh0ZXN0RmlsZVBhdGgsIGBcbmltcG9ydCB7IFVzZXJTZXJ2aWNlIH0gZnJvbSAnLi4vc3JjL1VzZXJTZXJ2aWNlJztcblxuZGVzY3JpYmUoJ1VzZXJTZXJ2aWNlJywgKCkgPT4ge1xuICB0ZXN0KCdzaG91bGQgY3JlYXRlIGFuZCByZXRyaWV2ZSB1c2VyJywgKCkgPT4ge1xuICAgIGNvbnN0IHNlcnZpY2UgPSBuZXcgVXNlclNlcnZpY2UoKTtcbiAgICBjb25zdCB1c2VyID0gc2VydmljZS5jcmVhdGVVc2VyKCdBbGljZScsICdhbGljZUBleGFtcGxlLmNvbScpO1xuXG4gICAgZXhwZWN0KHVzZXIubmFtZSkudG9CZSgnQWxpY2UnKTtcbiAgICBleHBlY3QodXNlci5lbWFpbCkudG9CZSgnYWxpY2VAZXhhbXBsZS5jb20nKTtcbiAgICBleHBlY3QodXNlci5pZCkudG9CZVRydXRoeSgpO1xuXG4gICAgY29uc3QgcmV0cmlldmVkID0gc2VydmljZS5nZXRVc2VyKHVzZXIuaWQpO1xuICAgIGV4cGVjdChyZXRyaWV2ZWQpLnRvRXF1YWwodXNlcik7XG4gIH0pO1xuXG4gIHRlc3QoJ3Nob3VsZCByZXR1cm4gdW5kZWZpbmVkIGZvciBub24tZXhpc3RlbnQgdXNlcicsICgpID0+IHtcbiAgICBjb25zdCBzZXJ2aWNlID0gbmV3IFVzZXJTZXJ2aWNlKCk7XG4gICAgY29uc3QgdXNlciA9IHNlcnZpY2UuZ2V0VXNlcignbm9uZXhpc3RlbnQnKTtcbiAgICBleHBlY3QodXNlcikudG9CZVVuZGVmaW5lZCgpO1xuICB9KTtcbn0pO1xuYC50cmltKCkpO1xuXG4gICAgZXhwZWN0KGV4aXN0c1N5bmModGVzdEZpbGVQYXRoKSkudG9CZSh0cnVlKTtcblxuICAgIC8vIFN0ZXAgNDogUmVhZCBiYWNrIGFuZCB2ZXJpZnlcbiAgICBjb25zdCBzZXJ2aWNlQ29udGVudCA9IHJlYWRGaWxlU3luYyhzZXJ2aWNlRmlsZSwgJ3V0Zi04Jyk7XG4gICAgY29uc3QgdGVzdENvbnRlbnQgPSByZWFkRmlsZVN5bmModGVzdEZpbGVQYXRoLCAndXRmLTgnKTtcblxuICAgIGV4cGVjdChzZXJ2aWNlQ29udGVudCkudG9Db250YWluKCdjbGFzcyBVc2VyU2VydmljZScpO1xuICAgIGV4cGVjdChzZXJ2aWNlQ29udGVudCkudG9Db250YWluKCdnZXRVc2VyJyk7XG4gICAgZXhwZWN0KHNlcnZpY2VDb250ZW50KS50b0NvbnRhaW4oJ2NyZWF0ZVVzZXInKTtcbiAgICBleHBlY3QodGVzdENvbnRlbnQpLnRvQ29udGFpbignZGVzY3JpYmUoXFwnVXNlclNlcnZpY2VcXCcnKTtcbiAgICBleHBlY3QodGVzdENvbnRlbnQpLnRvQ29udGFpbignc2hvdWxkIGNyZWF0ZSBhbmQgcmV0cmlldmUgdXNlcicpO1xuICB9KTtcblxuICB0ZXN0KCdEb2N1bWVudGF0aW9uIGdlbmVyYXRpb24gd29ya2Zsb3cnLCAoKSA9PiB7XG4gICAgLy8gV29ya2Zsb3c6IEV4cGxvcmUg4oaSIFJlYWQg4oaSIEFuYWx5emUg4oaSIFdyaXRlXG4gICAgLy8gU2ltdWxhdGVzOiBcIkdlbmVyYXRlIFJFQURNRSBmcm9tIHNvdXJjZSBmaWxlc1wiXG5cbiAgICBjb25zdCBzcmNEaXIgPSBqb2luKHRlc3RXb3Jrc3BhY2UsICdzcmMnKTtcbiAgICBta2RpclN5bmMoc3JjRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcblxuICAgIC8vIENyZWF0ZSBzb3VyY2UgZmlsZXNcbiAgICBjb25zdCBhcGkgPSBqb2luKHNyY0RpciwgJ2FwaS50cycpO1xuICAgIHdyaXRlRmlsZVN5bmMoYXBpLCBgXG4vKipcbiAqIE1haW4gQVBJIGNsaWVudCBmb3IgdGhlIHNlcnZpY2VcbiAqL1xuZXhwb3J0IGNsYXNzIEFwaUNsaWVudCB7XG4gIC8qKlxuICAgKiBGZXRjaCBkYXRhIGZyb20gdGhlIEFQSVxuICAgKiBAcGFyYW0gZW5kcG9pbnQgVGhlIEFQSSBlbmRwb2ludFxuICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggdGhlIHJlc3BvbnNlIGRhdGFcbiAgICovXG4gIGFzeW5jIGZldGNoKGVuZHBvaW50OiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIC8vIEltcGxlbWVudGF0aW9uXG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5gLnRyaW0oKSk7XG5cbiAgICBjb25zdCB1dGlscyA9IGpvaW4oc3JjRGlyLCAndXRpbHMudHMnKTtcbiAgICB3cml0ZUZpbGVTeW5jKHV0aWxzLCBgXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBGb3JtYXQgYSBkYXRlIHN0cmluZ1xuICogQHBhcmFtIGRhdGUgVGhlIGRhdGUgdG8gZm9ybWF0XG4gKiBAcmV0dXJucyBGb3JtYXR0ZWQgZGF0ZSBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZTogRGF0ZSk6IHN0cmluZyB7XG4gIHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCk7XG59XG5gLnRyaW0oKSk7XG5cbiAgICAvLyBTdGVwIDE6IEV4cGxvcmUgLSBmaW5kIGFsbCBzb3VyY2UgZmlsZXNcbiAgICBjb25zdCBzb3VyY2VGaWxlcyA9IFthcGksIHV0aWxzXTtcbiAgICBleHBlY3Qoc291cmNlRmlsZXMpLnRvSGF2ZUxlbmd0aCgyKTtcblxuICAgIC8vIFN0ZXAgMjogUmVhZCBhbmQgZXh0cmFjdCBkb2N1bWVudGF0aW9uXG4gICAgY29uc3QgYXBpQ29udGVudCA9IHJlYWRGaWxlU3luYyhhcGksICd1dGYtOCcpO1xuICAgIGNvbnN0IHV0aWxzQ29udGVudCA9IHJlYWRGaWxlU3luYyh1dGlscywgJ3V0Zi04Jyk7XG5cbiAgICBjb25zdCBhcGlEb2NzID0gYXBpQ29udGVudC5tYXRjaCgvXFwvXFwqXFwqW1xcc1xcU10qP1xcKlxcLy9nKSB8fCBbXTtcbiAgICBjb25zdCB1dGlsc0RvY3MgPSB1dGlsc0NvbnRlbnQubWF0Y2goL1xcL1xcKlxcKltcXHNcXFNdKj9cXCpcXC8vZykgfHwgW107XG5cbiAgICBleHBlY3QoYXBpRG9jcy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICBleHBlY3QodXRpbHNEb2NzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuXG4gICAgLy8gU3RlcCAzOiBHZW5lcmF0ZSBSRUFETUVcbiAgICBjb25zdCByZWFkbWUgPSBqb2luKHRlc3RXb3Jrc3BhY2UsICdSRUFETUUubWQnKTtcbiAgICB3cml0ZUZpbGVTeW5jKHJlYWRtZSwgYFxuIyBQcm9qZWN0IERvY3VtZW50YXRpb25cblxuIyMgQVBJIENsaWVudFxuXG5NYWluIEFQSSBjbGllbnQgZm9yIHRoZSBzZXJ2aWNlLlxuXG4jIyMgTWV0aG9kc1xuXG4tIFxcYGZldGNoKGVuZHBvaW50OiBzdHJpbmcpXFxgIC0gRmV0Y2ggZGF0YSBmcm9tIHRoZSBBUElcblxuIyMgVXRpbGl0aWVzXG5cbiMjIyBGdW5jdGlvbnNcblxuLSBcXGBmb3JtYXREYXRlKGRhdGU6IERhdGUpXFxgIC0gRm9ybWF0IGEgZGF0ZSBzdHJpbmdcblxuYC50cmltKCkpO1xuXG4gICAgLy8gU3RlcCA0OiBWZXJpZnkgUkVBRE1FIGV4aXN0cyBhbmQgaGFzIGNvbnRlbnRcbiAgICBjb25zdCByZWFkbWVDb250ZW50ID0gcmVhZEZpbGVTeW5jKHJlYWRtZSwgJ3V0Zi04Jyk7XG4gICAgZXhwZWN0KHJlYWRtZUNvbnRlbnQpLnRvQ29udGFpbignQVBJIENsaWVudCcpO1xuICAgIGV4cGVjdChyZWFkbWVDb250ZW50KS50b0NvbnRhaW4oJ1V0aWxpdGllcycpO1xuICAgIGV4cGVjdChyZWFkbWVDb250ZW50KS50b0NvbnRhaW4oJ2ZldGNoJyk7XG4gICAgZXhwZWN0KHJlYWRtZUNvbnRlbnQpLnRvQ29udGFpbignZm9ybWF0RGF0ZScpO1xuICB9KTtcblxuICB0ZXN0KCdDb2RlIHF1YWxpdHkgaW1wcm92ZW1lbnQgd29ya2Zsb3cnLCAoKSA9PiB7XG4gICAgLy8gV29ya2Zsb3c6IEFuYWx5emUg4oaSIElkZW50aWZ5IElzc3VlcyDihpIgRml4IOKGkiBWZXJpZnlcbiAgICAvLyBTaW11bGF0ZXM6IFwiRmluZCBhbmQgZml4IGNvZGUgcXVhbGl0eSBpc3N1ZXNcIlxuXG4gICAgY29uc3Qgc3JjRGlyID0gam9pbih0ZXN0V29ya3NwYWNlLCAnc3JjJyk7XG4gICAgbWtkaXJTeW5jKHNyY0RpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG5cbiAgICAvLyBDcmVhdGUgZmlsZSB3aXRoIHF1YWxpdHkgaXNzdWVzXG4gICAgY29uc3QgbWVzc3lGaWxlID0gam9pbihzcmNEaXIsICdtZXNzeS50cycpO1xuICAgIHdyaXRlRmlsZVN5bmMobWVzc3lGaWxlLCBgXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0RhdGEoZGF0YTogYW55KTogYW55IHtcbiAgLy8gVE9ETzogQWRkIHByb3BlciB0eXBlc1xuICB2YXIgcmVzdWx0ID0gW107ICAvLyBVc2UgY29uc3QgaW5zdGVhZCBvZiB2YXJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7ICAvLyBVc2UgZm9yLW9mIGluc3RlYWRcbiAgICBpZiAoZGF0YVtpXSAhPSBudWxsKSB7ICAvLyBVc2UgIT09IGluc3RlYWQgb2YgIT1cbiAgICAgIHJlc3VsdC5wdXNoKGRhdGFbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuYC50cmltKCkpO1xuXG4gICAgLy8gU3RlcCAxOiBBbmFseXplIC0gZGV0ZWN0IGlzc3Vlc1xuICAgIGNvbnN0IGNvbnRlbnQgPSByZWFkRmlsZVN5bmMobWVzc3lGaWxlLCAndXRmLTgnKTtcbiAgICBjb25zdCBpc3N1ZXMgPSBbXG4gICAgICAnTGluZSAxOiBVc2luZyBcImFueVwiIHR5cGUnLFxuICAgICAgJ0xpbmUgMzogVXNpbmcgXCJ2YXJcIiBpbnN0ZWFkIG9mIFwiY29uc3RcIicsXG4gICAgICAnTGluZSA0OiBVc2luZyBmb3IgbG9vcCBpbnN0ZWFkIG9mIGZvci1vZicsXG4gICAgICAnTGluZSA1OiBVc2luZyAhPSBpbnN0ZWFkIG9mICE9PScsXG4gICAgXTtcbiAgICBleHBlY3QoaXNzdWVzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuXG4gICAgLy8gU3RlcCAyOiBGaXggaXNzdWVzXG4gICAgY29uc3QgaW1wcm92ZWQgPSBgXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0RhdGEoZGF0YTogdW5rbm93bltdKTogdW5rbm93bltdIHtcbiAgY29uc3QgcmVzdWx0OiB1bmtub3duW10gPSBbXTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIGRhdGEpIHtcbiAgICBpZiAoaXRlbSAhPT0gbnVsbCAmJiBpdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuYC50cmltKCk7XG5cbiAgICB3cml0ZUZpbGVTeW5jKG1lc3N5RmlsZSwgaW1wcm92ZWQpO1xuXG4gICAgLy8gU3RlcCAzOiBWZXJpZnkgaW1wcm92ZW1lbnRzXG4gICAgY29uc3QgZml4ZWRDb250ZW50ID0gcmVhZEZpbGVTeW5jKG1lc3N5RmlsZSwgJ3V0Zi04Jyk7XG4gICAgZXhwZWN0KGZpeGVkQ29udGVudCkubm90LnRvQ29udGFpbignYW55Jyk7XG4gICAgZXhwZWN0KGZpeGVkQ29udGVudCkubm90LnRvQ29udGFpbigndmFyICcpO1xuICAgIGV4cGVjdChmaXhlZENvbnRlbnQpLnRvQ29udGFpbignY29uc3QnKTtcbiAgICBleHBlY3QoZml4ZWRDb250ZW50KS50b0NvbnRhaW4oJyE9PScpO1xuICAgIGV4cGVjdChmaXhlZENvbnRlbnQpLnRvQ29udGFpbignZm9yIChjb25zdCcpO1xuICB9KTtcblxuICB0ZXN0KCdEZXBlbmRlbmN5IHVwZGF0ZSB3b3JrZmxvdycsICgpID0+IHtcbiAgICAvLyBXb3JrZmxvdzogQ2hlY2sgRGVwZW5kZW5jaWVzIOKGkiBSZWFkIENoYW5nZWxvZyDihpIgVXBkYXRlIOKGkiBUZXN0XG4gICAgLy8gU2ltdWxhdGVzOiBcIlVwZGF0ZSBkZXBlbmRlbmNpZXMgc2FmZWx5XCJcblxuICAgIGNvbnN0IHBhY2thZ2VKc29uID0gam9pbih0ZXN0V29ya3NwYWNlLCAncGFja2FnZS5qc29uJyk7XG4gICAgd3JpdGVGaWxlU3luYyhwYWNrYWdlSnNvbiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgbmFtZTogJ3Rlc3QtcHJvamVjdCcsXG4gICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxuICAgICAgZGVwZW5kZW5jaWVzOiB7XG4gICAgICAgICdvbGQtbGliJzogJ14xLjAuMCcsXG4gICAgICB9LFxuICAgICAgZGV2RGVwZW5kZW5jaWVzOiB7XG4gICAgICAgICd0ZXN0LWxpYic6ICdeMi4wLjAnLFxuICAgICAgfSxcbiAgICB9LCBudWxsLCAyKSk7XG5cbiAgICAvLyBTdGVwIDE6IFJlYWQgY3VycmVudCBkZXBlbmRlbmNpZXNcbiAgICBjb25zdCBwa2dDb250ZW50ID0gSlNPTi5wYXJzZShyZWFkRmlsZVN5bmMocGFja2FnZUpzb24sICd1dGYtOCcpKTtcbiAgICBleHBlY3QocGtnQ29udGVudC5kZXBlbmRlbmNpZXNbJ29sZC1saWInXSkudG9CZSgnXjEuMC4wJyk7XG5cbiAgICAvLyBTdGVwIDI6IFVwZGF0ZSB2ZXJzaW9ucyAoc2ltdWxhdGVkKVxuICAgIHBrZ0NvbnRlbnQuZGVwZW5kZW5jaWVzWydvbGQtbGliJ10gPSAnXjIuMC4wJztcbiAgICBwa2dDb250ZW50LmRldkRlcGVuZGVuY2llc1sndGVzdC1saWInXSA9ICdeMy4wLjAnO1xuXG4gICAgd3JpdGVGaWxlU3luYyhwYWNrYWdlSnNvbiwgSlNPTi5zdHJpbmdpZnkocGtnQ29udGVudCwgbnVsbCwgMikpO1xuXG4gICAgLy8gU3RlcCAzOiBWZXJpZnkgdXBkYXRlc1xuICAgIGNvbnN0IHVwZGF0ZWQgPSBKU09OLnBhcnNlKHJlYWRGaWxlU3luYyhwYWNrYWdlSnNvbiwgJ3V0Zi04JykpO1xuICAgIGV4cGVjdCh1cGRhdGVkLmRlcGVuZGVuY2llc1snb2xkLWxpYiddKS50b0JlKCdeMi4wLjAnKTtcbiAgICBleHBlY3QodXBkYXRlZC5kZXZEZXBlbmRlbmNpZXNbJ3Rlc3QtbGliJ10pLnRvQmUoJ14zLjAuMCcpO1xuICB9KTtcblxuICB0ZXN0KCdFcnJvciByZWNvdmVyeSBhbmQgcmV0cnkgd29ya2Zsb3cnLCAoKSA9PiB7XG4gICAgLy8gV29ya2Zsb3c6IEF0dGVtcHQg4oaSIEZhaWwg4oaSIEFuYWx5emUg4oaSIEZpeCDihpIgUmV0cnlcbiAgICAvLyBTaW11bGF0ZXM6IFwiSGFuZGxlIGFuZCByZWNvdmVyIGZyb20gZXJyb3JzIGdyYWNlZnVsbHlcIlxuXG4gICAgY29uc3QgdGVzdEZpbGUgPSBqb2luKHRlc3RXb3Jrc3BhY2UsICdjb25maWcuanNvbicpO1xuXG4gICAgLy8gU3RlcCAxOiBBdHRlbXB0IHRvIHJlYWQgbm9uLWV4aXN0ZW50IGZpbGVcbiAgICBsZXQgY29udGVudDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IGVycm9yOiBFcnJvciB8IG51bGwgPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnRlbnQgPSByZWFkRmlsZVN5bmModGVzdEZpbGUsICd1dGYtOCcpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyb3IgPSBlcnIgYXMgRXJyb3I7XG4gICAgfVxuXG4gICAgZXhwZWN0KGNvbnRlbnQpLnRvQmVOdWxsKCk7XG4gICAgZXhwZWN0KGVycm9yKS5ub3QudG9CZU51bGwoKTtcbiAgICBleHBlY3QoZXJyb3I/Lm1lc3NhZ2UpLnRvQ29udGFpbignRU5PRU5UJyk7XG5cbiAgICAvLyBTdGVwIDI6IEFuYWx5emUgZXJyb3IgLSBmaWxlIGRvZXNuJ3QgZXhpc3RcbiAgICBjb25zdCBmaWxlRXhpc3RzID0gZXhpc3RzU3luYyh0ZXN0RmlsZSk7XG4gICAgZXhwZWN0KGZpbGVFeGlzdHMpLnRvQmUoZmFsc2UpO1xuXG4gICAgLy8gU3RlcCAzOiBGaXggLSBjcmVhdGUgdGhlIGZpbGVcbiAgICB3cml0ZUZpbGVTeW5jKHRlc3RGaWxlLCBKU09OLnN0cmluZ2lmeSh7IHNldHRpbmc6ICd2YWx1ZScgfSwgbnVsbCwgMikpO1xuXG4gICAgLy8gU3RlcCA0OiBSZXRyeSAtIHNob3VsZCBzdWNjZWVkIG5vd1xuICAgIGNvbnRlbnQgPSBudWxsO1xuICAgIGVycm9yID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICBjb250ZW50ID0gcmVhZEZpbGVTeW5jKHRlc3RGaWxlLCAndXRmLTgnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVycm9yID0gZXJyIGFzIEVycm9yO1xuICAgIH1cblxuICAgIGV4cGVjdChjb250ZW50KS5ub3QudG9CZU51bGwoKTtcbiAgICBleHBlY3QoZXJyb3IpLnRvQmVOdWxsKCk7XG4gICAgZXhwZWN0KEpTT04ucGFyc2UoY29udGVudCEpKS50b0VxdWFsKHsgc2V0dGluZzogJ3ZhbHVlJyB9KTtcbiAgfSk7XG5cbiAgdGVzdCgnQ29uY3VycmVudCBmaWxlIG9wZXJhdGlvbnMgd29ya2Zsb3cnLCBhc3luYyAoKSA9PiB7XG4gICAgLy8gV29ya2Zsb3c6IE11bHRpcGxlIHBhcmFsbGVsIG9wZXJhdGlvbnNcbiAgICAvLyBTaW11bGF0ZXM6IFwiUHJvY2VzcyBtdWx0aXBsZSBmaWxlcyBjb25jdXJyZW50bHlcIlxuXG4gICAgY29uc3QgZmlsZXMgPSBbJ2ZpbGUxLnR4dCcsICdmaWxlMi50eHQnLCAnZmlsZTMudHh0JywgJ2ZpbGU0LnR4dCddO1xuICAgIGNvbnN0IG9wZXJhdGlvbnM6IFByb21pc2U8dm9pZD5bXSA9IGZpbGVzLm1hcCgoZmlsZW5hbWUsIGluZGV4KSA9PlxuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGVwYXRoID0gam9pbih0ZXN0V29ya3NwYWNlLCBmaWxlbmFtZSk7XG4gICAgICAgIHdyaXRlRmlsZVN5bmMoZmlsZXBhdGgsIGBDb250ZW50IGZvciBmaWxlICR7aW5kZXggKyAxfWApO1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgLy8gV2FpdCBmb3IgYWxsIHdyaXRlcyB0byBjb21wbGV0ZVxuICAgIGF3YWl0IFByb21pc2UuYWxsKG9wZXJhdGlvbnMpO1xuXG4gICAgLy8gU3RlcCAyOiBSZWFkIGFsbCBmaWxlcyBjb25jdXJyZW50bHlcbiAgICBjb25zdCBjb250ZW50cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgZmlsZXMubWFwKGZpbGVuYW1lID0+XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZpbGVwYXRoID0gam9pbih0ZXN0V29ya3NwYWNlLCBmaWxlbmFtZSk7XG4gICAgICAgICAgcmV0dXJuIHJlYWRGaWxlU3luYyhmaWxlcGF0aCwgJ3V0Zi04Jyk7XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKTtcblxuICAgIC8vIFN0ZXAgMzogVmVyaWZ5IGFsbCBmaWxlcyB3ZXJlIHdyaXR0ZW4gY29ycmVjdGx5XG4gICAgZXhwZWN0KGNvbnRlbnRzKS50b0hhdmVMZW5ndGgoZmlsZXMubGVuZ3RoKTtcbiAgICBjb250ZW50cy5mb3JFYWNoKChjb250ZW50LCBpbmRleCkgPT4ge1xuICAgICAgZXhwZWN0KGNvbnRlbnQpLnRvQmUo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