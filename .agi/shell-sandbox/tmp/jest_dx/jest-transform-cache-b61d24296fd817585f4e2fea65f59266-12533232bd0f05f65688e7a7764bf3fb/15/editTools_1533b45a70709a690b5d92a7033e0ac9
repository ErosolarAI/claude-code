69f7a89744059d24db9102cb14cf1e17
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createEditTools = createEditTools;
exports.performSurgicalEdit = performSurgicalEdit;
var _promises = require("node:fs/promises");
var _nodePath = require("node:path");
var _errors = require("../core/errors.js");
var _diffUtils = require("./diffUtils.js");
/**
 * Track edit attempts per file to detect when edits keep being reverted (e.g., by linters/hooks)
 */
const fileEditAttempts = new Map();
const MAX_EDIT_ATTEMPTS_PER_FILE = 3;
const EDIT_ATTEMPT_RESET_MS = 60000; // Reset counter after 1 minute of no edits

/**
 * Creates the Edit tool for surgical file modifications using exact string replacement.
 *
 * This tool performs string-based edits without requiring full file rewrites,
 * making it ideal for targeted changes while preserving exact formatting and indentation.
 *
 * Features:
 * - Exact string matching (preserves indentation)
 * - Replace all occurrences or enforce uniqueness
 * - Unified diff preview
 * - Validation before writing
 *
 * @param workingDir - The working directory for resolving relative paths
 * @returns Array containing the Edit tool definition
 */
function createEditTools(workingDir) {
  return [{
    name: 'Edit',
    description: 'Performs exact string replacements in files. CRITICAL: For existing files, you MUST use the Read tool FIRST to get the exact text including whitespace and indentation, then copy it into old_string. The edit will FAIL if old_string is not unique unless replace_all is true. To CREATE a new file, use empty old_string (no prior read needed). To DELETE text, use empty new_string.',
    parameters: {
      type: 'object',
      properties: {
        file_path: {
          type: 'string',
          description: 'The absolute path to the file to modify or create'
        },
        old_string: {
          type: 'string',
          description: 'The exact text to replace (must match precisely including whitespace and indentation). For existing files, use read_file FIRST, then copy the exact text from its output (excluding line numbers). Use empty string "" to create a new file without needing a prior read.'
        },
        new_string: {
          type: 'string',
          default: '',
          description: 'The text to replace it with. Use empty string "" to delete the old_string. For new files, this is the full content. Defaults to "" when omitted.'
        },
        replace_all: {
          type: 'boolean',
          description: 'Replace all occurrences of old_string (default false). When false, the edit fails if old_string appears multiple times.'
        }
      },
      required: ['file_path', 'old_string'],
      additionalProperties: false
    },
    handler: async args => performSurgicalEdit(workingDir, args)
  }];
}
/**
 * Shared edit executor used by both legacy and unified tool flows.
 * Provides consistent validation, creation/deletion handling, and diff output.
 */
async function performSurgicalEdit(workingDir, args) {
  const pathArg = args['file_path'];
  const oldString = args['old_string'];
  const newStringRaw = args['new_string'];
  const replaceAll = args['replace_all'] === true;
  let replacementString = typeof newStringRaw === 'string' ? newStringRaw : '';

  // Validate inputs
  if (typeof pathArg !== 'string' || !pathArg.trim()) {
    return 'Error: file_path must be a non-empty string.';
  }
  if (typeof oldString !== 'string') {
    return 'Error: old_string must be a string (use "" for empty).';
  }
  if (newStringRaw !== undefined && typeof newStringRaw !== 'string') {
    return 'Error: new_string must be a string (use "" for empty).';
  }
  // Only error if both are identical AND non-empty (no-op edit)
  // Allow: empty old + content = create, content + empty new = delete
  if (oldString === replacementString && oldString !== '') {
    return 'Error: old_string and new_string are identical. No changes would be made.';
  }
  // Both empty is also a no-op
  if (oldString === '' && replacementString === '') {
    return 'Error: Both old_string and new_string are empty. Provide content to create a file or text to replace.';
  }
  try {
    const filePath = resolveFilePath(workingDir, pathArg);

    // Check if file exists
    let fileExists = false;
    try {
      await (0, _promises.stat)(filePath);
      fileExists = true;
    } catch {
      fileExists = false;
    }

    // Handle file creation mode (empty old_string)
    if (oldString === '') {
      if (fileExists) {
        return `Error: File already exists: ${filePath}\nTo modify an existing file, provide the exact text to replace in old_string.`;
      }

      // Create parent directories if needed
      const dir = (0, _nodePath.dirname)(filePath);
      await (0, _promises.mkdir)(dir, {
        recursive: true
      });

      // Write new file
      await (0, _promises.writeFile)(filePath, replacementString, 'utf-8');
      const relativePath = (0, _nodePath.relative)(workingDir, filePath);
      const displayPath = relativePath && !relativePath.startsWith('..') ? relativePath : filePath;
      const lineCount = replacementString.split('\n').length;
      const diffSegments = (0, _diffUtils.buildDiffSegmentsFast)('', replacementString);
      const addedLines = diffSegments.filter(s => s.type === 'added').length;
      const diffLines = (0, _diffUtils.formatDiffLines)(diffSegments, true);
      const diffBlock = diffLines.length > 0 ? diffLines.join('\n') : '(No visual diff - whitespace or formatting changes only)';
      return [`⏺ Create(${displayPath})`, `  ⎿  Created ${displayPath} with ${addedLines} additions`, `     ${lineCount} line${lineCount === 1 ? '' : 's'} written`, diffBlock].join('\n');
    }

    // For modifications, file must exist
    if (!fileExists) {
      return `Error: File not found: ${filePath}\nTo create a new file, use empty old_string ("").`;
    }

    // Read current content (async for speed)
    const currentContent = await (0, _promises.readFile)(filePath, 'utf-8');

    // Normalize escaped literals and whitespace differences to reduce mismatch errors
    let targetString = oldString;
    let matchNote = null;
    if (!currentContent.includes(targetString)) {
      const unescaped = unescapeLiteral(oldString);
      if (unescaped !== oldString && currentContent.includes(unescaped)) {
        targetString = unescaped;
        matchNote = 'normalized escaped old_string';
      }
    }
    if (!currentContent.includes(targetString)) {
      const flexibleMatch = matchWithFlexibleWhitespace(currentContent, targetString);
      if (flexibleMatch) {
        targetString = flexibleMatch;
        matchNote = matchNote ? matchNote : 'normalized whitespace in old_string';
      }
    }

    // Check if old_string exists in file
    if (!currentContent.includes(targetString)) {
      // Provide helpful debugging info when match fails
      const firstLine = oldString.split('\n')[0] || '';
      const suggestions = findSimilarLinesWithSuggestion(currentContent, firstLine, oldString, filePath, workingDir);

      // AI Flow Design: Provide structured guidance for self-correction
      const aiGuidance = buildAIRecoveryGuidance(oldString, currentContent);
      return ['Error: old_string not found in file.', '', `File: ${filePath}`, `Searching for: ${JSON.stringify(firstLine.substring(0, 80))}${firstLine.length > 80 ? '...' : ''}`, '', suggestions.hints, '', suggestions.actionable ? 'RECOMMENDED ACTION:' : 'Guidance:', suggestions.actionable ? suggestions.actionable : '- Ensure exact whitespace/indentation matches\n- Copy text directly from Read output\n- Check for tabs vs spaces', '', '---', 'AI SELF-CORRECTION GUIDANCE:', aiGuidance].join('\n');
    }

    // Count occurrences
    // Preserve indentation when we had to normalize whitespace to find the match
    if (matchNote === 'normalized whitespace in old_string') {
      const adjusted = alignIndentation(targetString, replacementString);
      if (adjusted !== replacementString) {
        replacementString = adjusted;
      }
    }
    const occurrences = countOccurrences(currentContent, targetString);
    if (!replaceAll && occurrences > 1) {
      return `Error: old_string appears ${occurrences} times in the file. Either:\n1. Provide a larger unique string that includes more context\n2. Set replace_all: true to replace all ${occurrences} occurrences\n\nFile: ${filePath}`;
    }

    // Perform replacement
    const newContent = replaceAll ? currentContent.split(targetString).join(replacementString) : currentContent.replace(targetString, replacementString);

    // Generate diff with context lines (AGI CLI style)
    const diffResult = (0, _diffUtils.buildDiffWithContext)(currentContent, newContent, 2);

    // Check for repeated edit attempts on same file (detect linter/hook reversion loops)
    const now = Date.now();
    const attempts = fileEditAttempts.get(filePath);
    if (attempts) {
      // Reset if enough time has passed
      if (now - attempts.lastTimestamp > EDIT_ATTEMPT_RESET_MS) {
        fileEditAttempts.set(filePath, {
          count: 1,
          lastContent: newContent,
          lastTimestamp: now
        });
      } else if (attempts.lastContent === newContent) {
        // Same exact edit being attempted again - likely in a loop
        attempts.count++;
        attempts.lastTimestamp = now;
        if (attempts.count > MAX_EDIT_ATTEMPTS_PER_FILE) {
          return [`Error: Edit loop detected on ${filePath}`, '', `This edit has been attempted ${attempts.count} times in quick succession.`, 'The file may be getting reverted by a linter, formatter, or pre-commit hook.', '', 'To resolve:', '1. Check for active file watchers or formatters', '2. Disable auto-formatting temporarily', '3. Or accept the current file state and move on', '', 'STOPPING to prevent infinite loop.'].join('\n');
        }
      } else {
        // Different edit - reset counter but track the new content
        fileEditAttempts.set(filePath, {
          count: 1,
          lastContent: newContent,
          lastTimestamp: now
        });
      }
    } else {
      fileEditAttempts.set(filePath, {
        count: 1,
        lastContent: newContent,
        lastTimestamp: now
      });
    }

    // Write file (async for speed)
    await (0, _promises.writeFile)(filePath, newContent, 'utf-8');

    // Verify the edit persisted (detect immediate reversion by hooks/watchers)
    // Small delay to allow any file watchers to trigger
    await new Promise(resolve => setTimeout(resolve, 50));
    const verifyContent = await (0, _promises.readFile)(filePath, 'utf-8');
    if (verifyContent !== newContent) {
      // File was modified after our write - likely by a linter/formatter
      const editAttempts = fileEditAttempts.get(filePath);
      if (editAttempts) {
        editAttempts.count++;
      }
      return [`Warning: Edit was immediately modified by an external process.`, '', `File: ${filePath}`, 'The edit was written but the file content changed immediately after.', 'This is likely caused by a linter, formatter, or file watcher.', '', 'The current file state may differ from the intended edit.', 'Consider disabling auto-formatting or accepting the modified result.'].join('\n');
    }

    // Build summary (AGI CLI style)
    const relativePath = (0, _nodePath.relative)(workingDir, filePath);
    const displayPath = relativePath && !relativePath.startsWith('..') ? relativePath : filePath;
    const {
      additions,
      removals
    } = diffResult;
    const occurrencesText = replaceAll ? ` (${occurrences} occurrence${occurrences > 1 ? 's' : ''})` : '';
    const noteText = matchNote ? ` [${matchNote}]` : '';

    // Format diff with colors for terminal display (AGI CLI style)
    const diffLines = (0, _diffUtils.formatDiffClaudeStyle)(diffResult.segments, true);
    const diffBlock = diffLines.length > 0 ? diffLines.join('\n') : '      (No visual diff - whitespace or formatting changes only)';

    // Build AGI CLI style output:
    // ⏺ Update(filepath)
    //   ⎿  Updated filepath with N additions and M removals
    //       41    }
    //       42 +   new line
    const additionText = additions === 1 ? '1 addition' : `${additions} additions`;
    const removalText = removals === 1 ? '1 removal' : `${removals} removals`;
    const summaryParts = [];
    if (additions > 0) summaryParts.push(additionText);
    if (removals > 0) summaryParts.push(removalText);
    const summaryText = summaryParts.length > 0 ? summaryParts.join(' and ') : 'no changes';
    return [`⏺ Update(${displayPath})${occurrencesText}${noteText}`, `  ⎿  Updated ${displayPath} with ${summaryText}`, diffBlock].join('\n');
  } catch (error) {
    return (0, _errors.buildError)('editing file', error, {
      file_path: typeof pathArg === 'string' ? pathArg : '',
      old_string_length: typeof oldString === 'string' ? oldString.length : 0,
      new_string_length: typeof replacementString === 'string' ? replacementString.length : 0
    });
  }
}
function resolveFilePath(workingDir, path) {
  const normalized = path.trim();
  return normalized.startsWith('/') ? normalized : (0, _nodePath.join)(workingDir, normalized);
}
function countOccurrences(text, search) {
  if (!search) return 0;
  let count = 0;
  let position = 0;
  while ((position = text.indexOf(search, position)) !== -1) {
    count++;
    position += search.length;
  }
  return count;
}

/**
 * Convert common escaped sequences (\\n, \\r, \\t, \\\\) into their literal forms.
 */
function unescapeLiteral(value) {
  if (!value.includes('\\')) return value;
  return value.replace(/\\\\/g, '\\').replace(/\\n/g, '\n').replace(/\\r/g, '\r').replace(/\\t/g, '\t');
}

/**
 * Try to locate the search string allowing whitespace differences (indentation, spacing).
 * Returns the exact substring from the original content when matched.
 */
function matchWithFlexibleWhitespace(content, search) {
  const normalizedPattern = buildWhitespaceFlexiblePattern(search);
  if (!normalizedPattern) {
    return null;
  }
  const regex = new RegExp(normalizedPattern, 's');
  const match = content.match(regex);
  return match ? match[0] : null;
}
function buildWhitespaceFlexiblePattern(search) {
  if (!search.trim()) {
    return null;
  }
  // Escape regex metacharacters
  const escaped = search.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  // Only allow flexible whitespace WITHIN lines, not across lines
  // This prevents matching across completely different code structures
  // Split by newlines, make each line flexible, then require exact newline boundaries
  const lines = escaped.split(/\\n|\n/);
  const flexibleLines = lines.map(line => line.replace(/[ \t]+/g, '[ \\t]+'));
  // Rejoin with flexible newline matching (allows \r\n or \n)
  return flexibleLines.join('\\r?\\n');
}

/**
 * When whitespace normalization is used, keep the replacement aligned with the matched indentation.
 * If a line in the replacement has no indentation, inherit indentation from the matched line.
 */
function alignIndentation(target, replacement) {
  const targetLines = target.split('\n');
  const replacementLines = replacement.split('\n');
  if (targetLines.length !== replacementLines.length) {
    return replacement;
  }
  const adjusted = replacementLines.map((line, idx) => {
    const targetLine = targetLines[idx] ?? '';
    const targetIndent = targetLine.match(/^\s*/)?.[0] ?? '';
    if (!line.trim()) {
      return targetIndent;
    }
    const lineIndent = line.match(/^\s*/)?.[0] ?? '';
    if (lineIndent.length < targetIndent.length) {
      const missing = targetIndent.slice(lineIndent.length);
      return `${lineIndent}${missing}${line.trimStart()}`;
    }
    return line;
  });
  return adjusted.join('\n');
}

/**
 * Enhanced similar line finder with actionable suggestions for AI.
 * Provides exact text to use in old_string and clear next steps.
 */
function findSimilarLinesWithSuggestion(content, searchFirstLine, _fullSearchText, filePath, workingDir) {
  const similarInfo = findSimilarLines(content, searchFirstLine, filePath);

  // Extract line numbers from similar lines
  const lineMatch = similarInfo.match(/Line (\d+)/);
  if (lineMatch && lineMatch[1]) {
    const lineNum = parseInt(lineMatch[1], 10);
    const relativePath = (0, _nodePath.relative)(workingDir, filePath);
    const displayPath = relativePath && !relativePath.startsWith('..') ? relativePath : filePath;

    // Provide concrete action: Read the file to get exact text
    const action = [`1. Use Read tool to view ${displayPath} starting at line ${Math.max(1, lineNum - 5)}`, `2. Copy the EXACT text from the Read output (including all indentation)`, `3. Use that exact text as old_string in your Edit call`, `4. Ensure you copy multiple lines if needed for uniqueness`].join('\n   ');
    return {
      hints: similarInfo,
      actionable: action
    };
  }

  // No similar lines found - suggest reading entire file
  const relativePath = (0, _nodePath.relative)(workingDir, filePath);
  const displayPath = relativePath && !relativePath.startsWith('..') ? relativePath : filePath;
  const action = [`1. Use Read tool to view the entire file: ${displayPath}`, `2. Locate the text you want to change`, `3. Copy the EXACT text including whitespace`, `4. Paste it as old_string in your Edit call`].join('\n   ');
  return {
    hints: similarInfo,
    actionable: action
  };
}

/**
 * Find lines in the file that are similar to the search text.
 * Enhanced with whitespace detection and auto-correction suggestions.
 */
function findSimilarLines(content, searchFirstLine, _filePath) {
  if (!searchFirstLine.trim()) {
    return 'The search string starts with an empty line.';
  }
  const lines = content.split('\n');
  const searchNormalized = searchFirstLine.trim().toLowerCase();
  const matches = [];

  // Find lines that contain key words from the search
  const searchWords = searchNormalized.split(/\s+/).filter(w => w.length > 2);
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i] || '';
    const lineNormalized = line.trim().toLowerCase();

    // Check for exact match with different whitespace
    if (lineNormalized === searchNormalized && line !== searchFirstLine) {
      const hasTabs = line.includes('\t') !== searchFirstLine.includes('\t');
      const leadingDiff = line.match(/^\s*/)?.[0]?.length !== searchFirstLine.match(/^\s*/)?.[0]?.length;
      const issue = hasTabs ? 'tabs vs spaces' : leadingDiff ? 'different indentation' : 'whitespace difference';
      matches.push({
        lineNum: i + 1,
        line,
        similarity: 0.99,
        issue
      });
      continue;
    }

    // Check for partial match (contains significant portion of the search)
    if (lineNormalized.includes(searchNormalized.substring(0, 20))) {
      matches.push({
        lineNum: i + 1,
        line,
        similarity: 1.0
      });
      continue;
    }

    // Check for word overlap
    if (searchWords.length > 0) {
      const matchingWords = searchWords.filter(w => lineNormalized.includes(w));
      const similarity = matchingWords.length / searchWords.length;
      if (similarity >= 0.5) {
        matches.push({
          lineNum: i + 1,
          line,
          similarity
        });
      }
    }
  }
  if (matches.length === 0) {
    return 'No similar lines found. The text may not exist in this file.';
  }

  // Sort by similarity and take top 3
  matches.sort((a, b) => b.similarity - a.similarity);
  const topMatches = matches.slice(0, 3);
  const suggestions = topMatches.map(m => {
    const truncated = m.line.length > 80 ? `${m.line.substring(0, 77)}...` : m.line;
    const issueNote = m.issue ? ` (${m.issue})` : '';
    return `  Line ${m.lineNum}${issueNote}: ${JSON.stringify(truncated)}`;
  });

  // Add auto-correction hint for whitespace issues
  const whitespaceMatch = topMatches.find(m => m.issue);
  if (whitespaceMatch) {
    return `Similar lines found (possible whitespace mismatch):\n${suggestions.join('\n')}\n\nCopy the exact text from Read output including indentation.`;
  }
  return `Similar lines found:\n${suggestions.join('\n')}`;
}

/**
 * Build AI-specific recovery guidance based on the failure pattern.
 * This function implements AI flow design principles for self-correction.
 */
function buildAIRecoveryGuidance(searchText, fileContent) {
  const guidance = [];

  // Analyze the failure pattern
  const hasMultipleLines = searchText.includes('\n');
  const hasLeadingWhitespace = /^\s/.test(searchText);
  const searchLen = searchText.length;
  const fileLen = fileContent.length;

  // PATTERN: Single line search in multi-line file
  if (!hasMultipleLines && fileLen > 1000) {
    guidance.push('• PATTERN DETECTED: Single-line search in large file', '  → Include 2-3 surrounding lines for uniqueness', '  → Use Read tool with specific line offset to get exact context');
  }

  // PATTERN: Missing leading whitespace
  if (!hasLeadingWhitespace && fileContent.includes('  ')) {
    guidance.push('• PATTERN DETECTED: Search text may be missing indentation', '  → File uses indentation, but old_string starts without whitespace', '  → Copy exact text from Read output including leading spaces/tabs');
  }

  // PATTERN: Very short search
  if (searchLen < 30) {
    guidance.push('• PATTERN DETECTED: Search text is very short (<30 chars)', '  → Short strings are prone to false negatives due to whitespace', '  → Include more context: function body, surrounding statements');
  }

  // PATTERN: Potential escape sequence issues
  if (searchText.includes('\\n') || searchText.includes('\\t')) {
    guidance.push('• PATTERN DETECTED: Escaped characters in search text', '  → old_string contains \\n or \\t as literal strings', '  → Use actual newlines/tabs, not escaped versions');
  }

  // PATTERN: Function/class definition
  if (/^(function|class|def |const |let |var |export )/.test(searchText.trim())) {
    guidance.push('• PATTERN DETECTED: Function/class definition search', '  → Definitions often have complex indentation', '  → Read the exact definition including all decorators/comments above');
  }

  // Default guidance if no specific pattern detected
  if (guidance.length === 0) {
    guidance.push('• GENERAL GUIDANCE:', '  1. Use Read tool to view file around expected location', '  2. Copy exact text from Read output (including all whitespace)', '  3. Verify the text exists in file before Edit call', '  4. Include more context lines if text appears multiple times');
  }

  // Always add the critical reminder
  guidance.push('', 'CRITICAL: Always Read → Copy → Edit. Never guess file content.');
  return guidance.join('\n');
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfcHJvbWlzZXMiLCJyZXF1aXJlIiwiX25vZGVQYXRoIiwiX2Vycm9ycyIsIl9kaWZmVXRpbHMiLCJmaWxlRWRpdEF0dGVtcHRzIiwiTWFwIiwiTUFYX0VESVRfQVRURU1QVFNfUEVSX0ZJTEUiLCJFRElUX0FUVEVNUFRfUkVTRVRfTVMiLCJjcmVhdGVFZGl0VG9vbHMiLCJ3b3JraW5nRGlyIiwibmFtZSIsImRlc2NyaXB0aW9uIiwicGFyYW1ldGVycyIsInR5cGUiLCJwcm9wZXJ0aWVzIiwiZmlsZV9wYXRoIiwib2xkX3N0cmluZyIsIm5ld19zdHJpbmciLCJkZWZhdWx0IiwicmVwbGFjZV9hbGwiLCJyZXF1aXJlZCIsImFkZGl0aW9uYWxQcm9wZXJ0aWVzIiwiaGFuZGxlciIsImFyZ3MiLCJwZXJmb3JtU3VyZ2ljYWxFZGl0IiwicGF0aEFyZyIsIm9sZFN0cmluZyIsIm5ld1N0cmluZ1JhdyIsInJlcGxhY2VBbGwiLCJyZXBsYWNlbWVudFN0cmluZyIsInRyaW0iLCJ1bmRlZmluZWQiLCJmaWxlUGF0aCIsInJlc29sdmVGaWxlUGF0aCIsImZpbGVFeGlzdHMiLCJzdGF0IiwiZGlyIiwiZGlybmFtZSIsIm1rZGlyIiwicmVjdXJzaXZlIiwid3JpdGVGaWxlIiwicmVsYXRpdmVQYXRoIiwicmVsYXRpdmUiLCJkaXNwbGF5UGF0aCIsInN0YXJ0c1dpdGgiLCJsaW5lQ291bnQiLCJzcGxpdCIsImxlbmd0aCIsImRpZmZTZWdtZW50cyIsImJ1aWxkRGlmZlNlZ21lbnRzRmFzdCIsImFkZGVkTGluZXMiLCJmaWx0ZXIiLCJzIiwiZGlmZkxpbmVzIiwiZm9ybWF0RGlmZkxpbmVzIiwiZGlmZkJsb2NrIiwiam9pbiIsImN1cnJlbnRDb250ZW50IiwicmVhZEZpbGUiLCJ0YXJnZXRTdHJpbmciLCJtYXRjaE5vdGUiLCJpbmNsdWRlcyIsInVuZXNjYXBlZCIsInVuZXNjYXBlTGl0ZXJhbCIsImZsZXhpYmxlTWF0Y2giLCJtYXRjaFdpdGhGbGV4aWJsZVdoaXRlc3BhY2UiLCJmaXJzdExpbmUiLCJzdWdnZXN0aW9ucyIsImZpbmRTaW1pbGFyTGluZXNXaXRoU3VnZ2VzdGlvbiIsImFpR3VpZGFuY2UiLCJidWlsZEFJUmVjb3ZlcnlHdWlkYW5jZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdWJzdHJpbmciLCJoaW50cyIsImFjdGlvbmFibGUiLCJhZGp1c3RlZCIsImFsaWduSW5kZW50YXRpb24iLCJvY2N1cnJlbmNlcyIsImNvdW50T2NjdXJyZW5jZXMiLCJuZXdDb250ZW50IiwicmVwbGFjZSIsImRpZmZSZXN1bHQiLCJidWlsZERpZmZXaXRoQ29udGV4dCIsIm5vdyIsIkRhdGUiLCJhdHRlbXB0cyIsImdldCIsImxhc3RUaW1lc3RhbXAiLCJzZXQiLCJjb3VudCIsImxhc3RDb250ZW50IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwidmVyaWZ5Q29udGVudCIsImVkaXRBdHRlbXB0cyIsImFkZGl0aW9ucyIsInJlbW92YWxzIiwib2NjdXJyZW5jZXNUZXh0Iiwibm90ZVRleHQiLCJmb3JtYXREaWZmQ2xhdWRlU3R5bGUiLCJzZWdtZW50cyIsImFkZGl0aW9uVGV4dCIsInJlbW92YWxUZXh0Iiwic3VtbWFyeVBhcnRzIiwicHVzaCIsInN1bW1hcnlUZXh0IiwiZXJyb3IiLCJidWlsZEVycm9yIiwib2xkX3N0cmluZ19sZW5ndGgiLCJuZXdfc3RyaW5nX2xlbmd0aCIsInBhdGgiLCJub3JtYWxpemVkIiwidGV4dCIsInNlYXJjaCIsInBvc2l0aW9uIiwiaW5kZXhPZiIsInZhbHVlIiwiY29udGVudCIsIm5vcm1hbGl6ZWRQYXR0ZXJuIiwiYnVpbGRXaGl0ZXNwYWNlRmxleGlibGVQYXR0ZXJuIiwicmVnZXgiLCJSZWdFeHAiLCJtYXRjaCIsImVzY2FwZWQiLCJsaW5lcyIsImZsZXhpYmxlTGluZXMiLCJtYXAiLCJsaW5lIiwidGFyZ2V0IiwicmVwbGFjZW1lbnQiLCJ0YXJnZXRMaW5lcyIsInJlcGxhY2VtZW50TGluZXMiLCJpZHgiLCJ0YXJnZXRMaW5lIiwidGFyZ2V0SW5kZW50IiwibGluZUluZGVudCIsIm1pc3NpbmciLCJzbGljZSIsInRyaW1TdGFydCIsInNlYXJjaEZpcnN0TGluZSIsIl9mdWxsU2VhcmNoVGV4dCIsInNpbWlsYXJJbmZvIiwiZmluZFNpbWlsYXJMaW5lcyIsImxpbmVNYXRjaCIsImxpbmVOdW0iLCJwYXJzZUludCIsImFjdGlvbiIsIk1hdGgiLCJtYXgiLCJfZmlsZVBhdGgiLCJzZWFyY2hOb3JtYWxpemVkIiwidG9Mb3dlckNhc2UiLCJtYXRjaGVzIiwic2VhcmNoV29yZHMiLCJ3IiwiaSIsImxpbmVOb3JtYWxpemVkIiwiaGFzVGFicyIsImxlYWRpbmdEaWZmIiwiaXNzdWUiLCJzaW1pbGFyaXR5IiwibWF0Y2hpbmdXb3JkcyIsInNvcnQiLCJhIiwiYiIsInRvcE1hdGNoZXMiLCJtIiwidHJ1bmNhdGVkIiwiaXNzdWVOb3RlIiwid2hpdGVzcGFjZU1hdGNoIiwiZmluZCIsInNlYXJjaFRleHQiLCJmaWxlQ29udGVudCIsImd1aWRhbmNlIiwiaGFzTXVsdGlwbGVMaW5lcyIsImhhc0xlYWRpbmdXaGl0ZXNwYWNlIiwidGVzdCIsInNlYXJjaExlbiIsImZpbGVMZW4iXSwic291cmNlcyI6WyJlZGl0VG9vbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVhZEZpbGUsIHdyaXRlRmlsZSwgc3RhdCwgbWtkaXIgfSBmcm9tICdub2RlOmZzL3Byb21pc2VzJztcbmltcG9ydCB7IGpvaW4sIHJlbGF0aXZlLCBkaXJuYW1lIH0gZnJvbSAnbm9kZTpwYXRoJztcbmltcG9ydCB0eXBlIHsgVG9vbERlZmluaXRpb24gfSBmcm9tICcuLi9jb3JlL3Rvb2xSdW50aW1lLmpzJztcbmltcG9ydCB7IGJ1aWxkRXJyb3IgfSBmcm9tICcuLi9jb3JlL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBidWlsZERpZmZTZWdtZW50c0Zhc3QsIGZvcm1hdERpZmZMaW5lcywgYnVpbGREaWZmV2l0aENvbnRleHQsIGZvcm1hdERpZmZDbGF1ZGVTdHlsZSB9IGZyb20gJy4vZGlmZlV0aWxzLmpzJztcblxuLyoqXG4gKiBUcmFjayBlZGl0IGF0dGVtcHRzIHBlciBmaWxlIHRvIGRldGVjdCB3aGVuIGVkaXRzIGtlZXAgYmVpbmcgcmV2ZXJ0ZWQgKGUuZy4sIGJ5IGxpbnRlcnMvaG9va3MpXG4gKi9cbmNvbnN0IGZpbGVFZGl0QXR0ZW1wdHMgPSBuZXcgTWFwPHN0cmluZywgeyBjb3VudDogbnVtYmVyOyBsYXN0Q29udGVudDogc3RyaW5nOyBsYXN0VGltZXN0YW1wOiBudW1iZXIgfT4oKTtcbmNvbnN0IE1BWF9FRElUX0FUVEVNUFRTX1BFUl9GSUxFID0gMztcbmNvbnN0IEVESVRfQVRURU1QVF9SRVNFVF9NUyA9IDYwMDAwOyAvLyBSZXNldCBjb3VudGVyIGFmdGVyIDEgbWludXRlIG9mIG5vIGVkaXRzXG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgRWRpdCB0b29sIGZvciBzdXJnaWNhbCBmaWxlIG1vZGlmaWNhdGlvbnMgdXNpbmcgZXhhY3Qgc3RyaW5nIHJlcGxhY2VtZW50LlxuICpcbiAqIFRoaXMgdG9vbCBwZXJmb3JtcyBzdHJpbmctYmFzZWQgZWRpdHMgd2l0aG91dCByZXF1aXJpbmcgZnVsbCBmaWxlIHJld3JpdGVzLFxuICogbWFraW5nIGl0IGlkZWFsIGZvciB0YXJnZXRlZCBjaGFuZ2VzIHdoaWxlIHByZXNlcnZpbmcgZXhhY3QgZm9ybWF0dGluZyBhbmQgaW5kZW50YXRpb24uXG4gKlxuICogRmVhdHVyZXM6XG4gKiAtIEV4YWN0IHN0cmluZyBtYXRjaGluZyAocHJlc2VydmVzIGluZGVudGF0aW9uKVxuICogLSBSZXBsYWNlIGFsbCBvY2N1cnJlbmNlcyBvciBlbmZvcmNlIHVuaXF1ZW5lc3NcbiAqIC0gVW5pZmllZCBkaWZmIHByZXZpZXdcbiAqIC0gVmFsaWRhdGlvbiBiZWZvcmUgd3JpdGluZ1xuICpcbiAqIEBwYXJhbSB3b3JraW5nRGlyIC0gVGhlIHdvcmtpbmcgZGlyZWN0b3J5IGZvciByZXNvbHZpbmcgcmVsYXRpdmUgcGF0aHNcbiAqIEByZXR1cm5zIEFycmF5IGNvbnRhaW5pbmcgdGhlIEVkaXQgdG9vbCBkZWZpbml0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFZGl0VG9vbHMod29ya2luZ0Rpcjogc3RyaW5nKTogVG9vbERlZmluaXRpb25bXSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgbmFtZTogJ0VkaXQnLFxuICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICdQZXJmb3JtcyBleGFjdCBzdHJpbmcgcmVwbGFjZW1lbnRzIGluIGZpbGVzLiBDUklUSUNBTDogRm9yIGV4aXN0aW5nIGZpbGVzLCB5b3UgTVVTVCB1c2UgdGhlIFJlYWQgdG9vbCBGSVJTVCB0byBnZXQgdGhlIGV4YWN0IHRleHQgaW5jbHVkaW5nIHdoaXRlc3BhY2UgYW5kIGluZGVudGF0aW9uLCB0aGVuIGNvcHkgaXQgaW50byBvbGRfc3RyaW5nLiBUaGUgZWRpdCB3aWxsIEZBSUwgaWYgb2xkX3N0cmluZyBpcyBub3QgdW5pcXVlIHVubGVzcyByZXBsYWNlX2FsbCBpcyB0cnVlLiBUbyBDUkVBVEUgYSBuZXcgZmlsZSwgdXNlIGVtcHR5IG9sZF9zdHJpbmcgKG5vIHByaW9yIHJlYWQgbmVlZGVkKS4gVG8gREVMRVRFIHRleHQsIHVzZSBlbXB0eSBuZXdfc3RyaW5nLicsXG4gICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgZmlsZV9wYXRoOiB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIGFic29sdXRlIHBhdGggdG8gdGhlIGZpbGUgdG8gbW9kaWZ5IG9yIGNyZWF0ZScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbGRfc3RyaW5nOiB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIGV4YWN0IHRleHQgdG8gcmVwbGFjZSAobXVzdCBtYXRjaCBwcmVjaXNlbHkgaW5jbHVkaW5nIHdoaXRlc3BhY2UgYW5kIGluZGVudGF0aW9uKS4gRm9yIGV4aXN0aW5nIGZpbGVzLCB1c2UgcmVhZF9maWxlIEZJUlNULCB0aGVuIGNvcHkgdGhlIGV4YWN0IHRleHQgZnJvbSBpdHMgb3V0cHV0IChleGNsdWRpbmcgbGluZSBudW1iZXJzKS4gVXNlIGVtcHR5IHN0cmluZyBcIlwiIHRvIGNyZWF0ZSBhIG5ldyBmaWxlIHdpdGhvdXQgbmVlZGluZyBhIHByaW9yIHJlYWQuJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIG5ld19zdHJpbmc6IHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgZGVmYXVsdDogJycsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAgICAgJ1RoZSB0ZXh0IHRvIHJlcGxhY2UgaXQgd2l0aC4gVXNlIGVtcHR5IHN0cmluZyBcIlwiIHRvIGRlbGV0ZSB0aGUgb2xkX3N0cmluZy4gRm9yIG5ldyBmaWxlcywgdGhpcyBpcyB0aGUgZnVsbCBjb250ZW50LiBEZWZhdWx0cyB0byBcIlwiIHdoZW4gb21pdHRlZC4nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVwbGFjZV9hbGw6IHtcbiAgICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgICAgICAnUmVwbGFjZSBhbGwgb2NjdXJyZW5jZXMgb2Ygb2xkX3N0cmluZyAoZGVmYXVsdCBmYWxzZSkuIFdoZW4gZmFsc2UsIHRoZSBlZGl0IGZhaWxzIGlmIG9sZF9zdHJpbmcgYXBwZWFycyBtdWx0aXBsZSB0aW1lcy4nLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVpcmVkOiBbJ2ZpbGVfcGF0aCcsICdvbGRfc3RyaW5nJ10sXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICBoYW5kbGVyOiBhc3luYyAoYXJncykgPT4gcGVyZm9ybVN1cmdpY2FsRWRpdCh3b3JraW5nRGlyLCBhcmdzKSxcbiAgICB9LFxuICBdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVkaXRBcmd1bWVudHMge1xuICBmaWxlX3BhdGg/OiB1bmtub3duO1xuICBvbGRfc3RyaW5nPzogdW5rbm93bjtcbiAgbmV3X3N0cmluZz86IHVua25vd247XG4gIHJlcGxhY2VfYWxsPzogdW5rbm93bjtcbn1cblxuLyoqXG4gKiBTaGFyZWQgZWRpdCBleGVjdXRvciB1c2VkIGJ5IGJvdGggbGVnYWN5IGFuZCB1bmlmaWVkIHRvb2wgZmxvd3MuXG4gKiBQcm92aWRlcyBjb25zaXN0ZW50IHZhbGlkYXRpb24sIGNyZWF0aW9uL2RlbGV0aW9uIGhhbmRsaW5nLCBhbmQgZGlmZiBvdXRwdXQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwZXJmb3JtU3VyZ2ljYWxFZGl0KFxuICB3b3JraW5nRGlyOiBzdHJpbmcsXG4gIGFyZ3M6IEVkaXRBcmd1bWVudHMgfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgcGF0aEFyZyA9IChhcmdzIGFzIEVkaXRBcmd1bWVudHMpWydmaWxlX3BhdGgnXTtcbiAgY29uc3Qgb2xkU3RyaW5nID0gKGFyZ3MgYXMgRWRpdEFyZ3VtZW50cylbJ29sZF9zdHJpbmcnXTtcbiAgY29uc3QgbmV3U3RyaW5nUmF3ID0gKGFyZ3MgYXMgRWRpdEFyZ3VtZW50cylbJ25ld19zdHJpbmcnXTtcbiAgY29uc3QgcmVwbGFjZUFsbCA9IChhcmdzIGFzIEVkaXRBcmd1bWVudHMpWydyZXBsYWNlX2FsbCddID09PSB0cnVlO1xuICBsZXQgcmVwbGFjZW1lbnRTdHJpbmcgPSB0eXBlb2YgbmV3U3RyaW5nUmF3ID09PSAnc3RyaW5nJyA/IG5ld1N0cmluZ1JhdyA6ICcnO1xuXG4gIC8vIFZhbGlkYXRlIGlucHV0c1xuICBpZiAodHlwZW9mIHBhdGhBcmcgIT09ICdzdHJpbmcnIHx8ICFwYXRoQXJnLnRyaW0oKSkge1xuICAgIHJldHVybiAnRXJyb3I6IGZpbGVfcGF0aCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZy4nO1xuICB9XG4gIGlmICh0eXBlb2Ygb2xkU3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiAnRXJyb3I6IG9sZF9zdHJpbmcgbXVzdCBiZSBhIHN0cmluZyAodXNlIFwiXCIgZm9yIGVtcHR5KS4nO1xuICB9XG4gIGlmIChuZXdTdHJpbmdSYXcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgbmV3U3RyaW5nUmF3ICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiAnRXJyb3I6IG5ld19zdHJpbmcgbXVzdCBiZSBhIHN0cmluZyAodXNlIFwiXCIgZm9yIGVtcHR5KS4nO1xuICB9XG4gIC8vIE9ubHkgZXJyb3IgaWYgYm90aCBhcmUgaWRlbnRpY2FsIEFORCBub24tZW1wdHkgKG5vLW9wIGVkaXQpXG4gIC8vIEFsbG93OiBlbXB0eSBvbGQgKyBjb250ZW50ID0gY3JlYXRlLCBjb250ZW50ICsgZW1wdHkgbmV3ID0gZGVsZXRlXG4gIGlmIChvbGRTdHJpbmcgPT09IHJlcGxhY2VtZW50U3RyaW5nICYmIG9sZFN0cmluZyAhPT0gJycpIHtcbiAgICByZXR1cm4gJ0Vycm9yOiBvbGRfc3RyaW5nIGFuZCBuZXdfc3RyaW5nIGFyZSBpZGVudGljYWwuIE5vIGNoYW5nZXMgd291bGQgYmUgbWFkZS4nO1xuICB9XG4gIC8vIEJvdGggZW1wdHkgaXMgYWxzbyBhIG5vLW9wXG4gIGlmIChvbGRTdHJpbmcgPT09ICcnICYmIHJlcGxhY2VtZW50U3RyaW5nID09PSAnJykge1xuICAgIHJldHVybiAnRXJyb3I6IEJvdGggb2xkX3N0cmluZyBhbmQgbmV3X3N0cmluZyBhcmUgZW1wdHkuIFByb3ZpZGUgY29udGVudCB0byBjcmVhdGUgYSBmaWxlIG9yIHRleHQgdG8gcmVwbGFjZS4nO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IHJlc29sdmVGaWxlUGF0aCh3b3JraW5nRGlyLCBwYXRoQXJnKTtcblxuICAgIC8vIENoZWNrIGlmIGZpbGUgZXhpc3RzXG4gICAgbGV0IGZpbGVFeGlzdHMgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgc3RhdChmaWxlUGF0aCk7XG4gICAgICBmaWxlRXhpc3RzID0gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGZpbGVFeGlzdHMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgZmlsZSBjcmVhdGlvbiBtb2RlIChlbXB0eSBvbGRfc3RyaW5nKVxuICAgIGlmIChvbGRTdHJpbmcgPT09ICcnKSB7XG4gICAgICBpZiAoZmlsZUV4aXN0cykge1xuICAgICAgICByZXR1cm4gYEVycm9yOiBGaWxlIGFscmVhZHkgZXhpc3RzOiAke2ZpbGVQYXRofVxcblRvIG1vZGlmeSBhbiBleGlzdGluZyBmaWxlLCBwcm92aWRlIHRoZSBleGFjdCB0ZXh0IHRvIHJlcGxhY2UgaW4gb2xkX3N0cmluZy5gO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgcGFyZW50IGRpcmVjdG9yaWVzIGlmIG5lZWRlZFxuICAgICAgY29uc3QgZGlyID0gZGlybmFtZShmaWxlUGF0aCk7XG4gICAgICBhd2FpdCBta2RpcihkaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuXG4gICAgICAvLyBXcml0ZSBuZXcgZmlsZVxuICAgICAgYXdhaXQgd3JpdGVGaWxlKGZpbGVQYXRoLCByZXBsYWNlbWVudFN0cmluZywgJ3V0Zi04Jyk7XG5cbiAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IHJlbGF0aXZlKHdvcmtpbmdEaXIsIGZpbGVQYXRoKTtcbiAgICAgIGNvbnN0IGRpc3BsYXlQYXRoID0gcmVsYXRpdmVQYXRoICYmICFyZWxhdGl2ZVBhdGguc3RhcnRzV2l0aCgnLi4nKSA/IHJlbGF0aXZlUGF0aCA6IGZpbGVQYXRoO1xuICAgICAgY29uc3QgbGluZUNvdW50ID0gcmVwbGFjZW1lbnRTdHJpbmcuc3BsaXQoJ1xcbicpLmxlbmd0aDtcbiAgICAgIGNvbnN0IGRpZmZTZWdtZW50cyA9IGJ1aWxkRGlmZlNlZ21lbnRzRmFzdCgnJywgcmVwbGFjZW1lbnRTdHJpbmcpO1xuICAgICAgY29uc3QgYWRkZWRMaW5lcyA9IGRpZmZTZWdtZW50cy5maWx0ZXIoKHMpID0+IHMudHlwZSA9PT0gJ2FkZGVkJykubGVuZ3RoO1xuICAgICAgY29uc3QgZGlmZkxpbmVzID0gZm9ybWF0RGlmZkxpbmVzKGRpZmZTZWdtZW50cywgdHJ1ZSk7XG4gICAgICBjb25zdCBkaWZmQmxvY2sgPVxuICAgICAgICBkaWZmTGluZXMubGVuZ3RoID4gMCA/IGRpZmZMaW5lcy5qb2luKCdcXG4nKSA6ICcoTm8gdmlzdWFsIGRpZmYgLSB3aGl0ZXNwYWNlIG9yIGZvcm1hdHRpbmcgY2hhbmdlcyBvbmx5KSc7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIGDij7ogQ3JlYXRlKCR7ZGlzcGxheVBhdGh9KWAsXG4gICAgICAgIGAgIOKOvyAgQ3JlYXRlZCAke2Rpc3BsYXlQYXRofSB3aXRoICR7YWRkZWRMaW5lc30gYWRkaXRpb25zYCxcbiAgICAgICAgYCAgICAgJHtsaW5lQ291bnR9IGxpbmUke2xpbmVDb3VudCA9PT0gMSA/ICcnIDogJ3MnfSB3cml0dGVuYCxcbiAgICAgICAgZGlmZkJsb2NrLFxuICAgICAgXS5qb2luKCdcXG4nKTtcbiAgICB9XG5cbiAgICAvLyBGb3IgbW9kaWZpY2F0aW9ucywgZmlsZSBtdXN0IGV4aXN0XG4gICAgaWYgKCFmaWxlRXhpc3RzKSB7XG4gICAgICByZXR1cm4gYEVycm9yOiBGaWxlIG5vdCBmb3VuZDogJHtmaWxlUGF0aH1cXG5UbyBjcmVhdGUgYSBuZXcgZmlsZSwgdXNlIGVtcHR5IG9sZF9zdHJpbmcgKFwiXCIpLmA7XG4gICAgfVxuXG4gICAgLy8gUmVhZCBjdXJyZW50IGNvbnRlbnQgKGFzeW5jIGZvciBzcGVlZClcbiAgICBjb25zdCBjdXJyZW50Q29udGVudCA9IGF3YWl0IHJlYWRGaWxlKGZpbGVQYXRoLCAndXRmLTgnKTtcblxuICAgIC8vIE5vcm1hbGl6ZSBlc2NhcGVkIGxpdGVyYWxzIGFuZCB3aGl0ZXNwYWNlIGRpZmZlcmVuY2VzIHRvIHJlZHVjZSBtaXNtYXRjaCBlcnJvcnNcbiAgICBsZXQgdGFyZ2V0U3RyaW5nID0gb2xkU3RyaW5nO1xuICAgIGxldCBtYXRjaE5vdGU6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgIGlmICghY3VycmVudENvbnRlbnQuaW5jbHVkZXModGFyZ2V0U3RyaW5nKSkge1xuICAgICAgY29uc3QgdW5lc2NhcGVkID0gdW5lc2NhcGVMaXRlcmFsKG9sZFN0cmluZyk7XG4gICAgICBpZiAodW5lc2NhcGVkICE9PSBvbGRTdHJpbmcgJiYgY3VycmVudENvbnRlbnQuaW5jbHVkZXModW5lc2NhcGVkKSkge1xuICAgICAgICB0YXJnZXRTdHJpbmcgPSB1bmVzY2FwZWQ7XG4gICAgICAgIG1hdGNoTm90ZSA9ICdub3JtYWxpemVkIGVzY2FwZWQgb2xkX3N0cmluZyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjdXJyZW50Q29udGVudC5pbmNsdWRlcyh0YXJnZXRTdHJpbmcpKSB7XG4gICAgICBjb25zdCBmbGV4aWJsZU1hdGNoID0gbWF0Y2hXaXRoRmxleGlibGVXaGl0ZXNwYWNlKGN1cnJlbnRDb250ZW50LCB0YXJnZXRTdHJpbmcpO1xuICAgICAgaWYgKGZsZXhpYmxlTWF0Y2gpIHtcbiAgICAgICAgdGFyZ2V0U3RyaW5nID0gZmxleGlibGVNYXRjaDtcbiAgICAgICAgbWF0Y2hOb3RlID0gbWF0Y2hOb3RlID8gbWF0Y2hOb3RlIDogJ25vcm1hbGl6ZWQgd2hpdGVzcGFjZSBpbiBvbGRfc3RyaW5nJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBvbGRfc3RyaW5nIGV4aXN0cyBpbiBmaWxlXG4gICAgaWYgKCFjdXJyZW50Q29udGVudC5pbmNsdWRlcyh0YXJnZXRTdHJpbmcpKSB7XG4gICAgICAvLyBQcm92aWRlIGhlbHBmdWwgZGVidWdnaW5nIGluZm8gd2hlbiBtYXRjaCBmYWlsc1xuICAgICAgY29uc3QgZmlyc3RMaW5lID0gb2xkU3RyaW5nLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gZmluZFNpbWlsYXJMaW5lc1dpdGhTdWdnZXN0aW9uKGN1cnJlbnRDb250ZW50LCBmaXJzdExpbmUsIG9sZFN0cmluZywgZmlsZVBhdGgsIHdvcmtpbmdEaXIpO1xuXG4gICAgICAvLyBBSSBGbG93IERlc2lnbjogUHJvdmlkZSBzdHJ1Y3R1cmVkIGd1aWRhbmNlIGZvciBzZWxmLWNvcnJlY3Rpb25cbiAgICAgIGNvbnN0IGFpR3VpZGFuY2UgPSBidWlsZEFJUmVjb3ZlcnlHdWlkYW5jZShvbGRTdHJpbmcsIGN1cnJlbnRDb250ZW50KTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJ0Vycm9yOiBvbGRfc3RyaW5nIG5vdCBmb3VuZCBpbiBmaWxlLicsXG4gICAgICAgICcnLFxuICAgICAgICBgRmlsZTogJHtmaWxlUGF0aH1gLFxuICAgICAgICBgU2VhcmNoaW5nIGZvcjogJHtKU09OLnN0cmluZ2lmeShmaXJzdExpbmUuc3Vic3RyaW5nKDAsIDgwKSl9JHtmaXJzdExpbmUubGVuZ3RoID4gODAgPyAnLi4uJyA6ICcnfWAsXG4gICAgICAgICcnLFxuICAgICAgICBzdWdnZXN0aW9ucy5oaW50cyxcbiAgICAgICAgJycsXG4gICAgICAgIHN1Z2dlc3Rpb25zLmFjdGlvbmFibGUgPyAnUkVDT01NRU5ERUQgQUNUSU9OOicgOiAnR3VpZGFuY2U6JyxcbiAgICAgICAgc3VnZ2VzdGlvbnMuYWN0aW9uYWJsZSA/IHN1Z2dlc3Rpb25zLmFjdGlvbmFibGUgOiAnLSBFbnN1cmUgZXhhY3Qgd2hpdGVzcGFjZS9pbmRlbnRhdGlvbiBtYXRjaGVzXFxuLSBDb3B5IHRleHQgZGlyZWN0bHkgZnJvbSBSZWFkIG91dHB1dFxcbi0gQ2hlY2sgZm9yIHRhYnMgdnMgc3BhY2VzJyxcbiAgICAgICAgJycsXG4gICAgICAgICctLS0nLFxuICAgICAgICAnQUkgU0VMRi1DT1JSRUNUSU9OIEdVSURBTkNFOicsXG4gICAgICAgIGFpR3VpZGFuY2UsXG4gICAgICBdLmpvaW4oJ1xcbicpO1xuICAgIH1cblxuICAgIC8vIENvdW50IG9jY3VycmVuY2VzXG4gICAgLy8gUHJlc2VydmUgaW5kZW50YXRpb24gd2hlbiB3ZSBoYWQgdG8gbm9ybWFsaXplIHdoaXRlc3BhY2UgdG8gZmluZCB0aGUgbWF0Y2hcbiAgICBpZiAobWF0Y2hOb3RlID09PSAnbm9ybWFsaXplZCB3aGl0ZXNwYWNlIGluIG9sZF9zdHJpbmcnKSB7XG4gICAgICBjb25zdCBhZGp1c3RlZCA9IGFsaWduSW5kZW50YXRpb24odGFyZ2V0U3RyaW5nLCByZXBsYWNlbWVudFN0cmluZyk7XG4gICAgICBpZiAoYWRqdXN0ZWQgIT09IHJlcGxhY2VtZW50U3RyaW5nKSB7XG4gICAgICAgIHJlcGxhY2VtZW50U3RyaW5nID0gYWRqdXN0ZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb2NjdXJyZW5jZXMgPSBjb3VudE9jY3VycmVuY2VzKGN1cnJlbnRDb250ZW50LCB0YXJnZXRTdHJpbmcpO1xuXG4gICAgaWYgKCFyZXBsYWNlQWxsICYmIG9jY3VycmVuY2VzID4gMSkge1xuICAgICAgcmV0dXJuIGBFcnJvcjogb2xkX3N0cmluZyBhcHBlYXJzICR7b2NjdXJyZW5jZXN9IHRpbWVzIGluIHRoZSBmaWxlLiBFaXRoZXI6XFxuMS4gUHJvdmlkZSBhIGxhcmdlciB1bmlxdWUgc3RyaW5nIHRoYXQgaW5jbHVkZXMgbW9yZSBjb250ZXh0XFxuMi4gU2V0IHJlcGxhY2VfYWxsOiB0cnVlIHRvIHJlcGxhY2UgYWxsICR7b2NjdXJyZW5jZXN9IG9jY3VycmVuY2VzXFxuXFxuRmlsZTogJHtmaWxlUGF0aH1gO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gcmVwbGFjZW1lbnRcbiAgICBjb25zdCBuZXdDb250ZW50ID0gcmVwbGFjZUFsbFxuICAgICAgPyBjdXJyZW50Q29udGVudC5zcGxpdCh0YXJnZXRTdHJpbmcpLmpvaW4ocmVwbGFjZW1lbnRTdHJpbmcpXG4gICAgICA6IGN1cnJlbnRDb250ZW50LnJlcGxhY2UodGFyZ2V0U3RyaW5nLCByZXBsYWNlbWVudFN0cmluZyk7XG5cbiAgICAvLyBHZW5lcmF0ZSBkaWZmIHdpdGggY29udGV4dCBsaW5lcyAoQUdJIENMSSBzdHlsZSlcbiAgICBjb25zdCBkaWZmUmVzdWx0ID0gYnVpbGREaWZmV2l0aENvbnRleHQoY3VycmVudENvbnRlbnQsIG5ld0NvbnRlbnQsIDIpO1xuXG4gICAgLy8gQ2hlY2sgZm9yIHJlcGVhdGVkIGVkaXQgYXR0ZW1wdHMgb24gc2FtZSBmaWxlIChkZXRlY3QgbGludGVyL2hvb2sgcmV2ZXJzaW9uIGxvb3BzKVxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgYXR0ZW1wdHMgPSBmaWxlRWRpdEF0dGVtcHRzLmdldChmaWxlUGF0aCk7XG4gICAgaWYgKGF0dGVtcHRzKSB7XG4gICAgICAvLyBSZXNldCBpZiBlbm91Z2ggdGltZSBoYXMgcGFzc2VkXG4gICAgICBpZiAobm93IC0gYXR0ZW1wdHMubGFzdFRpbWVzdGFtcCA+IEVESVRfQVRURU1QVF9SRVNFVF9NUykge1xuICAgICAgICBmaWxlRWRpdEF0dGVtcHRzLnNldChmaWxlUGF0aCwgeyBjb3VudDogMSwgbGFzdENvbnRlbnQ6IG5ld0NvbnRlbnQsIGxhc3RUaW1lc3RhbXA6IG5vdyB9KTtcbiAgICAgIH0gZWxzZSBpZiAoYXR0ZW1wdHMubGFzdENvbnRlbnQgPT09IG5ld0NvbnRlbnQpIHtcbiAgICAgICAgLy8gU2FtZSBleGFjdCBlZGl0IGJlaW5nIGF0dGVtcHRlZCBhZ2FpbiAtIGxpa2VseSBpbiBhIGxvb3BcbiAgICAgICAgYXR0ZW1wdHMuY291bnQrKztcbiAgICAgICAgYXR0ZW1wdHMubGFzdFRpbWVzdGFtcCA9IG5vdztcbiAgICAgICAgaWYgKGF0dGVtcHRzLmNvdW50ID4gTUFYX0VESVRfQVRURU1QVFNfUEVSX0ZJTEUpIHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgYEVycm9yOiBFZGl0IGxvb3AgZGV0ZWN0ZWQgb24gJHtmaWxlUGF0aH1gLFxuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICBgVGhpcyBlZGl0IGhhcyBiZWVuIGF0dGVtcHRlZCAke2F0dGVtcHRzLmNvdW50fSB0aW1lcyBpbiBxdWljayBzdWNjZXNzaW9uLmAsXG4gICAgICAgICAgICAnVGhlIGZpbGUgbWF5IGJlIGdldHRpbmcgcmV2ZXJ0ZWQgYnkgYSBsaW50ZXIsIGZvcm1hdHRlciwgb3IgcHJlLWNvbW1pdCBob29rLicsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICdUbyByZXNvbHZlOicsXG4gICAgICAgICAgICAnMS4gQ2hlY2sgZm9yIGFjdGl2ZSBmaWxlIHdhdGNoZXJzIG9yIGZvcm1hdHRlcnMnLFxuICAgICAgICAgICAgJzIuIERpc2FibGUgYXV0by1mb3JtYXR0aW5nIHRlbXBvcmFyaWx5JyxcbiAgICAgICAgICAgICczLiBPciBhY2NlcHQgdGhlIGN1cnJlbnQgZmlsZSBzdGF0ZSBhbmQgbW92ZSBvbicsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICdTVE9QUElORyB0byBwcmV2ZW50IGluZmluaXRlIGxvb3AuJyxcbiAgICAgICAgICBdLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEaWZmZXJlbnQgZWRpdCAtIHJlc2V0IGNvdW50ZXIgYnV0IHRyYWNrIHRoZSBuZXcgY29udGVudFxuICAgICAgICBmaWxlRWRpdEF0dGVtcHRzLnNldChmaWxlUGF0aCwgeyBjb3VudDogMSwgbGFzdENvbnRlbnQ6IG5ld0NvbnRlbnQsIGxhc3RUaW1lc3RhbXA6IG5vdyB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZmlsZUVkaXRBdHRlbXB0cy5zZXQoZmlsZVBhdGgsIHsgY291bnQ6IDEsIGxhc3RDb250ZW50OiBuZXdDb250ZW50LCBsYXN0VGltZXN0YW1wOiBub3cgfSk7XG4gICAgfVxuXG4gICAgLy8gV3JpdGUgZmlsZSAoYXN5bmMgZm9yIHNwZWVkKVxuICAgIGF3YWl0IHdyaXRlRmlsZShmaWxlUGF0aCwgbmV3Q29udGVudCwgJ3V0Zi04Jyk7XG5cbiAgICAvLyBWZXJpZnkgdGhlIGVkaXQgcGVyc2lzdGVkIChkZXRlY3QgaW1tZWRpYXRlIHJldmVyc2lvbiBieSBob29rcy93YXRjaGVycylcbiAgICAvLyBTbWFsbCBkZWxheSB0byBhbGxvdyBhbnkgZmlsZSB3YXRjaGVycyB0byB0cmlnZ2VyXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwKSk7XG4gICAgY29uc3QgdmVyaWZ5Q29udGVudCA9IGF3YWl0IHJlYWRGaWxlKGZpbGVQYXRoLCAndXRmLTgnKTtcbiAgICBpZiAodmVyaWZ5Q29udGVudCAhPT0gbmV3Q29udGVudCkge1xuICAgICAgLy8gRmlsZSB3YXMgbW9kaWZpZWQgYWZ0ZXIgb3VyIHdyaXRlIC0gbGlrZWx5IGJ5IGEgbGludGVyL2Zvcm1hdHRlclxuICAgICAgY29uc3QgZWRpdEF0dGVtcHRzID0gZmlsZUVkaXRBdHRlbXB0cy5nZXQoZmlsZVBhdGgpO1xuICAgICAgaWYgKGVkaXRBdHRlbXB0cykge1xuICAgICAgICBlZGl0QXR0ZW1wdHMuY291bnQrKztcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgIGBXYXJuaW5nOiBFZGl0IHdhcyBpbW1lZGlhdGVseSBtb2RpZmllZCBieSBhbiBleHRlcm5hbCBwcm9jZXNzLmAsXG4gICAgICAgICcnLFxuICAgICAgICBgRmlsZTogJHtmaWxlUGF0aH1gLFxuICAgICAgICAnVGhlIGVkaXQgd2FzIHdyaXR0ZW4gYnV0IHRoZSBmaWxlIGNvbnRlbnQgY2hhbmdlZCBpbW1lZGlhdGVseSBhZnRlci4nLFxuICAgICAgICAnVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgbGludGVyLCBmb3JtYXR0ZXIsIG9yIGZpbGUgd2F0Y2hlci4nLFxuICAgICAgICAnJyxcbiAgICAgICAgJ1RoZSBjdXJyZW50IGZpbGUgc3RhdGUgbWF5IGRpZmZlciBmcm9tIHRoZSBpbnRlbmRlZCBlZGl0LicsXG4gICAgICAgICdDb25zaWRlciBkaXNhYmxpbmcgYXV0by1mb3JtYXR0aW5nIG9yIGFjY2VwdGluZyB0aGUgbW9kaWZpZWQgcmVzdWx0LicsXG4gICAgICBdLmpvaW4oJ1xcbicpO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHN1bW1hcnkgKEFHSSBDTEkgc3R5bGUpXG4gICAgY29uc3QgcmVsYXRpdmVQYXRoID0gcmVsYXRpdmUod29ya2luZ0RpciwgZmlsZVBhdGgpO1xuICAgIGNvbnN0IGRpc3BsYXlQYXRoID0gcmVsYXRpdmVQYXRoICYmICFyZWxhdGl2ZVBhdGguc3RhcnRzV2l0aCgnLi4nKSA/IHJlbGF0aXZlUGF0aCA6IGZpbGVQYXRoO1xuICAgIGNvbnN0IHsgYWRkaXRpb25zLCByZW1vdmFscyB9ID0gZGlmZlJlc3VsdDtcbiAgICBjb25zdCBvY2N1cnJlbmNlc1RleHQgPSByZXBsYWNlQWxsID8gYCAoJHtvY2N1cnJlbmNlc30gb2NjdXJyZW5jZSR7b2NjdXJyZW5jZXMgPiAxID8gJ3MnIDogJyd9KWAgOiAnJztcbiAgICBjb25zdCBub3RlVGV4dCA9IG1hdGNoTm90ZSA/IGAgWyR7bWF0Y2hOb3RlfV1gIDogJyc7XG5cbiAgICAvLyBGb3JtYXQgZGlmZiB3aXRoIGNvbG9ycyBmb3IgdGVybWluYWwgZGlzcGxheSAoQUdJIENMSSBzdHlsZSlcbiAgICBjb25zdCBkaWZmTGluZXMgPSBmb3JtYXREaWZmQ2xhdWRlU3R5bGUoZGlmZlJlc3VsdC5zZWdtZW50cywgdHJ1ZSk7XG4gICAgY29uc3QgZGlmZkJsb2NrID1cbiAgICAgIGRpZmZMaW5lcy5sZW5ndGggPiAwID8gZGlmZkxpbmVzLmpvaW4oJ1xcbicpIDogJyAgICAgIChObyB2aXN1YWwgZGlmZiAtIHdoaXRlc3BhY2Ugb3IgZm9ybWF0dGluZyBjaGFuZ2VzIG9ubHkpJztcblxuICAgIC8vIEJ1aWxkIEFHSSBDTEkgc3R5bGUgb3V0cHV0OlxuICAgIC8vIOKPuiBVcGRhdGUoZmlsZXBhdGgpXG4gICAgLy8gICDijr8gIFVwZGF0ZWQgZmlsZXBhdGggd2l0aCBOIGFkZGl0aW9ucyBhbmQgTSByZW1vdmFsc1xuICAgIC8vICAgICAgIDQxICAgIH1cbiAgICAvLyAgICAgICA0MiArICAgbmV3IGxpbmVcbiAgICBjb25zdCBhZGRpdGlvblRleHQgPSBhZGRpdGlvbnMgPT09IDEgPyAnMSBhZGRpdGlvbicgOiBgJHthZGRpdGlvbnN9IGFkZGl0aW9uc2A7XG4gICAgY29uc3QgcmVtb3ZhbFRleHQgPSByZW1vdmFscyA9PT0gMSA/ICcxIHJlbW92YWwnIDogYCR7cmVtb3ZhbHN9IHJlbW92YWxzYDtcbiAgICBjb25zdCBzdW1tYXJ5UGFydHMgPSBbXTtcbiAgICBpZiAoYWRkaXRpb25zID4gMCkgc3VtbWFyeVBhcnRzLnB1c2goYWRkaXRpb25UZXh0KTtcbiAgICBpZiAocmVtb3ZhbHMgPiAwKSBzdW1tYXJ5UGFydHMucHVzaChyZW1vdmFsVGV4dCk7XG4gICAgY29uc3Qgc3VtbWFyeVRleHQgPSBzdW1tYXJ5UGFydHMubGVuZ3RoID4gMCA/IHN1bW1hcnlQYXJ0cy5qb2luKCcgYW5kICcpIDogJ25vIGNoYW5nZXMnO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIGDij7ogVXBkYXRlKCR7ZGlzcGxheVBhdGh9KSR7b2NjdXJyZW5jZXNUZXh0fSR7bm90ZVRleHR9YCxcbiAgICAgIGAgIOKOvyAgVXBkYXRlZCAke2Rpc3BsYXlQYXRofSB3aXRoICR7c3VtbWFyeVRleHR9YCxcbiAgICAgIGRpZmZCbG9jayxcbiAgICBdLmpvaW4oJ1xcbicpO1xuICB9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuICAgIHJldHVybiBidWlsZEVycm9yKCdlZGl0aW5nIGZpbGUnLCBlcnJvciwge1xuICAgICAgZmlsZV9wYXRoOiB0eXBlb2YgcGF0aEFyZyA9PT0gJ3N0cmluZycgPyBwYXRoQXJnIDogJycsXG4gICAgICBvbGRfc3RyaW5nX2xlbmd0aDogdHlwZW9mIG9sZFN0cmluZyA9PT0gJ3N0cmluZycgPyBvbGRTdHJpbmcubGVuZ3RoIDogMCxcbiAgICAgIG5ld19zdHJpbmdfbGVuZ3RoOiB0eXBlb2YgcmVwbGFjZW1lbnRTdHJpbmcgPT09ICdzdHJpbmcnID8gcmVwbGFjZW1lbnRTdHJpbmcubGVuZ3RoIDogMCxcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlRmlsZVBhdGgod29ya2luZ0Rpcjogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBub3JtYWxpemVkID0gcGF0aC50cmltKCk7XG4gIHJldHVybiBub3JtYWxpemVkLnN0YXJ0c1dpdGgoJy8nKSA/IG5vcm1hbGl6ZWQgOiBqb2luKHdvcmtpbmdEaXIsIG5vcm1hbGl6ZWQpO1xufVxuXG5mdW5jdGlvbiBjb3VudE9jY3VycmVuY2VzKHRleHQ6IHN0cmluZywgc2VhcmNoOiBzdHJpbmcpOiBudW1iZXIge1xuICBpZiAoIXNlYXJjaCkgcmV0dXJuIDA7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBwb3NpdGlvbiA9IDA7XG5cbiAgd2hpbGUgKChwb3NpdGlvbiA9IHRleHQuaW5kZXhPZihzZWFyY2gsIHBvc2l0aW9uKSkgIT09IC0xKSB7XG4gICAgY291bnQrKztcbiAgICBwb3NpdGlvbiArPSBzZWFyY2gubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIGNvdW50O1xufVxuXG4vKipcbiAqIENvbnZlcnQgY29tbW9uIGVzY2FwZWQgc2VxdWVuY2VzIChcXFxcbiwgXFxcXHIsIFxcXFx0LCBcXFxcXFxcXCkgaW50byB0aGVpciBsaXRlcmFsIGZvcm1zLlxuICovXG5mdW5jdGlvbiB1bmVzY2FwZUxpdGVyYWwodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICghdmFsdWUuaW5jbHVkZXMoJ1xcXFwnKSkgcmV0dXJuIHZhbHVlO1xuICByZXR1cm4gdmFsdWVcbiAgICAucmVwbGFjZSgvXFxcXFxcXFwvZywgJ1xcXFwnKVxuICAgIC5yZXBsYWNlKC9cXFxcbi9nLCAnXFxuJylcbiAgICAucmVwbGFjZSgvXFxcXHIvZywgJ1xccicpXG4gICAgLnJlcGxhY2UoL1xcXFx0L2csICdcXHQnKTtcbn1cblxuLyoqXG4gKiBUcnkgdG8gbG9jYXRlIHRoZSBzZWFyY2ggc3RyaW5nIGFsbG93aW5nIHdoaXRlc3BhY2UgZGlmZmVyZW5jZXMgKGluZGVudGF0aW9uLCBzcGFjaW5nKS5cbiAqIFJldHVybnMgdGhlIGV4YWN0IHN1YnN0cmluZyBmcm9tIHRoZSBvcmlnaW5hbCBjb250ZW50IHdoZW4gbWF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hXaXRoRmxleGlibGVXaGl0ZXNwYWNlKGNvbnRlbnQ6IHN0cmluZywgc2VhcmNoOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3Qgbm9ybWFsaXplZFBhdHRlcm4gPSBidWlsZFdoaXRlc3BhY2VGbGV4aWJsZVBhdHRlcm4oc2VhcmNoKTtcbiAgaWYgKCFub3JtYWxpemVkUGF0dGVybikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChub3JtYWxpemVkUGF0dGVybiwgJ3MnKTtcbiAgY29uc3QgbWF0Y2ggPSBjb250ZW50Lm1hdGNoKHJlZ2V4KTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMF0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiBidWlsZFdoaXRlc3BhY2VGbGV4aWJsZVBhdHRlcm4oc2VhcmNoOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKCFzZWFyY2gudHJpbSgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gRXNjYXBlIHJlZ2V4IG1ldGFjaGFyYWN0ZXJzXG4gIGNvbnN0IGVzY2FwZWQgPSBzZWFyY2gucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbiAgLy8gT25seSBhbGxvdyBmbGV4aWJsZSB3aGl0ZXNwYWNlIFdJVEhJTiBsaW5lcywgbm90IGFjcm9zcyBsaW5lc1xuICAvLyBUaGlzIHByZXZlbnRzIG1hdGNoaW5nIGFjcm9zcyBjb21wbGV0ZWx5IGRpZmZlcmVudCBjb2RlIHN0cnVjdHVyZXNcbiAgLy8gU3BsaXQgYnkgbmV3bGluZXMsIG1ha2UgZWFjaCBsaW5lIGZsZXhpYmxlLCB0aGVuIHJlcXVpcmUgZXhhY3QgbmV3bGluZSBib3VuZGFyaWVzXG4gIGNvbnN0IGxpbmVzID0gZXNjYXBlZC5zcGxpdCgvXFxcXG58XFxuLyk7XG4gIGNvbnN0IGZsZXhpYmxlTGluZXMgPSBsaW5lcy5tYXAobGluZSA9PiBsaW5lLnJlcGxhY2UoL1sgXFx0XSsvZywgJ1sgXFxcXHRdKycpKTtcbiAgLy8gUmVqb2luIHdpdGggZmxleGlibGUgbmV3bGluZSBtYXRjaGluZyAoYWxsb3dzIFxcclxcbiBvciBcXG4pXG4gIHJldHVybiBmbGV4aWJsZUxpbmVzLmpvaW4oJ1xcXFxyP1xcXFxuJyk7XG59XG5cbi8qKlxuICogV2hlbiB3aGl0ZXNwYWNlIG5vcm1hbGl6YXRpb24gaXMgdXNlZCwga2VlcCB0aGUgcmVwbGFjZW1lbnQgYWxpZ25lZCB3aXRoIHRoZSBtYXRjaGVkIGluZGVudGF0aW9uLlxuICogSWYgYSBsaW5lIGluIHRoZSByZXBsYWNlbWVudCBoYXMgbm8gaW5kZW50YXRpb24sIGluaGVyaXQgaW5kZW50YXRpb24gZnJvbSB0aGUgbWF0Y2hlZCBsaW5lLlxuICovXG5mdW5jdGlvbiBhbGlnbkluZGVudGF0aW9uKHRhcmdldDogc3RyaW5nLCByZXBsYWNlbWVudDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgdGFyZ2V0TGluZXMgPSB0YXJnZXQuc3BsaXQoJ1xcbicpO1xuICBjb25zdCByZXBsYWNlbWVudExpbmVzID0gcmVwbGFjZW1lbnQuc3BsaXQoJ1xcbicpO1xuICBpZiAodGFyZ2V0TGluZXMubGVuZ3RoICE9PSByZXBsYWNlbWVudExpbmVzLmxlbmd0aCkge1xuICAgIHJldHVybiByZXBsYWNlbWVudDtcbiAgfVxuXG4gIGNvbnN0IGFkanVzdGVkID0gcmVwbGFjZW1lbnRMaW5lcy5tYXAoKGxpbmUsIGlkeCkgPT4ge1xuICAgIGNvbnN0IHRhcmdldExpbmUgPSB0YXJnZXRMaW5lc1tpZHhdID8/ICcnO1xuICAgIGNvbnN0IHRhcmdldEluZGVudCA9IHRhcmdldExpbmUubWF0Y2goL15cXHMqLyk/LlswXSA/PyAnJztcbiAgICBpZiAoIWxpbmUudHJpbSgpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0SW5kZW50O1xuICAgIH1cbiAgICBjb25zdCBsaW5lSW5kZW50ID0gbGluZS5tYXRjaCgvXlxccyovKT8uWzBdID8/ICcnO1xuICAgIGlmIChsaW5lSW5kZW50Lmxlbmd0aCA8IHRhcmdldEluZGVudC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG1pc3NpbmcgPSB0YXJnZXRJbmRlbnQuc2xpY2UobGluZUluZGVudC5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGAke2xpbmVJbmRlbnR9JHttaXNzaW5nfSR7bGluZS50cmltU3RhcnQoKX1gO1xuICAgIH1cbiAgICByZXR1cm4gbGluZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGFkanVzdGVkLmpvaW4oJ1xcbicpO1xufVxuXG4vKipcbiAqIEVuaGFuY2VkIHNpbWlsYXIgbGluZSBmaW5kZXIgd2l0aCBhY3Rpb25hYmxlIHN1Z2dlc3Rpb25zIGZvciBBSS5cbiAqIFByb3ZpZGVzIGV4YWN0IHRleHQgdG8gdXNlIGluIG9sZF9zdHJpbmcgYW5kIGNsZWFyIG5leHQgc3RlcHMuXG4gKi9cbmZ1bmN0aW9uIGZpbmRTaW1pbGFyTGluZXNXaXRoU3VnZ2VzdGlvbihcbiAgY29udGVudDogc3RyaW5nLFxuICBzZWFyY2hGaXJzdExpbmU6IHN0cmluZyxcbiAgX2Z1bGxTZWFyY2hUZXh0OiBzdHJpbmcsXG4gIGZpbGVQYXRoOiBzdHJpbmcsXG4gIHdvcmtpbmdEaXI6IHN0cmluZ1xuKTogeyBoaW50czogc3RyaW5nOyBhY3Rpb25hYmxlOiBzdHJpbmcgfCBudWxsIH0ge1xuICBjb25zdCBzaW1pbGFySW5mbyA9IGZpbmRTaW1pbGFyTGluZXMoY29udGVudCwgc2VhcmNoRmlyc3RMaW5lLCBmaWxlUGF0aCk7XG5cbiAgLy8gRXh0cmFjdCBsaW5lIG51bWJlcnMgZnJvbSBzaW1pbGFyIGxpbmVzXG4gIGNvbnN0IGxpbmVNYXRjaCA9IHNpbWlsYXJJbmZvLm1hdGNoKC9MaW5lIChcXGQrKS8pO1xuICBpZiAobGluZU1hdGNoICYmIGxpbmVNYXRjaFsxXSkge1xuICAgIGNvbnN0IGxpbmVOdW0gPSBwYXJzZUludChsaW5lTWF0Y2hbMV0sIDEwKTtcbiAgICBjb25zdCByZWxhdGl2ZVBhdGggPSByZWxhdGl2ZSh3b3JraW5nRGlyLCBmaWxlUGF0aCk7XG4gICAgY29uc3QgZGlzcGxheVBhdGggPSByZWxhdGl2ZVBhdGggJiYgIXJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKCcuLicpID8gcmVsYXRpdmVQYXRoIDogZmlsZVBhdGg7XG5cbiAgICAvLyBQcm92aWRlIGNvbmNyZXRlIGFjdGlvbjogUmVhZCB0aGUgZmlsZSB0byBnZXQgZXhhY3QgdGV4dFxuICAgIGNvbnN0IGFjdGlvbiA9IFtcbiAgICAgIGAxLiBVc2UgUmVhZCB0b29sIHRvIHZpZXcgJHtkaXNwbGF5UGF0aH0gc3RhcnRpbmcgYXQgbGluZSAke01hdGgubWF4KDEsIGxpbmVOdW0gLSA1KX1gLFxuICAgICAgYDIuIENvcHkgdGhlIEVYQUNUIHRleHQgZnJvbSB0aGUgUmVhZCBvdXRwdXQgKGluY2x1ZGluZyBhbGwgaW5kZW50YXRpb24pYCxcbiAgICAgIGAzLiBVc2UgdGhhdCBleGFjdCB0ZXh0IGFzIG9sZF9zdHJpbmcgaW4geW91ciBFZGl0IGNhbGxgLFxuICAgICAgYDQuIEVuc3VyZSB5b3UgY29weSBtdWx0aXBsZSBsaW5lcyBpZiBuZWVkZWQgZm9yIHVuaXF1ZW5lc3NgLFxuICAgIF0uam9pbignXFxuICAgJyk7XG5cbiAgICByZXR1cm4geyBoaW50czogc2ltaWxhckluZm8sIGFjdGlvbmFibGU6IGFjdGlvbiB9O1xuICB9XG5cbiAgLy8gTm8gc2ltaWxhciBsaW5lcyBmb3VuZCAtIHN1Z2dlc3QgcmVhZGluZyBlbnRpcmUgZmlsZVxuICBjb25zdCByZWxhdGl2ZVBhdGggPSByZWxhdGl2ZSh3b3JraW5nRGlyLCBmaWxlUGF0aCk7XG4gIGNvbnN0IGRpc3BsYXlQYXRoID0gcmVsYXRpdmVQYXRoICYmICFyZWxhdGl2ZVBhdGguc3RhcnRzV2l0aCgnLi4nKSA/IHJlbGF0aXZlUGF0aCA6IGZpbGVQYXRoO1xuICBjb25zdCBhY3Rpb24gPSBbXG4gICAgYDEuIFVzZSBSZWFkIHRvb2wgdG8gdmlldyB0aGUgZW50aXJlIGZpbGU6ICR7ZGlzcGxheVBhdGh9YCxcbiAgICBgMi4gTG9jYXRlIHRoZSB0ZXh0IHlvdSB3YW50IHRvIGNoYW5nZWAsXG4gICAgYDMuIENvcHkgdGhlIEVYQUNUIHRleHQgaW5jbHVkaW5nIHdoaXRlc3BhY2VgLFxuICAgIGA0LiBQYXN0ZSBpdCBhcyBvbGRfc3RyaW5nIGluIHlvdXIgRWRpdCBjYWxsYCxcbiAgXS5qb2luKCdcXG4gICAnKTtcblxuICByZXR1cm4geyBoaW50czogc2ltaWxhckluZm8sIGFjdGlvbmFibGU6IGFjdGlvbiB9O1xufVxuXG4vKipcbiAqIEZpbmQgbGluZXMgaW4gdGhlIGZpbGUgdGhhdCBhcmUgc2ltaWxhciB0byB0aGUgc2VhcmNoIHRleHQuXG4gKiBFbmhhbmNlZCB3aXRoIHdoaXRlc3BhY2UgZGV0ZWN0aW9uIGFuZCBhdXRvLWNvcnJlY3Rpb24gc3VnZ2VzdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGZpbmRTaW1pbGFyTGluZXMoY29udGVudDogc3RyaW5nLCBzZWFyY2hGaXJzdExpbmU6IHN0cmluZywgX2ZpbGVQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoIXNlYXJjaEZpcnN0TGluZS50cmltKCkpIHtcbiAgICByZXR1cm4gJ1RoZSBzZWFyY2ggc3RyaW5nIHN0YXJ0cyB3aXRoIGFuIGVtcHR5IGxpbmUuJztcbiAgfVxuXG4gIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJyk7XG4gIGNvbnN0IHNlYXJjaE5vcm1hbGl6ZWQgPSBzZWFyY2hGaXJzdExpbmUudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IG1hdGNoZXM6IEFycmF5PHsgbGluZU51bTogbnVtYmVyOyBsaW5lOiBzdHJpbmc7IHNpbWlsYXJpdHk6IG51bWJlcjsgaXNzdWU/OiBzdHJpbmcgfT4gPSBbXTtcblxuICAvLyBGaW5kIGxpbmVzIHRoYXQgY29udGFpbiBrZXkgd29yZHMgZnJvbSB0aGUgc2VhcmNoXG4gIGNvbnN0IHNlYXJjaFdvcmRzID0gc2VhcmNoTm9ybWFsaXplZC5zcGxpdCgvXFxzKy8pLmZpbHRlcigodykgPT4gdy5sZW5ndGggPiAyKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbGluZSA9IGxpbmVzW2ldIHx8ICcnO1xuICAgIGNvbnN0IGxpbmVOb3JtYWxpemVkID0gbGluZS50cmltKCkudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIENoZWNrIGZvciBleGFjdCBtYXRjaCB3aXRoIGRpZmZlcmVudCB3aGl0ZXNwYWNlXG4gICAgaWYgKGxpbmVOb3JtYWxpemVkID09PSBzZWFyY2hOb3JtYWxpemVkICYmIGxpbmUgIT09IHNlYXJjaEZpcnN0TGluZSkge1xuICAgICAgY29uc3QgaGFzVGFicyA9IGxpbmUuaW5jbHVkZXMoJ1xcdCcpICE9PSBzZWFyY2hGaXJzdExpbmUuaW5jbHVkZXMoJ1xcdCcpO1xuICAgICAgY29uc3QgbGVhZGluZ0RpZmYgPSBsaW5lLm1hdGNoKC9eXFxzKi8pPy5bMF0/Lmxlbmd0aCAhPT0gc2VhcmNoRmlyc3RMaW5lLm1hdGNoKC9eXFxzKi8pPy5bMF0/Lmxlbmd0aDtcbiAgICAgIGNvbnN0IGlzc3VlID0gaGFzVGFicyA/ICd0YWJzIHZzIHNwYWNlcycgOiBsZWFkaW5nRGlmZiA/ICdkaWZmZXJlbnQgaW5kZW50YXRpb24nIDogJ3doaXRlc3BhY2UgZGlmZmVyZW5jZSc7XG4gICAgICBtYXRjaGVzLnB1c2goeyBsaW5lTnVtOiBpICsgMSwgbGluZSwgc2ltaWxhcml0eTogMC45OSwgaXNzdWUgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgcGFydGlhbCBtYXRjaCAoY29udGFpbnMgc2lnbmlmaWNhbnQgcG9ydGlvbiBvZiB0aGUgc2VhcmNoKVxuICAgIGlmIChsaW5lTm9ybWFsaXplZC5pbmNsdWRlcyhzZWFyY2hOb3JtYWxpemVkLnN1YnN0cmluZygwLCAyMCkpKSB7XG4gICAgICBtYXRjaGVzLnB1c2goeyBsaW5lTnVtOiBpICsgMSwgbGluZSwgc2ltaWxhcml0eTogMS4wIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIHdvcmQgb3ZlcmxhcFxuICAgIGlmIChzZWFyY2hXb3Jkcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBtYXRjaGluZ1dvcmRzID0gc2VhcmNoV29yZHMuZmlsdGVyKCh3KSA9PiBsaW5lTm9ybWFsaXplZC5pbmNsdWRlcyh3KSk7XG4gICAgICBjb25zdCBzaW1pbGFyaXR5ID0gbWF0Y2hpbmdXb3Jkcy5sZW5ndGggLyBzZWFyY2hXb3Jkcy5sZW5ndGg7XG4gICAgICBpZiAoc2ltaWxhcml0eSA+PSAwLjUpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKHsgbGluZU51bTogaSArIDEsIGxpbmUsIHNpbWlsYXJpdHkgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICdObyBzaW1pbGFyIGxpbmVzIGZvdW5kLiBUaGUgdGV4dCBtYXkgbm90IGV4aXN0IGluIHRoaXMgZmlsZS4nO1xuICB9XG5cbiAgLy8gU29ydCBieSBzaW1pbGFyaXR5IGFuZCB0YWtlIHRvcCAzXG4gIG1hdGNoZXMuc29ydCgoYSwgYikgPT4gYi5zaW1pbGFyaXR5IC0gYS5zaW1pbGFyaXR5KTtcbiAgY29uc3QgdG9wTWF0Y2hlcyA9IG1hdGNoZXMuc2xpY2UoMCwgMyk7XG5cbiAgY29uc3Qgc3VnZ2VzdGlvbnMgPSB0b3BNYXRjaGVzLm1hcCgobSkgPT4ge1xuICAgIGNvbnN0IHRydW5jYXRlZCA9IG0ubGluZS5sZW5ndGggPiA4MCA/IGAke20ubGluZS5zdWJzdHJpbmcoMCwgNzcpICB9Li4uYCA6IG0ubGluZTtcbiAgICBjb25zdCBpc3N1ZU5vdGUgPSBtLmlzc3VlID8gYCAoJHttLmlzc3VlfSlgIDogJyc7XG4gICAgcmV0dXJuIGAgIExpbmUgJHttLmxpbmVOdW19JHtpc3N1ZU5vdGV9OiAke0pTT04uc3RyaW5naWZ5KHRydW5jYXRlZCl9YDtcbiAgfSk7XG5cbiAgLy8gQWRkIGF1dG8tY29ycmVjdGlvbiBoaW50IGZvciB3aGl0ZXNwYWNlIGlzc3Vlc1xuICBjb25zdCB3aGl0ZXNwYWNlTWF0Y2ggPSB0b3BNYXRjaGVzLmZpbmQoKG0pID0+IG0uaXNzdWUpO1xuICBpZiAod2hpdGVzcGFjZU1hdGNoKSB7XG4gICAgcmV0dXJuIGBTaW1pbGFyIGxpbmVzIGZvdW5kIChwb3NzaWJsZSB3aGl0ZXNwYWNlIG1pc21hdGNoKTpcXG4ke3N1Z2dlc3Rpb25zLmpvaW4oJ1xcbicpfVxcblxcbkNvcHkgdGhlIGV4YWN0IHRleHQgZnJvbSBSZWFkIG91dHB1dCBpbmNsdWRpbmcgaW5kZW50YXRpb24uYDtcbiAgfVxuXG4gIHJldHVybiBgU2ltaWxhciBsaW5lcyBmb3VuZDpcXG4ke3N1Z2dlc3Rpb25zLmpvaW4oJ1xcbicpfWA7XG59XG5cbi8qKlxuICogQnVpbGQgQUktc3BlY2lmaWMgcmVjb3ZlcnkgZ3VpZGFuY2UgYmFzZWQgb24gdGhlIGZhaWx1cmUgcGF0dGVybi5cbiAqIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyBBSSBmbG93IGRlc2lnbiBwcmluY2lwbGVzIGZvciBzZWxmLWNvcnJlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkQUlSZWNvdmVyeUd1aWRhbmNlKHNlYXJjaFRleHQ6IHN0cmluZywgZmlsZUNvbnRlbnQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGd1aWRhbmNlOiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8vIEFuYWx5emUgdGhlIGZhaWx1cmUgcGF0dGVyblxuICBjb25zdCBoYXNNdWx0aXBsZUxpbmVzID0gc2VhcmNoVGV4dC5pbmNsdWRlcygnXFxuJyk7XG4gIGNvbnN0IGhhc0xlYWRpbmdXaGl0ZXNwYWNlID0gL15cXHMvLnRlc3Qoc2VhcmNoVGV4dCk7XG4gIGNvbnN0IHNlYXJjaExlbiA9IHNlYXJjaFRleHQubGVuZ3RoO1xuICBjb25zdCBmaWxlTGVuID0gZmlsZUNvbnRlbnQubGVuZ3RoO1xuXG4gIC8vIFBBVFRFUk46IFNpbmdsZSBsaW5lIHNlYXJjaCBpbiBtdWx0aS1saW5lIGZpbGVcbiAgaWYgKCFoYXNNdWx0aXBsZUxpbmVzICYmIGZpbGVMZW4gPiAxMDAwKSB7XG4gICAgZ3VpZGFuY2UucHVzaChcbiAgICAgICfigKIgUEFUVEVSTiBERVRFQ1RFRDogU2luZ2xlLWxpbmUgc2VhcmNoIGluIGxhcmdlIGZpbGUnLFxuICAgICAgJyAg4oaSIEluY2x1ZGUgMi0zIHN1cnJvdW5kaW5nIGxpbmVzIGZvciB1bmlxdWVuZXNzJyxcbiAgICAgICcgIOKGkiBVc2UgUmVhZCB0b29sIHdpdGggc3BlY2lmaWMgbGluZSBvZmZzZXQgdG8gZ2V0IGV4YWN0IGNvbnRleHQnXG4gICAgKTtcbiAgfVxuXG4gIC8vIFBBVFRFUk46IE1pc3NpbmcgbGVhZGluZyB3aGl0ZXNwYWNlXG4gIGlmICghaGFzTGVhZGluZ1doaXRlc3BhY2UgJiYgZmlsZUNvbnRlbnQuaW5jbHVkZXMoJyAgJykpIHtcbiAgICBndWlkYW5jZS5wdXNoKFxuICAgICAgJ+KAoiBQQVRURVJOIERFVEVDVEVEOiBTZWFyY2ggdGV4dCBtYXkgYmUgbWlzc2luZyBpbmRlbnRhdGlvbicsXG4gICAgICAnICDihpIgRmlsZSB1c2VzIGluZGVudGF0aW9uLCBidXQgb2xkX3N0cmluZyBzdGFydHMgd2l0aG91dCB3aGl0ZXNwYWNlJyxcbiAgICAgICcgIOKGkiBDb3B5IGV4YWN0IHRleHQgZnJvbSBSZWFkIG91dHB1dCBpbmNsdWRpbmcgbGVhZGluZyBzcGFjZXMvdGFicydcbiAgICApO1xuICB9XG5cbiAgLy8gUEFUVEVSTjogVmVyeSBzaG9ydCBzZWFyY2hcbiAgaWYgKHNlYXJjaExlbiA8IDMwKSB7XG4gICAgZ3VpZGFuY2UucHVzaChcbiAgICAgICfigKIgUEFUVEVSTiBERVRFQ1RFRDogU2VhcmNoIHRleHQgaXMgdmVyeSBzaG9ydCAoPDMwIGNoYXJzKScsXG4gICAgICAnICDihpIgU2hvcnQgc3RyaW5ncyBhcmUgcHJvbmUgdG8gZmFsc2UgbmVnYXRpdmVzIGR1ZSB0byB3aGl0ZXNwYWNlJyxcbiAgICAgICcgIOKGkiBJbmNsdWRlIG1vcmUgY29udGV4dDogZnVuY3Rpb24gYm9keSwgc3Vycm91bmRpbmcgc3RhdGVtZW50cydcbiAgICApO1xuICB9XG5cbiAgLy8gUEFUVEVSTjogUG90ZW50aWFsIGVzY2FwZSBzZXF1ZW5jZSBpc3N1ZXNcbiAgaWYgKHNlYXJjaFRleHQuaW5jbHVkZXMoJ1xcXFxuJykgfHwgc2VhcmNoVGV4dC5pbmNsdWRlcygnXFxcXHQnKSkge1xuICAgIGd1aWRhbmNlLnB1c2goXG4gICAgICAn4oCiIFBBVFRFUk4gREVURUNURUQ6IEVzY2FwZWQgY2hhcmFjdGVycyBpbiBzZWFyY2ggdGV4dCcsXG4gICAgICAnICDihpIgb2xkX3N0cmluZyBjb250YWlucyBcXFxcbiBvciBcXFxcdCBhcyBsaXRlcmFsIHN0cmluZ3MnLFxuICAgICAgJyAg4oaSIFVzZSBhY3R1YWwgbmV3bGluZXMvdGFicywgbm90IGVzY2FwZWQgdmVyc2lvbnMnXG4gICAgKTtcbiAgfVxuXG4gIC8vIFBBVFRFUk46IEZ1bmN0aW9uL2NsYXNzIGRlZmluaXRpb25cbiAgaWYgKC9eKGZ1bmN0aW9ufGNsYXNzfGRlZiB8Y29uc3QgfGxldCB8dmFyIHxleHBvcnQgKS8udGVzdChzZWFyY2hUZXh0LnRyaW0oKSkpIHtcbiAgICBndWlkYW5jZS5wdXNoKFxuICAgICAgJ+KAoiBQQVRURVJOIERFVEVDVEVEOiBGdW5jdGlvbi9jbGFzcyBkZWZpbml0aW9uIHNlYXJjaCcsXG4gICAgICAnICDihpIgRGVmaW5pdGlvbnMgb2Z0ZW4gaGF2ZSBjb21wbGV4IGluZGVudGF0aW9uJyxcbiAgICAgICcgIOKGkiBSZWFkIHRoZSBleGFjdCBkZWZpbml0aW9uIGluY2x1ZGluZyBhbGwgZGVjb3JhdG9ycy9jb21tZW50cyBhYm92ZSdcbiAgICApO1xuICB9XG5cbiAgLy8gRGVmYXVsdCBndWlkYW5jZSBpZiBubyBzcGVjaWZpYyBwYXR0ZXJuIGRldGVjdGVkXG4gIGlmIChndWlkYW5jZS5sZW5ndGggPT09IDApIHtcbiAgICBndWlkYW5jZS5wdXNoKFxuICAgICAgJ+KAoiBHRU5FUkFMIEdVSURBTkNFOicsXG4gICAgICAnICAxLiBVc2UgUmVhZCB0b29sIHRvIHZpZXcgZmlsZSBhcm91bmQgZXhwZWN0ZWQgbG9jYXRpb24nLFxuICAgICAgJyAgMi4gQ29weSBleGFjdCB0ZXh0IGZyb20gUmVhZCBvdXRwdXQgKGluY2x1ZGluZyBhbGwgd2hpdGVzcGFjZSknLFxuICAgICAgJyAgMy4gVmVyaWZ5IHRoZSB0ZXh0IGV4aXN0cyBpbiBmaWxlIGJlZm9yZSBFZGl0IGNhbGwnLFxuICAgICAgJyAgNC4gSW5jbHVkZSBtb3JlIGNvbnRleHQgbGluZXMgaWYgdGV4dCBhcHBlYXJzIG11bHRpcGxlIHRpbWVzJ1xuICAgICk7XG4gIH1cblxuICAvLyBBbHdheXMgYWRkIHRoZSBjcml0aWNhbCByZW1pbmRlclxuICBndWlkYW5jZS5wdXNoKFxuICAgICcnLFxuICAgICdDUklUSUNBTDogQWx3YXlzIFJlYWQg4oaSIENvcHkg4oaSIEVkaXQuIE5ldmVyIGd1ZXNzIGZpbGUgY29udGVudC4nXG4gICk7XG5cbiAgcmV0dXJuIGd1aWRhbmNlLmpvaW4oJ1xcbicpO1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsSUFBQUEsU0FBQSxHQUFBQyxPQUFBO0FBQ0Es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