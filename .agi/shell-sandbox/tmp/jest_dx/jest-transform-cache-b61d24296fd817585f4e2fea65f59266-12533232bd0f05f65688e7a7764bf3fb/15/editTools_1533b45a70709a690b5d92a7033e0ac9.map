{"version":3,"names":["_promises","require","_nodePath","_errors","_diffUtils","fileEditAttempts","Map","MAX_EDIT_ATTEMPTS_PER_FILE","EDIT_ATTEMPT_RESET_MS","createEditTools","workingDir","name","description","parameters","type","properties","file_path","old_string","new_string","default","replace_all","required","additionalProperties","handler","args","performSurgicalEdit","pathArg","oldString","newStringRaw","replaceAll","replacementString","trim","undefined","filePath","resolveFilePath","fileExists","stat","dir","dirname","mkdir","recursive","writeFile","relativePath","relative","displayPath","startsWith","lineCount","split","length","diffSegments","buildDiffSegmentsFast","addedLines","filter","s","diffLines","formatDiffLines","diffBlock","join","currentContent","readFile","targetString","matchNote","includes","unescaped","unescapeLiteral","flexibleMatch","matchWithFlexibleWhitespace","firstLine","suggestions","findSimilarLinesWithSuggestion","aiGuidance","buildAIRecoveryGuidance","JSON","stringify","substring","hints","actionable","adjusted","alignIndentation","occurrences","countOccurrences","newContent","replace","diffResult","buildDiffWithContext","now","Date","attempts","get","lastTimestamp","set","count","lastContent","Promise","resolve","setTimeout","verifyContent","editAttempts","additions","removals","occurrencesText","noteText","formatDiffClaudeStyle","segments","additionText","removalText","summaryParts","push","summaryText","error","buildError","old_string_length","new_string_length","path","normalized","text","search","position","indexOf","value","content","normalizedPattern","buildWhitespaceFlexiblePattern","regex","RegExp","match","escaped","lines","flexibleLines","map","line","target","replacement","targetLines","replacementLines","idx","targetLine","targetIndent","lineIndent","missing","slice","trimStart","searchFirstLine","_fullSearchText","similarInfo","findSimilarLines","lineMatch","lineNum","parseInt","action","Math","max","_filePath","searchNormalized","toLowerCase","matches","searchWords","w","i","lineNormalized","hasTabs","leadingDiff","issue","similarity","matchingWords","sort","a","b","topMatches","m","truncated","issueNote","whitespaceMatch","find","searchText","fileContent","guidance","hasMultipleLines","hasLeadingWhitespace","test","searchLen","fileLen"],"sources":["editTools.ts"],"sourcesContent":["import { readFile, writeFile, stat, mkdir } from 'node:fs/promises';\nimport { join, relative, dirname } from 'node:path';\nimport type { ToolDefinition } from '../core/toolRuntime.js';\nimport { buildError } from '../core/errors.js';\nimport { buildDiffSegmentsFast, formatDiffLines, buildDiffWithContext, formatDiffClaudeStyle } from './diffUtils.js';\n\n/**\n * Track edit attempts per file to detect when edits keep being reverted (e.g., by linters/hooks)\n */\nconst fileEditAttempts = new Map<string, { count: number; lastContent: string; lastTimestamp: number }>();\nconst MAX_EDIT_ATTEMPTS_PER_FILE = 3;\nconst EDIT_ATTEMPT_RESET_MS = 60000; // Reset counter after 1 minute of no edits\n\n/**\n * Creates the Edit tool for surgical file modifications using exact string replacement.\n *\n * This tool performs string-based edits without requiring full file rewrites,\n * making it ideal for targeted changes while preserving exact formatting and indentation.\n *\n * Features:\n * - Exact string matching (preserves indentation)\n * - Replace all occurrences or enforce uniqueness\n * - Unified diff preview\n * - Validation before writing\n *\n * @param workingDir - The working directory for resolving relative paths\n * @returns Array containing the Edit tool definition\n */\nexport function createEditTools(workingDir: string): ToolDefinition[] {\n  return [\n    {\n      name: 'Edit',\n      description:\n        'Performs exact string replacements in files. CRITICAL: For existing files, you MUST use the Read tool FIRST to get the exact text including whitespace and indentation, then copy it into old_string. The edit will FAIL if old_string is not unique unless replace_all is true. To CREATE a new file, use empty old_string (no prior read needed). To DELETE text, use empty new_string.',\n      parameters: {\n        type: 'object',\n        properties: {\n          file_path: {\n            type: 'string',\n            description: 'The absolute path to the file to modify or create',\n          },\n          old_string: {\n            type: 'string',\n            description: 'The exact text to replace (must match precisely including whitespace and indentation). For existing files, use read_file FIRST, then copy the exact text from its output (excluding line numbers). Use empty string \"\" to create a new file without needing a prior read.',\n          },\n          new_string: {\n            type: 'string',\n            default: '',\n            description:\n              'The text to replace it with. Use empty string \"\" to delete the old_string. For new files, this is the full content. Defaults to \"\" when omitted.',\n          },\n          replace_all: {\n            type: 'boolean',\n            description:\n              'Replace all occurrences of old_string (default false). When false, the edit fails if old_string appears multiple times.',\n          },\n        },\n        required: ['file_path', 'old_string'],\n        additionalProperties: false,\n      },\n      handler: async (args) => performSurgicalEdit(workingDir, args),\n    },\n  ];\n}\n\nexport interface EditArguments {\n  file_path?: unknown;\n  old_string?: unknown;\n  new_string?: unknown;\n  replace_all?: unknown;\n}\n\n/**\n * Shared edit executor used by both legacy and unified tool flows.\n * Provides consistent validation, creation/deletion handling, and diff output.\n */\nexport async function performSurgicalEdit(\n  workingDir: string,\n  args: EditArguments | Record<string, unknown>\n): Promise<string> {\n  const pathArg = (args as EditArguments)['file_path'];\n  const oldString = (args as EditArguments)['old_string'];\n  const newStringRaw = (args as EditArguments)['new_string'];\n  const replaceAll = (args as EditArguments)['replace_all'] === true;\n  let replacementString = typeof newStringRaw === 'string' ? newStringRaw : '';\n\n  // Validate inputs\n  if (typeof pathArg !== 'string' || !pathArg.trim()) {\n    return 'Error: file_path must be a non-empty string.';\n  }\n  if (typeof oldString !== 'string') {\n    return 'Error: old_string must be a string (use \"\" for empty).';\n  }\n  if (newStringRaw !== undefined && typeof newStringRaw !== 'string') {\n    return 'Error: new_string must be a string (use \"\" for empty).';\n  }\n  // Only error if both are identical AND non-empty (no-op edit)\n  // Allow: empty old + content = create, content + empty new = delete\n  if (oldString === replacementString && oldString !== '') {\n    return 'Error: old_string and new_string are identical. No changes would be made.';\n  }\n  // Both empty is also a no-op\n  if (oldString === '' && replacementString === '') {\n    return 'Error: Both old_string and new_string are empty. Provide content to create a file or text to replace.';\n  }\n\n  try {\n    const filePath = resolveFilePath(workingDir, pathArg);\n\n    // Check if file exists\n    let fileExists = false;\n    try {\n      await stat(filePath);\n      fileExists = true;\n    } catch {\n      fileExists = false;\n    }\n\n    // Handle file creation mode (empty old_string)\n    if (oldString === '') {\n      if (fileExists) {\n        return `Error: File already exists: ${filePath}\\nTo modify an existing file, provide the exact text to replace in old_string.`;\n      }\n\n      // Create parent directories if needed\n      const dir = dirname(filePath);\n      await mkdir(dir, { recursive: true });\n\n      // Write new file\n      await writeFile(filePath, replacementString, 'utf-8');\n\n      const relativePath = relative(workingDir, filePath);\n      const displayPath = relativePath && !relativePath.startsWith('..') ? relativePath : filePath;\n      const lineCount = replacementString.split('\\n').length;\n      const diffSegments = buildDiffSegmentsFast('', replacementString);\n      const addedLines = diffSegments.filter((s) => s.type === 'added').length;\n      const diffLines = formatDiffLines(diffSegments, true);\n      const diffBlock =\n        diffLines.length > 0 ? diffLines.join('\\n') : '(No visual diff - whitespace or formatting changes only)';\n\n      return [\n        `⏺ Create(${displayPath})`,\n        `  ⎿  Created ${displayPath} with ${addedLines} additions`,\n        `     ${lineCount} line${lineCount === 1 ? '' : 's'} written`,\n        diffBlock,\n      ].join('\\n');\n    }\n\n    // For modifications, file must exist\n    if (!fileExists) {\n      return `Error: File not found: ${filePath}\\nTo create a new file, use empty old_string (\"\").`;\n    }\n\n    // Read current content (async for speed)\n    const currentContent = await readFile(filePath, 'utf-8');\n\n    // Normalize escaped literals and whitespace differences to reduce mismatch errors\n    let targetString = oldString;\n    let matchNote: string | null = null;\n    if (!currentContent.includes(targetString)) {\n      const unescaped = unescapeLiteral(oldString);\n      if (unescaped !== oldString && currentContent.includes(unescaped)) {\n        targetString = unescaped;\n        matchNote = 'normalized escaped old_string';\n      }\n    }\n\n    if (!currentContent.includes(targetString)) {\n      const flexibleMatch = matchWithFlexibleWhitespace(currentContent, targetString);\n      if (flexibleMatch) {\n        targetString = flexibleMatch;\n        matchNote = matchNote ? matchNote : 'normalized whitespace in old_string';\n      }\n    }\n\n    // Check if old_string exists in file\n    if (!currentContent.includes(targetString)) {\n      // Provide helpful debugging info when match fails\n      const firstLine = oldString.split('\\n')[0] || '';\n      const suggestions = findSimilarLinesWithSuggestion(currentContent, firstLine, oldString, filePath, workingDir);\n\n      // AI Flow Design: Provide structured guidance for self-correction\n      const aiGuidance = buildAIRecoveryGuidance(oldString, currentContent);\n\n      return [\n        'Error: old_string not found in file.',\n        '',\n        `File: ${filePath}`,\n        `Searching for: ${JSON.stringify(firstLine.substring(0, 80))}${firstLine.length > 80 ? '...' : ''}`,\n        '',\n        suggestions.hints,\n        '',\n        suggestions.actionable ? 'RECOMMENDED ACTION:' : 'Guidance:',\n        suggestions.actionable ? suggestions.actionable : '- Ensure exact whitespace/indentation matches\\n- Copy text directly from Read output\\n- Check for tabs vs spaces',\n        '',\n        '---',\n        'AI SELF-CORRECTION GUIDANCE:',\n        aiGuidance,\n      ].join('\\n');\n    }\n\n    // Count occurrences\n    // Preserve indentation when we had to normalize whitespace to find the match\n    if (matchNote === 'normalized whitespace in old_string') {\n      const adjusted = alignIndentation(targetString, replacementString);\n      if (adjusted !== replacementString) {\n        replacementString = adjusted;\n      }\n    }\n\n    const occurrences = countOccurrences(currentContent, targetString);\n\n    if (!replaceAll && occurrences > 1) {\n      return `Error: old_string appears ${occurrences} times in the file. Either:\\n1. Provide a larger unique string that includes more context\\n2. Set replace_all: true to replace all ${occurrences} occurrences\\n\\nFile: ${filePath}`;\n    }\n\n    // Perform replacement\n    const newContent = replaceAll\n      ? currentContent.split(targetString).join(replacementString)\n      : currentContent.replace(targetString, replacementString);\n\n    // Generate diff with context lines (AGI CLI style)\n    const diffResult = buildDiffWithContext(currentContent, newContent, 2);\n\n    // Check for repeated edit attempts on same file (detect linter/hook reversion loops)\n    const now = Date.now();\n    const attempts = fileEditAttempts.get(filePath);\n    if (attempts) {\n      // Reset if enough time has passed\n      if (now - attempts.lastTimestamp > EDIT_ATTEMPT_RESET_MS) {\n        fileEditAttempts.set(filePath, { count: 1, lastContent: newContent, lastTimestamp: now });\n      } else if (attempts.lastContent === newContent) {\n        // Same exact edit being attempted again - likely in a loop\n        attempts.count++;\n        attempts.lastTimestamp = now;\n        if (attempts.count > MAX_EDIT_ATTEMPTS_PER_FILE) {\n          return [\n            `Error: Edit loop detected on ${filePath}`,\n            '',\n            `This edit has been attempted ${attempts.count} times in quick succession.`,\n            'The file may be getting reverted by a linter, formatter, or pre-commit hook.',\n            '',\n            'To resolve:',\n            '1. Check for active file watchers or formatters',\n            '2. Disable auto-formatting temporarily',\n            '3. Or accept the current file state and move on',\n            '',\n            'STOPPING to prevent infinite loop.',\n          ].join('\\n');\n        }\n      } else {\n        // Different edit - reset counter but track the new content\n        fileEditAttempts.set(filePath, { count: 1, lastContent: newContent, lastTimestamp: now });\n      }\n    } else {\n      fileEditAttempts.set(filePath, { count: 1, lastContent: newContent, lastTimestamp: now });\n    }\n\n    // Write file (async for speed)\n    await writeFile(filePath, newContent, 'utf-8');\n\n    // Verify the edit persisted (detect immediate reversion by hooks/watchers)\n    // Small delay to allow any file watchers to trigger\n    await new Promise(resolve => setTimeout(resolve, 50));\n    const verifyContent = await readFile(filePath, 'utf-8');\n    if (verifyContent !== newContent) {\n      // File was modified after our write - likely by a linter/formatter\n      const editAttempts = fileEditAttempts.get(filePath);\n      if (editAttempts) {\n        editAttempts.count++;\n      }\n      return [\n        `Warning: Edit was immediately modified by an external process.`,\n        '',\n        `File: ${filePath}`,\n        'The edit was written but the file content changed immediately after.',\n        'This is likely caused by a linter, formatter, or file watcher.',\n        '',\n        'The current file state may differ from the intended edit.',\n        'Consider disabling auto-formatting or accepting the modified result.',\n      ].join('\\n');\n    }\n\n    // Build summary (AGI CLI style)\n    const relativePath = relative(workingDir, filePath);\n    const displayPath = relativePath && !relativePath.startsWith('..') ? relativePath : filePath;\n    const { additions, removals } = diffResult;\n    const occurrencesText = replaceAll ? ` (${occurrences} occurrence${occurrences > 1 ? 's' : ''})` : '';\n    const noteText = matchNote ? ` [${matchNote}]` : '';\n\n    // Format diff with colors for terminal display (AGI CLI style)\n    const diffLines = formatDiffClaudeStyle(diffResult.segments, true);\n    const diffBlock =\n      diffLines.length > 0 ? diffLines.join('\\n') : '      (No visual diff - whitespace or formatting changes only)';\n\n    // Build AGI CLI style output:\n    // ⏺ Update(filepath)\n    //   ⎿  Updated filepath with N additions and M removals\n    //       41    }\n    //       42 +   new line\n    const additionText = additions === 1 ? '1 addition' : `${additions} additions`;\n    const removalText = removals === 1 ? '1 removal' : `${removals} removals`;\n    const summaryParts = [];\n    if (additions > 0) summaryParts.push(additionText);\n    if (removals > 0) summaryParts.push(removalText);\n    const summaryText = summaryParts.length > 0 ? summaryParts.join(' and ') : 'no changes';\n\n    return [\n      `⏺ Update(${displayPath})${occurrencesText}${noteText}`,\n      `  ⎿  Updated ${displayPath} with ${summaryText}`,\n      diffBlock,\n    ].join('\\n');\n  } catch (error: unknown) {\n    return buildError('editing file', error, {\n      file_path: typeof pathArg === 'string' ? pathArg : '',\n      old_string_length: typeof oldString === 'string' ? oldString.length : 0,\n      new_string_length: typeof replacementString === 'string' ? replacementString.length : 0,\n    });\n  }\n}\n\nfunction resolveFilePath(workingDir: string, path: string): string {\n  const normalized = path.trim();\n  return normalized.startsWith('/') ? normalized : join(workingDir, normalized);\n}\n\nfunction countOccurrences(text: string, search: string): number {\n  if (!search) return 0;\n  let count = 0;\n  let position = 0;\n\n  while ((position = text.indexOf(search, position)) !== -1) {\n    count++;\n    position += search.length;\n  }\n\n  return count;\n}\n\n/**\n * Convert common escaped sequences (\\\\n, \\\\r, \\\\t, \\\\\\\\) into their literal forms.\n */\nfunction unescapeLiteral(value: string): string {\n  if (!value.includes('\\\\')) return value;\n  return value\n    .replace(/\\\\\\\\/g, '\\\\')\n    .replace(/\\\\n/g, '\\n')\n    .replace(/\\\\r/g, '\\r')\n    .replace(/\\\\t/g, '\\t');\n}\n\n/**\n * Try to locate the search string allowing whitespace differences (indentation, spacing).\n * Returns the exact substring from the original content when matched.\n */\nfunction matchWithFlexibleWhitespace(content: string, search: string): string | null {\n  const normalizedPattern = buildWhitespaceFlexiblePattern(search);\n  if (!normalizedPattern) {\n    return null;\n  }\n  const regex = new RegExp(normalizedPattern, 's');\n  const match = content.match(regex);\n  return match ? match[0] : null;\n}\n\nfunction buildWhitespaceFlexiblePattern(search: string): string | null {\n  if (!search.trim()) {\n    return null;\n  }\n  // Escape regex metacharacters\n  const escaped = search.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  // Only allow flexible whitespace WITHIN lines, not across lines\n  // This prevents matching across completely different code structures\n  // Split by newlines, make each line flexible, then require exact newline boundaries\n  const lines = escaped.split(/\\\\n|\\n/);\n  const flexibleLines = lines.map(line => line.replace(/[ \\t]+/g, '[ \\\\t]+'));\n  // Rejoin with flexible newline matching (allows \\r\\n or \\n)\n  return flexibleLines.join('\\\\r?\\\\n');\n}\n\n/**\n * When whitespace normalization is used, keep the replacement aligned with the matched indentation.\n * If a line in the replacement has no indentation, inherit indentation from the matched line.\n */\nfunction alignIndentation(target: string, replacement: string): string {\n  const targetLines = target.split('\\n');\n  const replacementLines = replacement.split('\\n');\n  if (targetLines.length !== replacementLines.length) {\n    return replacement;\n  }\n\n  const adjusted = replacementLines.map((line, idx) => {\n    const targetLine = targetLines[idx] ?? '';\n    const targetIndent = targetLine.match(/^\\s*/)?.[0] ?? '';\n    if (!line.trim()) {\n      return targetIndent;\n    }\n    const lineIndent = line.match(/^\\s*/)?.[0] ?? '';\n    if (lineIndent.length < targetIndent.length) {\n      const missing = targetIndent.slice(lineIndent.length);\n      return `${lineIndent}${missing}${line.trimStart()}`;\n    }\n    return line;\n  });\n\n  return adjusted.join('\\n');\n}\n\n/**\n * Enhanced similar line finder with actionable suggestions for AI.\n * Provides exact text to use in old_string and clear next steps.\n */\nfunction findSimilarLinesWithSuggestion(\n  content: string,\n  searchFirstLine: string,\n  _fullSearchText: string,\n  filePath: string,\n  workingDir: string\n): { hints: string; actionable: string | null } {\n  const similarInfo = findSimilarLines(content, searchFirstLine, filePath);\n\n  // Extract line numbers from similar lines\n  const lineMatch = similarInfo.match(/Line (\\d+)/);\n  if (lineMatch && lineMatch[1]) {\n    const lineNum = parseInt(lineMatch[1], 10);\n    const relativePath = relative(workingDir, filePath);\n    const displayPath = relativePath && !relativePath.startsWith('..') ? relativePath : filePath;\n\n    // Provide concrete action: Read the file to get exact text\n    const action = [\n      `1. Use Read tool to view ${displayPath} starting at line ${Math.max(1, lineNum - 5)}`,\n      `2. Copy the EXACT text from the Read output (including all indentation)`,\n      `3. Use that exact text as old_string in your Edit call`,\n      `4. Ensure you copy multiple lines if needed for uniqueness`,\n    ].join('\\n   ');\n\n    return { hints: similarInfo, actionable: action };\n  }\n\n  // No similar lines found - suggest reading entire file\n  const relativePath = relative(workingDir, filePath);\n  const displayPath = relativePath && !relativePath.startsWith('..') ? relativePath : filePath;\n  const action = [\n    `1. Use Read tool to view the entire file: ${displayPath}`,\n    `2. Locate the text you want to change`,\n    `3. Copy the EXACT text including whitespace`,\n    `4. Paste it as old_string in your Edit call`,\n  ].join('\\n   ');\n\n  return { hints: similarInfo, actionable: action };\n}\n\n/**\n * Find lines in the file that are similar to the search text.\n * Enhanced with whitespace detection and auto-correction suggestions.\n */\nfunction findSimilarLines(content: string, searchFirstLine: string, _filePath: string): string {\n  if (!searchFirstLine.trim()) {\n    return 'The search string starts with an empty line.';\n  }\n\n  const lines = content.split('\\n');\n  const searchNormalized = searchFirstLine.trim().toLowerCase();\n  const matches: Array<{ lineNum: number; line: string; similarity: number; issue?: string }> = [];\n\n  // Find lines that contain key words from the search\n  const searchWords = searchNormalized.split(/\\s+/).filter((w) => w.length > 2);\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i] || '';\n    const lineNormalized = line.trim().toLowerCase();\n\n    // Check for exact match with different whitespace\n    if (lineNormalized === searchNormalized && line !== searchFirstLine) {\n      const hasTabs = line.includes('\\t') !== searchFirstLine.includes('\\t');\n      const leadingDiff = line.match(/^\\s*/)?.[0]?.length !== searchFirstLine.match(/^\\s*/)?.[0]?.length;\n      const issue = hasTabs ? 'tabs vs spaces' : leadingDiff ? 'different indentation' : 'whitespace difference';\n      matches.push({ lineNum: i + 1, line, similarity: 0.99, issue });\n      continue;\n    }\n\n    // Check for partial match (contains significant portion of the search)\n    if (lineNormalized.includes(searchNormalized.substring(0, 20))) {\n      matches.push({ lineNum: i + 1, line, similarity: 1.0 });\n      continue;\n    }\n\n    // Check for word overlap\n    if (searchWords.length > 0) {\n      const matchingWords = searchWords.filter((w) => lineNormalized.includes(w));\n      const similarity = matchingWords.length / searchWords.length;\n      if (similarity >= 0.5) {\n        matches.push({ lineNum: i + 1, line, similarity });\n      }\n    }\n  }\n\n  if (matches.length === 0) {\n    return 'No similar lines found. The text may not exist in this file.';\n  }\n\n  // Sort by similarity and take top 3\n  matches.sort((a, b) => b.similarity - a.similarity);\n  const topMatches = matches.slice(0, 3);\n\n  const suggestions = topMatches.map((m) => {\n    const truncated = m.line.length > 80 ? `${m.line.substring(0, 77)  }...` : m.line;\n    const issueNote = m.issue ? ` (${m.issue})` : '';\n    return `  Line ${m.lineNum}${issueNote}: ${JSON.stringify(truncated)}`;\n  });\n\n  // Add auto-correction hint for whitespace issues\n  const whitespaceMatch = topMatches.find((m) => m.issue);\n  if (whitespaceMatch) {\n    return `Similar lines found (possible whitespace mismatch):\\n${suggestions.join('\\n')}\\n\\nCopy the exact text from Read output including indentation.`;\n  }\n\n  return `Similar lines found:\\n${suggestions.join('\\n')}`;\n}\n\n/**\n * Build AI-specific recovery guidance based on the failure pattern.\n * This function implements AI flow design principles for self-correction.\n */\nfunction buildAIRecoveryGuidance(searchText: string, fileContent: string): string {\n  const guidance: string[] = [];\n\n  // Analyze the failure pattern\n  const hasMultipleLines = searchText.includes('\\n');\n  const hasLeadingWhitespace = /^\\s/.test(searchText);\n  const searchLen = searchText.length;\n  const fileLen = fileContent.length;\n\n  // PATTERN: Single line search in multi-line file\n  if (!hasMultipleLines && fileLen > 1000) {\n    guidance.push(\n      '• PATTERN DETECTED: Single-line search in large file',\n      '  → Include 2-3 surrounding lines for uniqueness',\n      '  → Use Read tool with specific line offset to get exact context'\n    );\n  }\n\n  // PATTERN: Missing leading whitespace\n  if (!hasLeadingWhitespace && fileContent.includes('  ')) {\n    guidance.push(\n      '• PATTERN DETECTED: Search text may be missing indentation',\n      '  → File uses indentation, but old_string starts without whitespace',\n      '  → Copy exact text from Read output including leading spaces/tabs'\n    );\n  }\n\n  // PATTERN: Very short search\n  if (searchLen < 30) {\n    guidance.push(\n      '• PATTERN DETECTED: Search text is very short (<30 chars)',\n      '  → Short strings are prone to false negatives due to whitespace',\n      '  → Include more context: function body, surrounding statements'\n    );\n  }\n\n  // PATTERN: Potential escape sequence issues\n  if (searchText.includes('\\\\n') || searchText.includes('\\\\t')) {\n    guidance.push(\n      '• PATTERN DETECTED: Escaped characters in search text',\n      '  → old_string contains \\\\n or \\\\t as literal strings',\n      '  → Use actual newlines/tabs, not escaped versions'\n    );\n  }\n\n  // PATTERN: Function/class definition\n  if (/^(function|class|def |const |let |var |export )/.test(searchText.trim())) {\n    guidance.push(\n      '• PATTERN DETECTED: Function/class definition search',\n      '  → Definitions often have complex indentation',\n      '  → Read the exact definition including all decorators/comments above'\n    );\n  }\n\n  // Default guidance if no specific pattern detected\n  if (guidance.length === 0) {\n    guidance.push(\n      '• GENERAL GUIDANCE:',\n      '  1. Use Read tool to view file around expected location',\n      '  2. Copy exact text from Read output (including all whitespace)',\n      '  3. Verify the text exists in file before Edit call',\n      '  4. Include more context lines if text appears multiple times'\n    );\n  }\n\n  // Always add the critical reminder\n  guidance.push(\n    '',\n    'CRITICAL: Always Read → Copy → Edit. Never guess file content.'\n  );\n\n  return guidance.join('\\n');\n}\n"],"mappings":"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","ignoreList":[]}