{"version":3,"names":["_nodeFs","require","_nodePath","_nodeUrl","readPackageInfo","importMetaUrl","options","maxDepth","startDir","dirname","fileURLToPath","packagePath","findNearestPackageJson","payload","JSON","parse","readFileSync","name","undefined","version","readPackageVersion","fallback","current","depth","candidate","resolve","existsSync","parent"],"sources":["packageInfo.ts"],"sourcesContent":["import { readFileSync, existsSync } from 'node:fs';\nimport { dirname, resolve } from 'node:path';\nimport { fileURLToPath } from 'node:url';\n\nexport interface PackageInfo {\n  name?: string;\n  version?: string;\n}\n\n/**\n * Locate and read the nearest package.json starting from the caller's module URL.\n * This mirrors prior per-file helpers but centralizes the logic so CLI entrypoints\n * and tests stay consistent even if their relative paths change.\n */\nexport function readPackageInfo(\n  importMetaUrl: string | URL,\n  options?: { maxDepth?: number }\n): PackageInfo {\n  const maxDepth = options?.maxDepth ?? 6;\n  const startDir = dirname(fileURLToPath(importMetaUrl));\n  const packagePath = findNearestPackageJson(startDir, maxDepth);\n  if (!packagePath) {\n    return {};\n  }\n\n  try {\n    const payload = JSON.parse(readFileSync(packagePath, 'utf8')) as PackageInfo;\n    return {\n      name: typeof payload.name === 'string' ? payload.name : undefined,\n      version: typeof payload.version === 'string' ? payload.version : undefined,\n    };\n  } catch {\n    return {};\n  }\n}\n\nexport function readPackageVersion(importMetaUrl: string | URL, fallback = '0.0.0'): string {\n  return readPackageInfo(importMetaUrl).version ?? fallback;\n}\n\nfunction findNearestPackageJson(startDir: string, maxDepth: number): string | null {\n  let current = startDir;\n  for (let depth = 0; depth <= maxDepth; depth += 1) {\n    const candidate = resolve(current, 'package.json');\n    if (existsSync(candidate)) {\n      return candidate;\n    }\n    const parent = dirname(current);\n    if (parent === current) {\n      break;\n    }\n    current = parent;\n  }\n  return null;\n}\n"],"mappings":";;;;;;;AAAA,IAAAA,OAAA,GAAAC,OAAA;AACA,IAAAC,SAAA,GAAAD,OAAA;AACA,IAAAE,QAAA,GAAAF,OAAA;AAOA;AACA;AACA;AACA;AACA;AACO,SAASG,eAAeA,CAC7BC,aAA2B,EAC3BC,OAA+B,EAClB;EACb,MAAMC,QAAQ,GAAGD,OAAO,EAAEC,QAAQ,IAAI,CAAC;EACvC,MAAMC,QAAQ,GAAG,IAAAC,iBAAO,EAAC,IAAAC,sBAAa,EAACL,aAAa,CAAC,CAAC;EACtD,MAAMM,WAAW,GAAGC,sBAAsB,CAACJ,QAAQ,EAAED,QAAQ,CAAC;EAC9D,IAAI,CAACI,WAAW,EAAE;IAChB,OAAO,CAAC,CAAC;EACX;EAEA,IAAI;IACF,MAAME,OAAO,GAAGC,IAAI,CAACC,KAAK,CAAC,IAAAC,oBAAY,EAACL,WAAW,EAAE,MAAM,CAAC,CAAgB;IAC5E,OAAO;MACLM,IAAI,EAAE,OAAOJ,OAAO,CAACI,IAAI,KAAK,QAAQ,GAAGJ,OAAO,CAACI,IAAI,GAAGC,SAAS;MACjEC,OAAO,EAAE,OAAON,OAAO,CAACM,OAAO,KAAK,QAAQ,GAAGN,OAAO,CAACM,OAAO,GAAGD;IACnE,CAAC;EACH,CAAC,CAAC,MAAM;IACN,OAAO,CAAC,CAAC;EACX;AACF;AAEO,SAASE,kBAAkBA,CAACf,aAA2B,EAAEgB,QAAQ,GAAG,OAAO,EAAU;EAC1F,OAAOjB,eAAe,CAACC,aAAa,CAAC,CAACc,OAAO,IAAIE,QAAQ;AAC3D;AAEA,SAAST,sBAAsBA,CAACJ,QAAgB,EAAED,QAAgB,EAAiB;EACjF,IAAIe,OAAO,GAAGd,QAAQ;EACtB,KAAK,IAAIe,KAAK,GAAG,CAAC,EAAEA,KAAK,IAAIhB,QAAQ,EAAEgB,KAAK,IAAI,CAAC,EAAE;IACjD,MAAMC,SAAS,GAAG,IAAAC,iBAAO,EAACH,OAAO,EAAE,cAAc,CAAC;IAClD,IAAI,IAAAI,kBAAU,EAACF,SAAS,CAAC,EAAE;MACzB,OAAOA,SAAS;IAClB;IACA,MAAMG,MAAM,GAAG,IAAAlB,iBAAO,EAACa,OAAO,CAAC;IAC/B,IAAIK,MAAM,KAAKL,OAAO,EAAE;MACtB;IACF;IACAA,OAAO,GAAGK,MAAM;EAClB;EACA,OAAO,IAAI;AACb","ignoreList":[]}