d22c13011c13b95daa3d2e5ce8e727c5
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MissingSecretError = void 0;
exports.ensureSecretForProvider = ensureSecretForProvider;
exports.getSecretDefinition = getSecretDefinition;
exports.getSecretDefinitionForProvider = getSecretDefinitionForProvider;
exports.getSecretValue = getSecretValue;
exports.listSecretDefinitions = listSecretDefinitions;
exports.loadAllSecrets = loadAllSecrets;
exports.maskSecret = maskSecret;
exports.safeErrorMessage = safeErrorMessage;
exports.sanitizeError = sanitizeError;
exports.sanitizeErrorMessage = sanitizeErrorMessage;
exports.setSecretValue = setSecretValue;
var _nodeFs = require("node:fs");
var _nodeOs = require("node:os");
var _nodePath = require("node:path");
const SECRET_DEFINITIONS = [{
  id: 'OPENAI_API_KEY',
  label: 'OpenAI API Key',
  description: 'Required to run OpenAI GPT and Erosolar Code models.',
  envVar: 'OPENAI_API_KEY',
  providers: ['openai']
}, {
  id: 'ANTHROPIC_API_KEY',
  label: 'Anthropic API Key',
  description: 'Required to run Anthropic Sonnet, Opus, or Haiku models.',
  envVar: 'ANTHROPIC_API_KEY',
  providers: ['anthropic']
}, {
  id: 'DEEPSEEK_API_KEY',
  label: 'DeepSeek API Key',
  description: 'Required to run DeepSeek Reasoner or Chat models.',
  envVar: 'DEEPSEEK_API_KEY',
  providers: ['deepseek']
}, {
  id: 'XAI_API_KEY',
  label: 'xAI API Key',
  description: 'Required to run Grok models from xAI.',
  envVar: 'XAI_API_KEY',
  providers: ['xai']
}, {
  id: 'GEMINI_API_KEY',
  label: 'Google Gemini API Key',
  description: 'Required to run Gemini 2.5 Pro or Flash models.',
  envVar: 'GEMINI_API_KEY',
  providers: ['google']
}, {
  id: 'BRAVE_SEARCH_API_KEY',
  label: 'Brave Search API Key',
  description: 'Optional: unlock WebSearch using the Brave Search API.',
  envVar: 'BRAVE_SEARCH_API_KEY',
  providers: []
}, {
  id: 'SERPAPI_API_KEY',
  label: 'SerpAPI Key',
  description: 'Optional: fallback WebSearch provider via SerpAPI.',
  envVar: 'SERPAPI_API_KEY',
  providers: []
}, {
  id: 'TAVILY_API_KEY',
  label: 'Tavily API Key',
  description: 'Recommended: Primary WebSearch and WebExtract provider. Get yours at https://tavily.com',
  envVar: 'TAVILY_API_KEY',
  providers: []
}, {
  id: 'SMTP_USER',
  label: 'Email Address',
  description: 'Your email address for sending emails (e.g., you@gmail.com).',
  envVar: 'SMTP_USER',
  providers: []
}, {
  id: 'SMTP_PASSWORD',
  label: 'Email App Password',
  description: 'App password for your email (NOT your regular password). For Gmail: https://myaccount.google.com/apppasswords',
  envVar: 'SMTP_PASSWORD',
  providers: []
}, {
  id: 'SMTP_PROVIDER',
  label: 'Email Provider',
  description: 'Email provider: gmail, outlook, yahoo, icloud, zoho (default: gmail).',
  envVar: 'SMTP_PROVIDER',
  providers: []
}, {
  id: 'SMTP_FROM_NAME',
  label: 'Email Display Name',
  description: 'Optional: Display name shown in sent emails (e.g., "John Doe").',
  envVar: 'SMTP_FROM_NAME',
  providers: []
}, {
  id: 'SMTP_HOST',
  label: 'Custom SMTP Host',
  description: 'Optional: Custom SMTP server hostname (only for non-standard providers).',
  envVar: 'SMTP_HOST',
  providers: []
}, {
  id: 'SMTP_PORT',
  label: 'Custom SMTP Port',
  description: 'Optional: Custom SMTP port (only for non-standard providers, default: 587).',
  envVar: 'SMTP_PORT',
  providers: []
}];
const envAgiHome = process.env['AGI_HOME'];
const SECRET_DIR = envAgiHome ? (0, _nodePath.resolve)(envAgiHome) : (0, _nodePath.join)((0, _nodeOs.homedir)(), '.agi');
const SECRET_FILE = (0, _nodePath.join)(SECRET_DIR, 'secrets.json');
class MissingSecretError extends Error {
  constructor(secret) {
    super(`${secret.label} is not configured.`);
    this.secret = secret;
    this.name = 'MissingSecretError';
  }
}
exports.MissingSecretError = MissingSecretError;
function listSecretDefinitions() {
  return [...SECRET_DEFINITIONS];
}
function getSecretDefinition(id) {
  return SECRET_DEFINITIONS.find(entry => entry.id === id) ?? null;
}
function getSecretValue(id) {
  const envValue = sanitize(process.env[id]);
  if (envValue) {
    return envValue;
  }
  const store = readSecretStore();
  const storedValue = sanitize(store[id]);
  if (!storedValue) {
    return null;
  }
  process.env[id] = storedValue;
  return storedValue;
}

/**
 * Load all stored secrets into process.env at startup.
 * This ensures secrets are available before any provider checks.
 *
 * IMPORTANT: Stored secrets always take precedence over environment variables
 * for provider API keys. This ensures keys set via /secrets are used even if
 * the user has old/stale keys exported in their shell environment.
 */
function loadAllSecrets() {
  const store = readSecretStore();
  for (const definition of SECRET_DEFINITIONS) {
    const storedValue = sanitize(store[definition.id]);
    if (storedValue) {
      // Always use stored value for API keys to ensure /secrets takes precedence
      // over potentially stale environment variables
      process.env[definition.id] = storedValue;
    }
  }

  // Sync GEMINI_API_KEY and GOOGLE_API_KEY for Google SDK compatibility
  // The Google SDK checks both vars and warns if both are set
  // We standardize on GEMINI_API_KEY as the canonical key
  syncGoogleApiKeys();
}

/**
 * Sync GEMINI_API_KEY and GOOGLE_API_KEY environment variables.
 * The Google SDK prefers GOOGLE_API_KEY if both are set, but we use GEMINI_API_KEY
 * as the canonical stored key. This function ensures consistency.
 */
function syncGoogleApiKeys() {
  const geminiKey = process.env['GEMINI_API_KEY'];
  const googleKey = process.env['GOOGLE_API_KEY'];
  if (geminiKey && !googleKey) {
    // Only GEMINI_API_KEY set - also set GOOGLE_API_KEY to avoid SDK confusion
    process.env['GOOGLE_API_KEY'] = geminiKey;
  } else if (googleKey && !geminiKey) {
    // Only GOOGLE_API_KEY set (from env export) - copy to GEMINI_API_KEY
    process.env['GEMINI_API_KEY'] = googleKey;
  } else if (geminiKey && googleKey && geminiKey !== googleKey) {
    // Both set with different values - prefer GEMINI_API_KEY (the stored one)
    // and sync GOOGLE_API_KEY to match
    process.env['GOOGLE_API_KEY'] = geminiKey;
  }
  // If both are set and equal, no action needed
}
function setSecretValue(id, rawValue) {
  const value = sanitize(rawValue);
  if (!value) {
    throw new Error('Secret value cannot be blank.');
  }
  const store = readSecretStore();
  store[id] = value;
  writeSecretStore(store);
  process.env[id] = value;

  // If setting GEMINI_API_KEY, also sync GOOGLE_API_KEY for SDK compatibility
  if (id === 'GEMINI_API_KEY') {
    process.env['GOOGLE_API_KEY'] = value;
  }
}
function maskSecret(value) {
  if (!value) {
    return '';
  }
  if (value.length <= 4) {
    return '*'.repeat(value.length);
  }
  const suffix = value.slice(-4);
  const prefix = '*'.repeat(Math.max(0, value.length - 4));
  return `${prefix}${suffix}`;
}
function ensureSecretForProvider(provider) {
  const definition = findDefinitionForProvider(provider);
  const value = getSecretValue(definition.id);
  if (!value) {
    throw new MissingSecretError(definition);
  }
  process.env[definition.envVar] = value;
  return value;
}
function getSecretDefinitionForProvider(provider) {
  return SECRET_DEFINITIONS.find(entry => entry.providers.includes(provider)) ?? null;
}
function readSecretStore() {
  if (!(0, _nodeFs.existsSync)(SECRET_FILE)) {
    return {};
  }
  try {
    const content = (0, _nodeFs.readFileSync)(SECRET_FILE, 'utf8');
    const parsed = JSON.parse(content);
    if (parsed && typeof parsed === 'object') {
      return parsed;
    }
  } catch {
    return {};
  }
  return {};
}
function writeSecretStore(store) {
  const directory = (0, _nodePath.dirname)(SECRET_FILE);
  (0, _nodeFs.mkdirSync)(directory, {
    recursive: true
  });
  const payload = JSON.stringify(store, null, 2);
  (0, _nodeFs.writeFileSync)(SECRET_FILE, `${payload}
`);
}
function findDefinitionForProvider(provider) {
  const definition = getSecretDefinitionForProvider(provider);
  if (!definition) {
    throw new Error(`No secret configuration for provider "${provider}".`);
  }
  return definition;
}
function sanitize(value) {
  if (typeof value !== 'string') {
    return null;
  }
  const trimmed = value.trim();
  return trimmed.length ? trimmed : null;
}

// ============================================================================
// Secret Sanitization for Error Messages
// ============================================================================

/**
 * Known API key patterns to detect and sanitize in error messages.
 * These patterns match common API key formats from various providers.
 */
const API_KEY_PATTERNS = [
// Anthropic API keys: sk-ant-api03-...
/sk-ant-api\d{2}-[A-Za-z0-9_-]{20,}/g,
// OpenAI API keys: sk-proj-... or sk-...
/sk-(?:proj-)?[A-Za-z0-9_-]{20,}/g,
// Generic Bearer tokens in headers
/Bearer\s+[A-Za-z0-9_.-]{20,}/gi,
// x-api-key header values
/x-api-key['":\s]+[A-Za-z0-9_.-]{20,}/gi,
// API keys in URLs (key=value pattern)
/[?&](?:key|api_key|apiKey|api-key|token|access_token)=([A-Za-z0-9_.-]{16,})/gi,
// DeepSeek keys
/sk-[a-f0-9]{32,}/gi,
// xAI/Grok keys
/xai-[A-Za-z0-9_-]{20,}/gi,
// Google/Gemini API keys (AIza...)
/AIza[A-Za-z0-9_-]{30,}/g,
// Generic long alphanumeric tokens that look like API keys
/(?:api[_-]?key|token|secret|password|credential)['"]?\s*[:=]\s*['"]?([A-Za-z0-9_.-]{20,})['"]?/gi];

/**
 * Sanitize error messages to remove potential API keys and secrets.
 * This prevents accidental token leakage in logs, error reports, and console output.
 *
 * @param message - The error message or string to sanitize
 * @returns The sanitized string with secrets replaced by [REDACTED]
 */
function sanitizeErrorMessage(message) {
  if (!message || typeof message !== 'string') {
    return message;
  }
  let sanitized = message;

  // Apply all API key patterns
  for (const pattern of API_KEY_PATTERNS) {
    // Reset lastIndex for global patterns
    pattern.lastIndex = 0;
    sanitized = sanitized.replace(pattern, match => {
      // For patterns with capture groups, try to preserve context
      if (match.includes('=') || match.includes(':')) {
        const separator = match.includes('=') ? '=' : ':';
        const parts = match.split(separator);
        if (parts.length === 2) {
          return `${parts[0]}${separator}[REDACTED]`;
        }
      }
      return '[REDACTED]';
    });
  }

  // Additionally sanitize any env var values that are currently loaded
  sanitized = sanitizeAgainstLoadedSecrets(sanitized);
  return sanitized;
}

/**
 * Sanitize a string against currently loaded secret values.
 * This catches any secrets that might not match the pattern-based detection.
 */
function sanitizeAgainstLoadedSecrets(message) {
  const secretNames = ['OPENAI_API_KEY', 'ANTHROPIC_API_KEY', 'DEEPSEEK_API_KEY', 'XAI_API_KEY', 'GEMINI_API_KEY', 'BRAVE_SEARCH_API_KEY', 'SERPAPI_API_KEY', 'TAVILY_API_KEY', 'SMTP_PASSWORD'];
  let sanitized = message;
  for (const name of secretNames) {
    const value = process.env[name];
    if (value && value.length >= 8) {
      // Only sanitize if the value appears in the message
      // Use a case-sensitive exact match to avoid false positives
      if (sanitized.includes(value)) {
        sanitized = sanitized.split(value).join('[REDACTED]');
      }
    }
  }
  return sanitized;
}

/**
 * Sanitize an Error object's message and stack trace.
 * Returns a new error message string with secrets removed.
 */
function sanitizeError(error) {
  const message = sanitizeErrorMessage(error.message);
  const stack = error.stack ? sanitizeErrorMessage(error.stack) : '';
  if (stack && stack !== message) {
    return `${message}\n${stack}`;
  }
  return message;
}

/**
 * Create a safe error message from an unknown error value.
 * Ensures no secrets are leaked regardless of error type.
 */
function safeErrorMessage(error) {
  if (error instanceof Error) {
    return sanitizeErrorMessage(error.message);
  }
  if (typeof error === 'string') {
    return sanitizeErrorMessage(error);
  }
  return 'Unknown error occurred';
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfbm9kZUZzIiwicmVxdWlyZSIsIl9ub2RlT3MiLCJfbm9kZVBhdGgiLCJTRUNSRVRfREVGSU5JVElPTlMiLCJpZCIsImxhYmVsIiwiZGVzY3JpcHRpb24iLCJlbnZWYXIiLCJwcm92aWRlcnMiLCJlbnZBZ2lIb21lIiwicHJvY2VzcyIsImVudiIsIlNFQ1JFVF9ESVIiLCJyZXNvbHZlIiwiam9pbiIsImhvbWVkaXIiLCJTRUNSRVRfRklMRSIsIk1pc3NpbmdTZWNyZXRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJzZWNyZXQiLCJuYW1lIiwiZXhwb3J0cyIsImxpc3RTZWNyZXREZWZpbml0aW9ucyIsImdldFNlY3JldERlZmluaXRpb24iLCJmaW5kIiwiZW50cnkiLCJnZXRTZWNyZXRWYWx1ZSIsImVudlZhbHVlIiwic2FuaXRpemUiLCJzdG9yZSIsInJlYWRTZWNyZXRTdG9yZSIsInN0b3JlZFZhbHVlIiwibG9hZEFsbFNlY3JldHMiLCJkZWZpbml0aW9uIiwic3luY0dvb2dsZUFwaUtleXMiLCJnZW1pbmlLZXkiLCJnb29nbGVLZXkiLCJzZXRTZWNyZXRWYWx1ZSIsInJhd1ZhbHVlIiwidmFsdWUiLCJ3cml0ZVNlY3JldFN0b3JlIiwibWFza1NlY3JldCIsImxlbmd0aCIsInJlcGVhdCIsInN1ZmZpeCIsInNsaWNlIiwicHJlZml4IiwiTWF0aCIsIm1heCIsImVuc3VyZVNlY3JldEZvclByb3ZpZGVyIiwicHJvdmlkZXIiLCJmaW5kRGVmaW5pdGlvbkZvclByb3ZpZGVyIiwiZ2V0U2VjcmV0RGVmaW5pdGlvbkZvclByb3ZpZGVyIiwiaW5jbHVkZXMiLCJleGlzdHNTeW5jIiwiY29udGVudCIsInJlYWRGaWxlU3luYyIsInBhcnNlZCIsIkpTT04iLCJwYXJzZSIsImRpcmVjdG9yeSIsImRpcm5hbWUiLCJta2RpclN5bmMiLCJyZWN1cnNpdmUiLCJwYXlsb2FkIiwic3RyaW5naWZ5Iiwid3JpdGVGaWxlU3luYyIsInRyaW1tZWQiLCJ0cmltIiwiQVBJX0tFWV9QQVRURVJOUyIsInNhbml0aXplRXJyb3JNZXNzYWdlIiwibWVzc2FnZSIsInNhbml0aXplZCIsInBhdHRlcm4iLCJsYXN0SW5kZXgiLCJyZXBsYWNlIiwibWF0Y2giLCJzZXBhcmF0b3IiLCJwYXJ0cyIsInNwbGl0Iiwic2FuaXRpemVBZ2FpbnN0TG9hZGVkU2VjcmV0cyIsInNlY3JldE5hbWVzIiwic2FuaXRpemVFcnJvciIsImVycm9yIiwic3RhY2siLCJzYWZlRXJyb3JNZXNzYWdlIl0sInNvdXJjZXMiOlsic2VjcmV0U3RvcmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhpc3RzU3luYywgbWtkaXJTeW5jLCByZWFkRmlsZVN5bmMsIHdyaXRlRmlsZVN5bmMgfSBmcm9tICdub2RlOmZzJztcbmltcG9ydCB7IGhvbWVkaXIgfSBmcm9tICdub2RlOm9zJztcbmltcG9ydCB7IGRpcm5hbWUsIGpvaW4sIHJlc29sdmUgfSBmcm9tICdub2RlOnBhdGgnO1xuaW1wb3J0IHR5cGUgeyBQcm92aWRlcklkIH0gZnJvbSAnLi90eXBlcy5qcyc7XG5cbmV4cG9ydCB0eXBlIFNlY3JldE5hbWUgPVxuICB8ICdPUEVOQUlfQVBJX0tFWSdcbiAgfCAnQU5USFJPUElDX0FQSV9LRVknXG4gIHwgJ0RFRVBTRUVLX0FQSV9LRVknXG4gIHwgJ1hBSV9BUElfS0VZJ1xuICB8ICdHRU1JTklfQVBJX0tFWSdcbiAgfCAnQlJBVkVfU0VBUkNIX0FQSV9LRVknXG4gIHwgJ1NFUlBBUElfQVBJX0tFWSdcbiAgfCAnVEFWSUxZX0FQSV9LRVknXG4gIHwgJ1NNVFBfVVNFUidcbiAgfCAnU01UUF9QQVNTV09SRCdcbiAgfCAnU01UUF9QUk9WSURFUidcbiAgfCAnU01UUF9GUk9NX05BTUUnXG4gIHwgJ1NNVFBfSE9TVCdcbiAgfCAnU01UUF9QT1JUJztcblxuZXhwb3J0IGludGVyZmFjZSBTZWNyZXREZWZpbml0aW9uIHtcbiAgaWQ6IFNlY3JldE5hbWU7XG4gIGxhYmVsOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIGVudlZhcjogU2VjcmV0TmFtZTtcbiAgcHJvdmlkZXJzOiBQcm92aWRlcklkW107XG59XG5cbmludGVyZmFjZSBTZWNyZXRTdG9yZURhdGEge1xuICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59XG5cbmNvbnN0IFNFQ1JFVF9ERUZJTklUSU9OUzogU2VjcmV0RGVmaW5pdGlvbltdID0gW1xuICB7XG4gICAgaWQ6ICdPUEVOQUlfQVBJX0tFWScsXG4gICAgbGFiZWw6ICdPcGVuQUkgQVBJIEtleScsXG4gICAgZGVzY3JpcHRpb246ICdSZXF1aXJlZCB0byBydW4gT3BlbkFJIEdQVCBhbmQgRXJvc29sYXIgQ29kZSBtb2RlbHMuJyxcbiAgICBlbnZWYXI6ICdPUEVOQUlfQVBJX0tFWScsXG4gICAgcHJvdmlkZXJzOiBbJ29wZW5haSddLFxuICB9LFxuICB7XG4gICAgaWQ6ICdBTlRIUk9QSUNfQVBJX0tFWScsXG4gICAgbGFiZWw6ICdBbnRocm9waWMgQVBJIEtleScsXG4gICAgZGVzY3JpcHRpb246ICdSZXF1aXJlZCB0byBydW4gQW50aHJvcGljIFNvbm5ldCwgT3B1cywgb3IgSGFpa3UgbW9kZWxzLicsXG4gICAgZW52VmFyOiAnQU5USFJPUElDX0FQSV9LRVknLFxuICAgIHByb3ZpZGVyczogWydhbnRocm9waWMnXSxcbiAgfSxcbiAge1xuICAgIGlkOiAnREVFUFNFRUtfQVBJX0tFWScsXG4gICAgbGFiZWw6ICdEZWVwU2VlayBBUEkgS2V5JyxcbiAgICBkZXNjcmlwdGlvbjogJ1JlcXVpcmVkIHRvIHJ1biBEZWVwU2VlayBSZWFzb25lciBvciBDaGF0IG1vZGVscy4nLFxuICAgIGVudlZhcjogJ0RFRVBTRUVLX0FQSV9LRVknLFxuICAgIHByb3ZpZGVyczogWydkZWVwc2VlayddLFxuICB9LFxuICB7XG4gICAgaWQ6ICdYQUlfQVBJX0tFWScsXG4gICAgbGFiZWw6ICd4QUkgQVBJIEtleScsXG4gICAgZGVzY3JpcHRpb246ICdSZXF1aXJlZCB0byBydW4gR3JvayBtb2RlbHMgZnJvbSB4QUkuJyxcbiAgICBlbnZWYXI6ICdYQUlfQVBJX0tFWScsXG4gICAgcHJvdmlkZXJzOiBbJ3hhaSddLFxuICB9LFxuICB7XG4gICAgaWQ6ICdHRU1JTklfQVBJX0tFWScsXG4gICAgbGFiZWw6ICdHb29nbGUgR2VtaW5pIEFQSSBLZXknLFxuICAgIGRlc2NyaXB0aW9uOiAnUmVxdWlyZWQgdG8gcnVuIEdlbWluaSAyLjUgUHJvIG9yIEZsYXNoIG1vZGVscy4nLFxuICAgIGVudlZhcjogJ0dFTUlOSV9BUElfS0VZJyxcbiAgICBwcm92aWRlcnM6IFsnZ29vZ2xlJ10sXG4gIH0sXG4gIHtcbiAgICBpZDogJ0JSQVZFX1NFQVJDSF9BUElfS0VZJyxcbiAgICBsYWJlbDogJ0JyYXZlIFNlYXJjaCBBUEkgS2V5JyxcbiAgICBkZXNjcmlwdGlvbjogJ09wdGlvbmFsOiB1bmxvY2sgV2ViU2VhcmNoIHVzaW5nIHRoZSBCcmF2ZSBTZWFyY2ggQVBJLicsXG4gICAgZW52VmFyOiAnQlJBVkVfU0VBUkNIX0FQSV9LRVknLFxuICAgIHByb3ZpZGVyczogW10sXG4gIH0sXG4gIHtcbiAgICBpZDogJ1NFUlBBUElfQVBJX0tFWScsXG4gICAgbGFiZWw6ICdTZXJwQVBJIEtleScsXG4gICAgZGVzY3JpcHRpb246ICdPcHRpb25hbDogZmFsbGJhY2sgV2ViU2VhcmNoIHByb3ZpZGVyIHZpYSBTZXJwQVBJLicsXG4gICAgZW52VmFyOiAnU0VSUEFQSV9BUElfS0VZJyxcbiAgICBwcm92aWRlcnM6IFtdLFxuICB9LFxuICB7XG4gICAgaWQ6ICdUQVZJTFlfQVBJX0tFWScsXG4gICAgbGFiZWw6ICdUYXZpbHkgQVBJIEtleScsXG4gICAgZGVzY3JpcHRpb246ICdSZWNvbW1lbmRlZDogUHJpbWFyeSBXZWJTZWFyY2ggYW5kIFdlYkV4dHJhY3QgcHJvdmlkZXIuIEdldCB5b3VycyBhdCBodHRwczovL3RhdmlseS5jb20nLFxuICAgIGVudlZhcjogJ1RBVklMWV9BUElfS0VZJyxcbiAgICBwcm92aWRlcnM6IFtdLFxuICB9LFxuICB7XG4gICAgaWQ6ICdTTVRQX1VTRVInLFxuICAgIGxhYmVsOiAnRW1haWwgQWRkcmVzcycsXG4gICAgZGVzY3JpcHRpb246ICdZb3VyIGVtYWlsIGFkZHJlc3MgZm9yIHNlbmRpbmcgZW1haWxzIChlLmcuLCB5b3VAZ21haWwuY29tKS4nLFxuICAgIGVudlZhcjogJ1NNVFBfVVNFUicsXG4gICAgcHJvdmlkZXJzOiBbXSxcbiAgfSxcbiAge1xuICAgIGlkOiAnU01UUF9QQVNTV09SRCcsXG4gICAgbGFiZWw6ICdFbWFpbCBBcHAgUGFzc3dvcmQnLFxuICAgIGRlc2NyaXB0aW9uOiAnQXBwIHBhc3N3b3JkIGZvciB5b3VyIGVtYWlsIChOT1QgeW91ciByZWd1bGFyIHBhc3N3b3JkKS4gRm9yIEdtYWlsOiBodHRwczovL215YWNjb3VudC5nb29nbGUuY29tL2FwcHBhc3N3b3JkcycsXG4gICAgZW52VmFyOiAnU01UUF9QQVNTV09SRCcsXG4gICAgcHJvdmlkZXJzOiBbXSxcbiAgfSxcbiAge1xuICAgIGlkOiAnU01UUF9QUk9WSURFUicsXG4gICAgbGFiZWw6ICdFbWFpbCBQcm92aWRlcicsXG4gICAgZGVzY3JpcHRpb246ICdFbWFpbCBwcm92aWRlcjogZ21haWwsIG91dGxvb2ssIHlhaG9vLCBpY2xvdWQsIHpvaG8gKGRlZmF1bHQ6IGdtYWlsKS4nLFxuICAgIGVudlZhcjogJ1NNVFBfUFJPVklERVInLFxuICAgIHByb3ZpZGVyczogW10sXG4gIH0sXG4gIHtcbiAgICBpZDogJ1NNVFBfRlJPTV9OQU1FJyxcbiAgICBsYWJlbDogJ0VtYWlsIERpc3BsYXkgTmFtZScsXG4gICAgZGVzY3JpcHRpb246ICdPcHRpb25hbDogRGlzcGxheSBuYW1lIHNob3duIGluIHNlbnQgZW1haWxzIChlLmcuLCBcIkpvaG4gRG9lXCIpLicsXG4gICAgZW52VmFyOiAnU01UUF9GUk9NX05BTUUnLFxuICAgIHByb3ZpZGVyczogW10sXG4gIH0sXG4gIHtcbiAgICBpZDogJ1NNVFBfSE9TVCcsXG4gICAgbGFiZWw6ICdDdXN0b20gU01UUCBIb3N0JyxcbiAgICBkZXNjcmlwdGlvbjogJ09wdGlvbmFsOiBDdXN0b20gU01UUCBzZXJ2ZXIgaG9zdG5hbWUgKG9ubHkgZm9yIG5vbi1zdGFuZGFyZCBwcm92aWRlcnMpLicsXG4gICAgZW52VmFyOiAnU01UUF9IT1NUJyxcbiAgICBwcm92aWRlcnM6IFtdLFxuICB9LFxuICB7XG4gICAgaWQ6ICdTTVRQX1BPUlQnLFxuICAgIGxhYmVsOiAnQ3VzdG9tIFNNVFAgUG9ydCcsXG4gICAgZGVzY3JpcHRpb246ICdPcHRpb25hbDogQ3VzdG9tIFNNVFAgcG9ydCAob25seSBmb3Igbm9uLXN0YW5kYXJkIHByb3ZpZGVycywgZGVmYXVsdDogNTg3KS4nLFxuICAgIGVudlZhcjogJ1NNVFBfUE9SVCcsXG4gICAgcHJvdmlkZXJzOiBbXSxcbiAgfSxcbl07XG5cbmNvbnN0IGVudkFnaUhvbWUgPSBwcm9jZXNzLmVudlsnQUdJX0hPTUUnXTtcbmNvbnN0IFNFQ1JFVF9ESVIgPSBlbnZBZ2lIb21lID8gcmVzb2x2ZShlbnZBZ2lIb21lKSA6IGpvaW4oaG9tZWRpcigpLCAnLmFnaScpO1xuY29uc3QgU0VDUkVUX0ZJTEUgPSBqb2luKFNFQ1JFVF9ESVIsICdzZWNyZXRzLmpzb24nKTtcblxuZXhwb3J0IGNsYXNzIE1pc3NpbmdTZWNyZXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IHNlY3JldDogU2VjcmV0RGVmaW5pdGlvbikge1xuICAgIHN1cGVyKGAke3NlY3JldC5sYWJlbH0gaXMgbm90IGNvbmZpZ3VyZWQuYCk7XG4gICAgdGhpcy5uYW1lID0gJ01pc3NpbmdTZWNyZXRFcnJvcic7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RTZWNyZXREZWZpbml0aW9ucygpOiBTZWNyZXREZWZpbml0aW9uW10ge1xuICByZXR1cm4gWy4uLlNFQ1JFVF9ERUZJTklUSU9OU107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWNyZXREZWZpbml0aW9uKGlkOiBTZWNyZXROYW1lKTogU2VjcmV0RGVmaW5pdGlvbiB8IG51bGwge1xuICByZXR1cm4gU0VDUkVUX0RFRklOSVRJT05TLmZpbmQoKGVudHJ5KSA9PiBlbnRyeS5pZCA9PT0gaWQpID8/IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWNyZXRWYWx1ZShpZDogU2VjcmV0TmFtZSk6IHN0cmluZyB8IG51bGwge1xuICBjb25zdCBlbnZWYWx1ZSA9IHNhbml0aXplKHByb2Nlc3MuZW52W2lkXSk7XG4gIGlmIChlbnZWYWx1ZSkge1xuICAgIHJldHVybiBlbnZWYWx1ZTtcbiAgfVxuXG4gIGNvbnN0IHN0b3JlID0gcmVhZFNlY3JldFN0b3JlKCk7XG4gIGNvbnN0IHN0b3JlZFZhbHVlID0gc2FuaXRpemUoc3RvcmVbaWRdKTtcbiAgaWYgKCFzdG9yZWRWYWx1ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcHJvY2Vzcy5lbnZbaWRdID0gc3RvcmVkVmFsdWU7XG4gIHJldHVybiBzdG9yZWRWYWx1ZTtcbn1cblxuLyoqXG4gKiBMb2FkIGFsbCBzdG9yZWQgc2VjcmV0cyBpbnRvIHByb2Nlc3MuZW52IGF0IHN0YXJ0dXAuXG4gKiBUaGlzIGVuc3VyZXMgc2VjcmV0cyBhcmUgYXZhaWxhYmxlIGJlZm9yZSBhbnkgcHJvdmlkZXIgY2hlY2tzLlxuICpcbiAqIElNUE9SVEFOVDogU3RvcmVkIHNlY3JldHMgYWx3YXlzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICogZm9yIHByb3ZpZGVyIEFQSSBrZXlzLiBUaGlzIGVuc3VyZXMga2V5cyBzZXQgdmlhIC9zZWNyZXRzIGFyZSB1c2VkIGV2ZW4gaWZcbiAqIHRoZSB1c2VyIGhhcyBvbGQvc3RhbGUga2V5cyBleHBvcnRlZCBpbiB0aGVpciBzaGVsbCBlbnZpcm9ubWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvYWRBbGxTZWNyZXRzKCk6IHZvaWQge1xuICBjb25zdCBzdG9yZSA9IHJlYWRTZWNyZXRTdG9yZSgpO1xuICBmb3IgKGNvbnN0IGRlZmluaXRpb24gb2YgU0VDUkVUX0RFRklOSVRJT05TKSB7XG4gICAgY29uc3Qgc3RvcmVkVmFsdWUgPSBzYW5pdGl6ZShzdG9yZVtkZWZpbml0aW9uLmlkXSk7XG4gICAgaWYgKHN0b3JlZFZhbHVlKSB7XG4gICAgICAvLyBBbHdheXMgdXNlIHN0b3JlZCB2YWx1ZSBmb3IgQVBJIGtleXMgdG8gZW5zdXJlIC9zZWNyZXRzIHRha2VzIHByZWNlZGVuY2VcbiAgICAgIC8vIG92ZXIgcG90ZW50aWFsbHkgc3RhbGUgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgICBwcm9jZXNzLmVudltkZWZpbml0aW9uLmlkXSA9IHN0b3JlZFZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFN5bmMgR0VNSU5JX0FQSV9LRVkgYW5kIEdPT0dMRV9BUElfS0VZIGZvciBHb29nbGUgU0RLIGNvbXBhdGliaWxpdHlcbiAgLy8gVGhlIEdvb2dsZSBTREsgY2hlY2tzIGJvdGggdmFycyBhbmQgd2FybnMgaWYgYm90aCBhcmUgc2V0XG4gIC8vIFdlIHN0YW5kYXJkaXplIG9uIEdFTUlOSV9BUElfS0VZIGFzIHRoZSBjYW5vbmljYWwga2V5XG4gIHN5bmNHb29nbGVBcGlLZXlzKCk7XG59XG5cbi8qKlxuICogU3luYyBHRU1JTklfQVBJX0tFWSBhbmQgR09PR0xFX0FQSV9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICogVGhlIEdvb2dsZSBTREsgcHJlZmVycyBHT09HTEVfQVBJX0tFWSBpZiBib3RoIGFyZSBzZXQsIGJ1dCB3ZSB1c2UgR0VNSU5JX0FQSV9LRVlcbiAqIGFzIHRoZSBjYW5vbmljYWwgc3RvcmVkIGtleS4gVGhpcyBmdW5jdGlvbiBlbnN1cmVzIGNvbnNpc3RlbmN5LlxuICovXG5mdW5jdGlvbiBzeW5jR29vZ2xlQXBpS2V5cygpOiB2b2lkIHtcbiAgY29uc3QgZ2VtaW5pS2V5ID0gcHJvY2Vzcy5lbnZbJ0dFTUlOSV9BUElfS0VZJ107XG4gIGNvbnN0IGdvb2dsZUtleSA9IHByb2Nlc3MuZW52WydHT09HTEVfQVBJX0tFWSddO1xuXG4gIGlmIChnZW1pbmlLZXkgJiYgIWdvb2dsZUtleSkge1xuICAgIC8vIE9ubHkgR0VNSU5JX0FQSV9LRVkgc2V0IC0gYWxzbyBzZXQgR09PR0xFX0FQSV9LRVkgdG8gYXZvaWQgU0RLIGNvbmZ1c2lvblxuICAgIHByb2Nlc3MuZW52WydHT09HTEVfQVBJX0tFWSddID0gZ2VtaW5pS2V5O1xuICB9IGVsc2UgaWYgKGdvb2dsZUtleSAmJiAhZ2VtaW5pS2V5KSB7XG4gICAgLy8gT25seSBHT09HTEVfQVBJX0tFWSBzZXQgKGZyb20gZW52IGV4cG9ydCkgLSBjb3B5IHRvIEdFTUlOSV9BUElfS0VZXG4gICAgcHJvY2Vzcy5lbnZbJ0dFTUlOSV9BUElfS0VZJ10gPSBnb29nbGVLZXk7XG4gIH0gZWxzZSBpZiAoZ2VtaW5pS2V5ICYmIGdvb2dsZUtleSAmJiBnZW1pbmlLZXkgIT09IGdvb2dsZUtleSkge1xuICAgIC8vIEJvdGggc2V0IHdpdGggZGlmZmVyZW50IHZhbHVlcyAtIHByZWZlciBHRU1JTklfQVBJX0tFWSAodGhlIHN0b3JlZCBvbmUpXG4gICAgLy8gYW5kIHN5bmMgR09PR0xFX0FQSV9LRVkgdG8gbWF0Y2hcbiAgICBwcm9jZXNzLmVudlsnR09PR0xFX0FQSV9LRVknXSA9IGdlbWluaUtleTtcbiAgfVxuICAvLyBJZiBib3RoIGFyZSBzZXQgYW5kIGVxdWFsLCBubyBhY3Rpb24gbmVlZGVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRTZWNyZXRWYWx1ZShpZDogU2VjcmV0TmFtZSwgcmF3VmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICBjb25zdCB2YWx1ZSA9IHNhbml0aXplKHJhd1ZhbHVlKTtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2VjcmV0IHZhbHVlIGNhbm5vdCBiZSBibGFuay4nKTtcbiAgfVxuXG4gIGNvbnN0IHN0b3JlID0gcmVhZFNlY3JldFN0b3JlKCk7XG4gIHN0b3JlW2lkXSA9IHZhbHVlO1xuICB3cml0ZVNlY3JldFN0b3JlKHN0b3JlKTtcbiAgcHJvY2Vzcy5lbnZbaWRdID0gdmFsdWU7XG5cbiAgLy8gSWYgc2V0dGluZyBHRU1JTklfQVBJX0tFWSwgYWxzbyBzeW5jIEdPT0dMRV9BUElfS0VZIGZvciBTREsgY29tcGF0aWJpbGl0eVxuICBpZiAoaWQgPT09ICdHRU1JTklfQVBJX0tFWScpIHtcbiAgICBwcm9jZXNzLmVudlsnR09PR0xFX0FQSV9LRVknXSA9IHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXNrU2VjcmV0KHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmICh2YWx1ZS5sZW5ndGggPD0gNCkge1xuICAgIHJldHVybiAnKicucmVwZWF0KHZhbHVlLmxlbmd0aCk7XG4gIH1cbiAgY29uc3Qgc3VmZml4ID0gdmFsdWUuc2xpY2UoLTQpO1xuICBjb25zdCBwcmVmaXggPSAnKicucmVwZWF0KE1hdGgubWF4KDAsIHZhbHVlLmxlbmd0aCAtIDQpKTtcbiAgcmV0dXJuIGAke3ByZWZpeH0ke3N1ZmZpeH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlU2VjcmV0Rm9yUHJvdmlkZXIocHJvdmlkZXI6IFByb3ZpZGVySWQpOiBzdHJpbmcge1xuICBjb25zdCBkZWZpbml0aW9uID0gZmluZERlZmluaXRpb25Gb3JQcm92aWRlcihwcm92aWRlcik7XG4gIGNvbnN0IHZhbHVlID0gZ2V0U2VjcmV0VmFsdWUoZGVmaW5pdGlvbi5pZCk7XG4gIGlmICghdmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgTWlzc2luZ1NlY3JldEVycm9yKGRlZmluaXRpb24pO1xuICB9XG4gIHByb2Nlc3MuZW52W2RlZmluaXRpb24uZW52VmFyXSA9IHZhbHVlO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWNyZXREZWZpbml0aW9uRm9yUHJvdmlkZXIocHJvdmlkZXI6IFByb3ZpZGVySWQpOiBTZWNyZXREZWZpbml0aW9uIHwgbnVsbCB7XG4gIHJldHVybiBTRUNSRVRfREVGSU5JVElPTlMuZmluZCgoZW50cnkpID0+IGVudHJ5LnByb3ZpZGVycy5pbmNsdWRlcyhwcm92aWRlcikpID8/IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlYWRTZWNyZXRTdG9yZSgpOiBTZWNyZXRTdG9yZURhdGEge1xuICBpZiAoIWV4aXN0c1N5bmMoU0VDUkVUX0ZJTEUpKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBjb250ZW50ID0gcmVhZEZpbGVTeW5jKFNFQ1JFVF9GSUxFLCAndXRmOCcpO1xuICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoY29udGVudCk7XG4gICAgaWYgKHBhcnNlZCAmJiB0eXBlb2YgcGFyc2VkID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHBhcnNlZCBhcyBTZWNyZXRTdG9yZURhdGE7XG4gICAgfVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiB3cml0ZVNlY3JldFN0b3JlKHN0b3JlOiBTZWNyZXRTdG9yZURhdGEpOiB2b2lkIHtcbiAgY29uc3QgZGlyZWN0b3J5ID0gZGlybmFtZShTRUNSRVRfRklMRSk7XG4gIG1rZGlyU3luYyhkaXJlY3RvcnksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICBjb25zdCBwYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkoc3RvcmUsIG51bGwsIDIpO1xuICB3cml0ZUZpbGVTeW5jKFNFQ1JFVF9GSUxFLCBgJHtwYXlsb2FkfVxuYCk7XG59XG5cbmZ1bmN0aW9uIGZpbmREZWZpbml0aW9uRm9yUHJvdmlkZXIocHJvdmlkZXI6IFByb3ZpZGVySWQpOiBTZWNyZXREZWZpbml0aW9uIHtcbiAgY29uc3QgZGVmaW5pdGlvbiA9IGdldFNlY3JldERlZmluaXRpb25Gb3JQcm92aWRlcihwcm92aWRlcik7XG4gIGlmICghZGVmaW5pdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gc2VjcmV0IGNvbmZpZ3VyYXRpb24gZm9yIHByb3ZpZGVyIFwiJHtwcm92aWRlcn1cIi5gKTtcbiAgfVxuICByZXR1cm4gZGVmaW5pdGlvbjtcbn1cblxuZnVuY3Rpb24gc2FuaXRpemUodmFsdWU6IHVua25vd24pOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB0cmltbWVkID0gdmFsdWUudHJpbSgpO1xuICByZXR1cm4gdHJpbW1lZC5sZW5ndGggPyB0cmltbWVkIDogbnVsbDtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU2VjcmV0IFNhbml0aXphdGlvbiBmb3IgRXJyb3IgTWVzc2FnZXNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBLbm93biBBUEkga2V5IHBhdHRlcm5zIHRvIGRldGVjdCBhbmQgc2FuaXRpemUgaW4gZXJyb3IgbWVzc2FnZXMuXG4gKiBUaGVzZSBwYXR0ZXJucyBtYXRjaCBjb21tb24gQVBJIGtleSBmb3JtYXRzIGZyb20gdmFyaW91cyBwcm92aWRlcnMuXG4gKi9cbmNvbnN0IEFQSV9LRVlfUEFUVEVSTlM6IFJlZ0V4cFtdID0gW1xuICAvLyBBbnRocm9waWMgQVBJIGtleXM6IHNrLWFudC1hcGkwMy0uLi5cbiAgL3NrLWFudC1hcGlcXGR7Mn0tW0EtWmEtejAtOV8tXXsyMCx9L2csXG4gIC8vIE9wZW5BSSBBUEkga2V5czogc2stcHJvai0uLi4gb3Igc2stLi4uXG4gIC9zay0oPzpwcm9qLSk/W0EtWmEtejAtOV8tXXsyMCx9L2csXG4gIC8vIEdlbmVyaWMgQmVhcmVyIHRva2VucyBpbiBoZWFkZXJzXG4gIC9CZWFyZXJcXHMrW0EtWmEtejAtOV8uLV17MjAsfS9naSxcbiAgLy8geC1hcGkta2V5IGhlYWRlciB2YWx1ZXNcbiAgL3gtYXBpLWtleVsnXCI6XFxzXStbQS1aYS16MC05Xy4tXXsyMCx9L2dpLFxuICAvLyBBUEkga2V5cyBpbiBVUkxzIChrZXk9dmFsdWUgcGF0dGVybilcbiAgL1s/Jl0oPzprZXl8YXBpX2tleXxhcGlLZXl8YXBpLWtleXx0b2tlbnxhY2Nlc3NfdG9rZW4pPShbQS1aYS16MC05Xy4tXXsxNix9KS9naSxcbiAgLy8gRGVlcFNlZWsga2V5c1xuICAvc2stW2EtZjAtOV17MzIsfS9naSxcbiAgLy8geEFJL0dyb2sga2V5c1xuICAveGFpLVtBLVphLXowLTlfLV17MjAsfS9naSxcbiAgLy8gR29vZ2xlL0dlbWluaSBBUEkga2V5cyAoQUl6YS4uLilcbiAgL0FJemFbQS1aYS16MC05Xy1dezMwLH0vZyxcbiAgLy8gR2VuZXJpYyBsb25nIGFscGhhbnVtZXJpYyB0b2tlbnMgdGhhdCBsb29rIGxpa2UgQVBJIGtleXNcbiAgLyg/OmFwaVtfLV0/a2V5fHRva2VufHNlY3JldHxwYXNzd29yZHxjcmVkZW50aWFsKVsnXCJdP1xccypbOj1dXFxzKlsnXCJdPyhbQS1aYS16MC05Xy4tXXsyMCx9KVsnXCJdPy9naSxcbl07XG5cbi8qKlxuICogU2FuaXRpemUgZXJyb3IgbWVzc2FnZXMgdG8gcmVtb3ZlIHBvdGVudGlhbCBBUEkga2V5cyBhbmQgc2VjcmV0cy5cbiAqIFRoaXMgcHJldmVudHMgYWNjaWRlbnRhbCB0b2tlbiBsZWFrYWdlIGluIGxvZ3MsIGVycm9yIHJlcG9ydHMsIGFuZCBjb25zb2xlIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIHN0cmluZyB0byBzYW5pdGl6ZVxuICogQHJldHVybnMgVGhlIHNhbml0aXplZCBzdHJpbmcgd2l0aCBzZWNyZXRzIHJlcGxhY2VkIGJ5IFtSRURBQ1RFRF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhbml0aXplRXJyb3JNZXNzYWdlKG1lc3NhZ2U6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICghbWVzc2FnZSB8fCB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuXG4gIGxldCBzYW5pdGl6ZWQgPSBtZXNzYWdlO1xuXG4gIC8vIEFwcGx5IGFsbCBBUEkga2V5IHBhdHRlcm5zXG4gIGZvciAoY29uc3QgcGF0dGVybiBvZiBBUElfS0VZX1BBVFRFUk5TKSB7XG4gICAgLy8gUmVzZXQgbGFzdEluZGV4IGZvciBnbG9iYWwgcGF0dGVybnNcbiAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gICAgc2FuaXRpemVkID0gc2FuaXRpemVkLnJlcGxhY2UocGF0dGVybiwgKG1hdGNoKSA9PiB7XG4gICAgICAvLyBGb3IgcGF0dGVybnMgd2l0aCBjYXB0dXJlIGdyb3VwcywgdHJ5IHRvIHByZXNlcnZlIGNvbnRleHRcbiAgICAgIGlmIChtYXRjaC5pbmNsdWRlcygnPScpIHx8IG1hdGNoLmluY2x1ZGVzKCc6JykpIHtcbiAgICAgICAgY29uc3Qgc2VwYXJhdG9yID0gbWF0Y2guaW5jbHVkZXMoJz0nKSA/ICc9JyA6ICc6JztcbiAgICAgICAgY29uc3QgcGFydHMgPSBtYXRjaC5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIGAke3BhcnRzWzBdfSR7c2VwYXJhdG9yfVtSRURBQ1RFRF1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1tSRURBQ1RFRF0nO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQWRkaXRpb25hbGx5IHNhbml0aXplIGFueSBlbnYgdmFyIHZhbHVlcyB0aGF0IGFyZSBjdXJyZW50bHkgbG9hZGVkXG4gIHNhbml0aXplZCA9IHNhbml0aXplQWdhaW5zdExvYWRlZFNlY3JldHMoc2FuaXRpemVkKTtcblxuICByZXR1cm4gc2FuaXRpemVkO1xufVxuXG4vKipcbiAqIFNhbml0aXplIGEgc3RyaW5nIGFnYWluc3QgY3VycmVudGx5IGxvYWRlZCBzZWNyZXQgdmFsdWVzLlxuICogVGhpcyBjYXRjaGVzIGFueSBzZWNyZXRzIHRoYXQgbWlnaHQgbm90IG1hdGNoIHRoZSBwYXR0ZXJuLWJhc2VkIGRldGVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2FuaXRpemVBZ2FpbnN0TG9hZGVkU2VjcmV0cyhtZXNzYWdlOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBzZWNyZXROYW1lczogU2VjcmV0TmFtZVtdID0gW1xuICAgICdPUEVOQUlfQVBJX0tFWScsXG4gICAgJ0FOVEhST1BJQ19BUElfS0VZJyxcbiAgICAnREVFUFNFRUtfQVBJX0tFWScsXG4gICAgJ1hBSV9BUElfS0VZJyxcbiAgICAnR0VNSU5JX0FQSV9LRVknLFxuICAgICdCUkFWRV9TRUFSQ0hfQVBJX0tFWScsXG4gICAgJ1NFUlBBUElfQVBJX0tFWScsXG4gICAgJ1RBVklMWV9BUElfS0VZJyxcbiAgICAnU01UUF9QQVNTV09SRCcsXG4gIF07XG5cbiAgbGV0IHNhbml0aXplZCA9IG1lc3NhZ2U7XG5cbiAgZm9yIChjb25zdCBuYW1lIG9mIHNlY3JldE5hbWVzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBwcm9jZXNzLmVudltuYW1lXTtcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUubGVuZ3RoID49IDgpIHtcbiAgICAgIC8vIE9ubHkgc2FuaXRpemUgaWYgdGhlIHZhbHVlIGFwcGVhcnMgaW4gdGhlIG1lc3NhZ2VcbiAgICAgIC8vIFVzZSBhIGNhc2Utc2Vuc2l0aXZlIGV4YWN0IG1hdGNoIHRvIGF2b2lkIGZhbHNlIHBvc2l0aXZlc1xuICAgICAgaWYgKHNhbml0aXplZC5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgc2FuaXRpemVkID0gc2FuaXRpemVkLnNwbGl0KHZhbHVlKS5qb2luKCdbUkVEQUNURURdJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNhbml0aXplZDtcbn1cblxuLyoqXG4gKiBTYW5pdGl6ZSBhbiBFcnJvciBvYmplY3QncyBtZXNzYWdlIGFuZCBzdGFjayB0cmFjZS5cbiAqIFJldHVybnMgYSBuZXcgZXJyb3IgbWVzc2FnZSBzdHJpbmcgd2l0aCBzZWNyZXRzIHJlbW92ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZUVycm9yKGVycm9yOiBFcnJvcik6IHN0cmluZyB7XG4gIGNvbnN0IG1lc3NhZ2UgPSBzYW5pdGl6ZUVycm9yTWVzc2FnZShlcnJvci5tZXNzYWdlKTtcbiAgY29uc3Qgc3RhY2sgPSBlcnJvci5zdGFjayA/IHNhbml0aXplRXJyb3JNZXNzYWdlKGVycm9yLnN0YWNrKSA6ICcnO1xuXG4gIGlmIChzdGFjayAmJiBzdGFjayAhPT0gbWVzc2FnZSkge1xuICAgIHJldHVybiBgJHttZXNzYWdlfVxcbiR7c3RhY2t9YDtcbiAgfVxuICByZXR1cm4gbWVzc2FnZTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzYWZlIGVycm9yIG1lc3NhZ2UgZnJvbSBhbiB1bmtub3duIGVycm9yIHZhbHVlLlxuICogRW5zdXJlcyBubyBzZWNyZXRzIGFyZSBsZWFrZWQgcmVnYXJkbGVzcyBvZiBlcnJvciB0eXBlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FmZUVycm9yTWVzc2FnZShlcnJvcjogdW5rbm93bik6IHN0cmluZyB7XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIHNhbml0aXplRXJyb3JNZXNzYWdlKGVycm9yLm1lc3NhZ2UpO1xuICB9XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHNhbml0aXplRXJyb3JNZXNzYWdlKGVycm9yKTtcbiAgfVxuICByZXR1cm4gJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnO1xufVxuIl0sIm1hcHBpbmdz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Q0E7QUFDQTtBQUNBLFNBQVNRLDRCQUE0QkEsQ0FBQ1QsT0FBZSxFQUFVO0VBQzdELE1BQU1VLFdBQXlCLEdBQUcsQ0FDaEMsZ0JBQWdCLEVBQ2hCLG1CQUFtQixFQUNuQixrQkFBa0IsRUFDbEIsYUFBYSxFQUNiLGdCQUFnQixFQUNoQixzQkFBc0IsRUFDdEIsaUJBQWlCLEVBQ2pCLGdCQUFnQixFQUNoQixlQUFlLENBQ2hCO0VBRUQsSUFBSVQsU0FBUyxHQUFHRCxPQUFPO0VBRXZCLEtBQUssTUFBTW5ELElBQUksSUFBSTZELFdBQVcsRUFBRTtJQUM5QixNQUFNMUMsS0FBSyxHQUFHOUIsT0FBTyxDQUFDQyxHQUFHLENBQUNVLElBQUksQ0FBQztJQUMvQixJQUFJbUIsS0FBSyxJQUFJQSxLQUFLLENBQUNHLE1BQU0sSUFBSSxDQUFDLEVBQUU7TUFDOUI7TUFDQTtNQUNBLElBQUk4QixTQUFTLENBQUNuQixRQUFRLENBQUNkLEtBQUssQ0FBQyxFQUFFO1FBQzdCaUMsU0FBUyxHQUFHQSxTQUFTLENBQUNPLEtBQUssQ0FBQ3hDLEtBQUssQ0FBQyxDQUFDMUIsSUFBSSxDQUFDLFlBQVksQ0FBQztNQUN2RDtJQUNGO0VBQ0Y7RUFFQSxPQUFPMkQsU0FBUztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNVLGFBQWFBLENBQUNDLEtBQVksRUFBVTtFQUNsRCxNQUFNWixPQUFPLEdBQUdELG9CQUFvQixDQUFDYSxLQUFLLENBQUNaLE9BQU8sQ0FBQztFQUNuRCxNQUFNYSxLQUFLLEdBQUdELEtBQUssQ0FBQ0MsS0FBSyxHQUFHZCxvQkFBb0IsQ0FBQ2EsS0FBSyxDQUFDQyxLQUFLLENBQUMsR0FBRyxFQUFFO0VBRWxFLElBQUlBLEtBQUssSUFBSUEsS0FBSyxLQUFLYixPQUFPLEVBQUU7SUFDOUIsT0FBTyxHQUFHQSxPQUFPLEtBQUthLEtBQUssRUFBRTtFQUMvQjtFQUNBLE9BQU9iLE9BQU87QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTYyxnQkFBZ0JBLENBQUNGLEtBQWMsRUFBVTtFQUN2RCxJQUFJQSxLQUFLLFlBQVlsRSxLQUFLLEVBQUU7SUFDMUIsT0FBT3FELG9CQUFvQixDQUFDYSxLQUFLLENBQUNaLE9BQU8sQ0FBQztFQUM1QztFQUNBLElBQUksT0FBT1ksS0FBSyxLQUFLLFFBQVEsRUFBRTtJQUM3QixPQUFPYixvQkFBb0IsQ0FBQ2EsS0FBSyxDQUFDO0VBQ3BDO0VBQ0EsT0FBTyx3QkFBd0I7QUFDakMiLCJpZ25vcmVMaXN0IjpbXX0=