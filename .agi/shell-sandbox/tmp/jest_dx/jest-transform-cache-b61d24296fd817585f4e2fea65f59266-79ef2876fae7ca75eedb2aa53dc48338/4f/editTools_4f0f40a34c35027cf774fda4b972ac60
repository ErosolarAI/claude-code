03c21c725cbeb7383af7fcfed98081e7
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createEditTools = createEditTools;
exports.performSurgicalEdit = performSurgicalEdit;
var _promises = require("node:fs/promises");
var _nodePath = require("node:path");
var _errors = require("../core/errors.js");
var _diffUtils = require("./diffUtils.js");
/**
 * Track edit attempts per file to detect when edits keep being reverted (e.g., by linters/hooks)
 */
const fileEditAttempts = new Map();
const MAX_EDIT_ATTEMPTS_PER_FILE = 3;
const EDIT_ATTEMPT_RESET_MS = 60000; // Reset counter after 1 minute of no edits

/**
 * Creates the Edit tool for surgical file modifications using exact string replacement.
 *
 * This tool performs string-based edits without requiring full file rewrites,
 * making it ideal for targeted changes while preserving exact formatting and indentation.
 *
 * Features:
 * - Exact string matching (preserves indentation)
 * - Replace all occurrences or enforce uniqueness
 * - Unified diff preview
 * - Validation before writing
 *
 * @param workingDir - The working directory for resolving relative paths
 * @returns Array containing the Edit tool definition
 */
function createEditTools(workingDir) {
  return [{
    name: 'Edit',
    description: 'Performs exact string replacements in files. CRITICAL: For existing files, you MUST use the Read tool FIRST to get the exact text including whitespace and indentation, then copy it into old_string. The edit will FAIL if old_string is not unique unless replace_all is true. To CREATE a new file, use empty old_string (no prior read needed). To DELETE text, use empty new_string.',
    parameters: {
      type: 'object',
      properties: {
        file_path: {
          type: 'string',
          description: 'The absolute path to the file to modify or create'
        },
        old_string: {
          type: 'string',
          description: 'The exact text to replace (must match precisely including whitespace and indentation). For existing files, use read_file FIRST, then copy the exact text from its output (excluding line numbers). Use empty string "" to create a new file without needing a prior read.'
        },
        new_string: {
          type: 'string',
          default: '',
          description: 'The text to replace it with. Use empty string "" to delete the old_string. For new files, this is the full content. Defaults to "" when omitted.'
        },
        replace_all: {
          type: 'boolean',
          description: 'Replace all occurrences of old_string (default false). When false, the edit fails if old_string appears multiple times.'
        }
      },
      required: ['file_path', 'old_string'],
      additionalProperties: false
    },
    handler: async args => performSurgicalEdit(workingDir, args)
  }];
}
/**
 * Shared edit executor used by both legacy and unified tool flows.
 * Provides consistent validation, creation/deletion handling, and diff output.
 */
async function performSurgicalEdit(workingDir, args) {
  const pathArg = args['file_path'];
  const oldString = args['old_string'];
  const newStringRaw = args['new_string'];
  const replaceAll = args['replace_all'] === true;
  let replacementString = typeof newStringRaw === 'string' ? newStringRaw : '';

  // Validate inputs
  if (typeof pathArg !== 'string' || !pathArg.trim()) {
    return 'Error: file_path must be a non-empty string.';
  }
  if (typeof oldString !== 'string') {
    return 'Error: old_string must be a string (use "" for empty).';
  }
  if (newStringRaw !== undefined && typeof newStringRaw !== 'string') {
    return 'Error: new_string must be a string (use "" for empty).';
  }
  // Only error if both are identical AND non-empty (no-op edit)
  // Allow: empty old + content = create, content + empty new = delete
  if (oldString === replacementString && oldString !== '') {
    return 'Error: old_string and new_string are identical. No changes would be made.';
  }
  // Both empty is also a no-op
  if (oldString === '' && replacementString === '') {
    return 'Error: Both old_string and new_string are empty. Provide content to create a file or text to replace.';
  }
  try {
    const filePath = resolveFilePath(workingDir, pathArg);

    // Check if file exists
    let fileExists = false;
    try {
      await (0, _promises.stat)(filePath);
      fileExists = true;
    } catch {
      fileExists = false;
    }

    // Handle file creation mode (empty old_string)
    if (oldString === '') {
      if (fileExists) {
        return `Error: File already exists: ${filePath}\nTo modify an existing file, provide the exact text to replace in old_string.`;
      }

      // Create parent directories if needed
      const dir = (0, _nodePath.dirname)(filePath);
      await (0, _promises.mkdir)(dir, {
        recursive: true
      });

      // Write new file
      await (0, _promises.writeFile)(filePath, replacementString, 'utf-8');
      const relativePath = (0, _nodePath.relative)(workingDir, filePath);
      const displayPath = relativePath && !relativePath.startsWith('..') ? relativePath : filePath;
      const lineCount = replacementString.split('\n').length;
      const diffSegments = (0, _diffUtils.buildDiffSegmentsFast)('', replacementString);
      const addedLines = diffSegments.filter(s => s.type === 'added').length;
      const diffLines = (0, _diffUtils.formatDiffLines)(diffSegments, true);
      const diffBlock = diffLines.length > 0 ? diffLines.join('\n') : '(No visual diff - whitespace or formatting changes only)';
      return [`⏺ Create(${displayPath})`, `  ⎿  Created ${displayPath} with ${addedLines} additions`, `     ${lineCount} line${lineCount === 1 ? '' : 's'} written`, diffBlock].join('\n');
    }

    // For modifications, file must exist
    if (!fileExists) {
      return `Error: File not found: ${filePath}\nTo create a new file, use empty old_string ("").`;
    }

    // Read current content (async for speed)
    const currentContent = await (0, _promises.readFile)(filePath, 'utf-8');

    // Normalize escaped literals and whitespace differences to reduce mismatch errors
    let targetString = oldString;
    let matchNote = null;
    if (!currentContent.includes(targetString)) {
      const unescaped = unescapeLiteral(oldString);
      if (unescaped !== oldString && currentContent.includes(unescaped)) {
        targetString = unescaped;
        matchNote = 'normalized escaped old_string';
      }
    }
    if (!currentContent.includes(targetString)) {
      const flexibleMatch = matchWithFlexibleWhitespace(currentContent, targetString);
      if (flexibleMatch) {
        targetString = flexibleMatch;
        matchNote = matchNote ? matchNote : 'normalized whitespace in old_string';
      }
    }

    // Check if old_string exists in file
    if (!currentContent.includes(targetString)) {
      // Provide helpful debugging info when match fails
      const firstLine = oldString.split('\n')[0] || '';
      const suggestions = findSimilarLinesWithSuggestion(currentContent, firstLine, oldString, filePath, workingDir);

      // AI Flow Design: Provide structured guidance for self-correction
      const aiGuidance = buildAIRecoveryGuidance(oldString, currentContent);
      return ['Error: old_string not found in file.', '', `File: ${filePath}`, `Searching for: ${JSON.stringify(firstLine.substring(0, 80))}${firstLine.length > 80 ? '...' : ''}`, '', suggestions.hints, '', suggestions.actionable ? 'RECOMMENDED ACTION:' : 'Guidance:', suggestions.actionable ? suggestions.actionable : '- Ensure exact whitespace/indentation matches\n- Copy text directly from Read output\n- Check for tabs vs spaces', '', '---', 'AI SELF-CORRECTION GUIDANCE:', aiGuidance].join('\n');
    }

    // Count occurrences
    // Preserve indentation when we had to normalize whitespace to find the match
    if (matchNote === 'normalized whitespace in old_string') {
      const adjusted = alignIndentation(targetString, replacementString);
      if (adjusted !== replacementString) {
        replacementString = adjusted;
      }
    }
    const occurrences = countOccurrences(currentContent, targetString);
    if (!replaceAll && occurrences > 1) {
      return `Error: old_string appears ${occurrences} times in the file. Either:\n1. Provide a larger unique string that includes more context\n2. Set replace_all: true to replace all ${occurrences} occurrences\n\nFile: ${filePath}`;
    }

    // Perform replacement
    const newContent = replaceAll ? currentContent.split(targetString).join(replacementString) : currentContent.replace(targetString, replacementString);

    // Generate diff with context lines (Erosolar-CLI style)
    const diffResult = (0, _diffUtils.buildDiffWithContext)(currentContent, newContent, 2);

    // Check for repeated edit attempts on same file (detect linter/hook reversion loops)
    const now = Date.now();
    const attempts = fileEditAttempts.get(filePath);
    if (attempts) {
      // Reset if enough time has passed
      if (now - attempts.lastTimestamp > EDIT_ATTEMPT_RESET_MS) {
        fileEditAttempts.set(filePath, {
          count: 1,
          lastContent: newContent,
          lastTimestamp: now
        });
      } else if (attempts.lastContent === newContent) {
        // Same exact edit being attempted again - likely in a loop
        attempts.count++;
        attempts.lastTimestamp = now;
        if (attempts.count > MAX_EDIT_ATTEMPTS_PER_FILE) {
          return [`Error: Edit loop detected on ${filePath}`, '', `This edit has been attempted ${attempts.count} times in quick succession.`, 'The file may be getting reverted by a linter, formatter, or pre-commit hook.', '', 'To resolve:', '1. Check for active file watchers or formatters', '2. Disable auto-formatting temporarily', '3. Or accept the current file state and move on', '', 'STOPPING to prevent infinite loop.'].join('\n');
        }
      } else {
        // Different edit - reset counter but track the new content
        fileEditAttempts.set(filePath, {
          count: 1,
          lastContent: newContent,
          lastTimestamp: now
        });
      }
    } else {
      fileEditAttempts.set(filePath, {
        count: 1,
        lastContent: newContent,
        lastTimestamp: now
      });
    }

    // Write file (async for speed)
    await (0, _promises.writeFile)(filePath, newContent, 'utf-8');

    // Verify the edit persisted (detect immediate reversion by hooks/watchers)
    // Small delay to allow any file watchers to trigger
    await new Promise(resolve => setTimeout(resolve, 50));
    const verifyContent = await (0, _promises.readFile)(filePath, 'utf-8');
    if (verifyContent !== newContent) {
      // File was modified after our write - likely by a linter/formatter
      const editAttempts = fileEditAttempts.get(filePath);
      if (editAttempts) {
        editAttempts.count++;
      }
      return [`Warning: Edit was immediately modified by an external process.`, '', `File: ${filePath}`, 'The edit was written but the file content changed immediately after.', 'This is likely caused by a linter, formatter, or file watcher.', '', 'The current file state may differ from the intended edit.', 'Consider disabling auto-formatting or accepting the modified result.'].join('\n');
    }

    // Build summary (Erosolar-CLI style)
    const relativePath = (0, _nodePath.relative)(workingDir, filePath);
    const displayPath = relativePath && !relativePath.startsWith('..') ? relativePath : filePath;
    const {
      additions,
      removals
    } = diffResult;
    const occurrencesText = replaceAll ? ` (${occurrences} occurrence${occurrences > 1 ? 's' : ''})` : '';
    const noteText = matchNote ? ` [${matchNote}]` : '';

    // Format diff with colors for terminal display (Erosolar-CLI style)
    const diffLines = (0, _diffUtils.formatDiffClaudeStyle)(diffResult.segments, true);
    const diffBlock = diffLines.length > 0 ? diffLines.join('\n') : '      (No visual diff - whitespace or formatting changes only)';

    // Build Erosolar-CLI style output:
    // ⏺ Update(filepath)
    //   ⎿  Updated filepath with N additions and M removals
    //       41    }
    //       42 +   new line
    const additionText = additions === 1 ? '1 addition' : `${additions} additions`;
    const removalText = removals === 1 ? '1 removal' : `${removals} removals`;
    const summaryParts = [];
    if (additions > 0) summaryParts.push(additionText);
    if (removals > 0) summaryParts.push(removalText);
    const summaryText = summaryParts.length > 0 ? summaryParts.join(' and ') : 'no changes';
    return [`⏺ Update(${displayPath})${occurrencesText}${noteText}`, `  ⎿  Updated ${displayPath} with ${summaryText}`, diffBlock].join('\n');
  } catch (error) {
    return (0, _errors.buildError)('editing file', error, {
      file_path: typeof pathArg === 'string' ? pathArg : '',
      old_string_length: typeof oldString === 'string' ? oldString.length : 0,
      new_string_length: typeof replacementString === 'string' ? replacementString.length : 0
    });
  }
}
function resolveFilePath(workingDir, path) {
  const normalized = path.trim();
  return normalized.startsWith('/') ? normalized : (0, _nodePath.join)(workingDir, normalized);
}
function countOccurrences(text, search) {
  if (!search) return 0;
  let count = 0;
  let position = 0;
  while ((position = text.indexOf(search, position)) !== -1) {
    count++;
    position += search.length;
  }
  return count;
}

/**
 * Convert common escaped sequences (\\n, \\r, \\t, \\\\) into their literal forms.
 */
function unescapeLiteral(value) {
  if (!value.includes('\\')) return value;
  return value.replace(/\\\\/g, '\\').replace(/\\n/g, '\n').replace(/\\r/g, '\r').replace(/\\t/g, '\t');
}

/**
 * Try to locate the search string allowing whitespace differences (indentation, spacing).
 * Returns the exact substring from the original content when matched.
 */
function matchWithFlexibleWhitespace(content, search) {
  const normalizedPattern = buildWhitespaceFlexiblePattern(search);
  if (!normalizedPattern) {
    return null;
  }
  const regex = new RegExp(normalizedPattern, 's');
  const match = content.match(regex);
  return match ? match[0] : null;
}
function buildWhitespaceFlexiblePattern(search) {
  if (!search.trim()) {
    return null;
  }
  // Escape regex metacharacters
  const escaped = search.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  // Only allow flexible whitespace WITHIN lines, not across lines
  // This prevents matching across completely different code structures
  // Split by newlines, make each line flexible, then require exact newline boundaries
  const lines = escaped.split(/\\n|\n/);
  const flexibleLines = lines.map(line => line.replace(/[ \t]+/g, '[ \\t]+'));
  // Rejoin with flexible newline matching (allows \r\n or \n)
  return flexibleLines.join('\\r?\\n');
}

/**
 * When whitespace normalization is used, keep the replacement aligned with the matched indentation.
 * If a line in the replacement has no indentation, inherit indentation from the matched line.
 */
function alignIndentation(target, replacement) {
  const targetLines = target.split('\n');
  const replacementLines = replacement.split('\n');
  if (targetLines.length !== replacementLines.length) {
    return replacement;
  }
  const adjusted = replacementLines.map((line, idx) => {
    const targetLine = targetLines[idx] ?? '';
    const targetIndent = targetLine.match(/^\s*/)?.[0] ?? '';
    if (!line.trim()) {
      return targetIndent;
    }
    const lineIndent = line.match(/^\s*/)?.[0] ?? '';
    if (lineIndent.length < targetIndent.length) {
      const missing = targetIndent.slice(lineIndent.length);
      return `${lineIndent}${missing}${line.trimStart()}`;
    }
    return line;
  });
  return adjusted.join('\n');
}

/**
 * Enhanced similar line finder with actionable suggestions for AI.
 * Provides exact text to use in old_string and clear next steps.
 */
function findSimilarLinesWithSuggestion(content, searchFirstLine, _fullSearchText, filePath, workingDir) {
  const similarInfo = findSimilarLines(content, searchFirstLine, filePath);

  // Extract line numbers from similar lines
  const lineMatch = similarInfo.match(/Line (\d+)/);
  if (lineMatch && lineMatch[1]) {
    const lineNum = parseInt(lineMatch[1], 10);
    const relativePath = (0, _nodePath.relative)(workingDir, filePath);
    const displayPath = relativePath && !relativePath.startsWith('..') ? relativePath : filePath;

    // Provide concrete action: Read the file to get exact text
    const action = [`1. Use Read tool to view ${displayPath} starting at line ${Math.max(1, lineNum - 5)}`, `2. Copy the EXACT text from the Read output (including all indentation)`, `3. Use that exact text as old_string in your Edit call`, `4. Ensure you copy multiple lines if needed for uniqueness`].join('\n   ');
    return {
      hints: similarInfo,
      actionable: action
    };
  }

  // No similar lines found - suggest reading entire file
  const relativePath = (0, _nodePath.relative)(workingDir, filePath);
  const displayPath = relativePath && !relativePath.startsWith('..') ? relativePath : filePath;
  const action = [`1. Use Read tool to view the entire file: ${displayPath}`, `2. Locate the text you want to change`, `3. Copy the EXACT text including whitespace`, `4. Paste it as old_string in your Edit call`].join('\n   ');
  return {
    hints: similarInfo,
    actionable: action
  };
}

/**
 * Find lines in the file that are similar to the search text.
 * Enhanced with whitespace detection and auto-correction suggestions.
 */
function findSimilarLines(content, searchFirstLine, _filePath) {
  if (!searchFirstLine.trim()) {
    return 'The search string starts with an empty line.';
  }
  const lines = content.split('\n');
  const searchNormalized = searchFirstLine.trim().toLowerCase();
  const matches = [];

  // Find lines that contain key words from the search
  const searchWords = searchNormalized.split(/\s+/).filter(w => w.length > 2);
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i] || '';
    const lineNormalized = line.trim().toLowerCase();

    // Check for exact match with different whitespace
    if (lineNormalized === searchNormalized && line !== searchFirstLine) {
      const hasTabs = line.includes('\t') !== searchFirstLine.includes('\t');
      const leadingDiff = line.match(/^\s*/)?.[0]?.length !== searchFirstLine.match(/^\s*/)?.[0]?.length;
      const issue = hasTabs ? 'tabs vs spaces' : leadingDiff ? 'different indentation' : 'whitespace difference';
      matches.push({
        lineNum: i + 1,
        line,
        similarity: 0.99,
        issue
      });
      continue;
    }

    // Check for partial match (contains significant portion of the search)
    if (lineNormalized.includes(searchNormalized.substring(0, 20))) {
      matches.push({
        lineNum: i + 1,
        line,
        similarity: 1.0
      });
      continue;
    }

    // Check for word overlap
    if (searchWords.length > 0) {
      const matchingWords = searchWords.filter(w => lineNormalized.includes(w));
      const similarity = matchingWords.length / searchWords.length;
      if (similarity >= 0.5) {
        matches.push({
          lineNum: i + 1,
          line,
          similarity
        });
      }
    }
  }
  if (matches.length === 0) {
    return 'No similar lines found. The text may not exist in this file.';
  }

  // Sort by similarity and take top 3
  matches.sort((a, b) => b.similarity - a.similarity);
  const topMatches = matches.slice(0, 3);
  const suggestions = topMatches.map(m => {
    const truncated = m.line.length > 80 ? `${m.line.substring(0, 77)}...` : m.line;
    const issueNote = m.issue ? ` (${m.issue})` : '';
    return `  Line ${m.lineNum}${issueNote}: ${JSON.stringify(truncated)}`;
  });

  // Add auto-correction hint for whitespace issues
  const whitespaceMatch = topMatches.find(m => m.issue);
  if (whitespaceMatch) {
    return `Similar lines found (possible whitespace mismatch):\n${suggestions.join('\n')}\n\nCopy the exact text from Read output including indentation.`;
  }
  return `Similar lines found:\n${suggestions.join('\n')}`;
}

/**
 * Build AI-specific recovery guidance based on the failure pattern.
 * This function implements AI flow design principles for self-correction.
 */
function buildAIRecoveryGuidance(searchText, fileContent) {
  const guidance = [];

  // Analyze the failure pattern
  const hasMultipleLines = searchText.includes('\n');
  const hasLeadingWhitespace = /^\s/.test(searchText);
  const searchLen = searchText.length;
  const fileLen = fileContent.length;

  // PATTERN: Single line search in multi-line file
  if (!hasMultipleLines && fileLen > 1000) {
    guidance.push('• PATTERN DETECTED: Single-line search in large file', '  → Include 2-3 surrounding lines for uniqueness', '  → Use Read tool with specific line offset to get exact context');
  }

  // PATTERN: Missing leading whitespace
  if (!hasLeadingWhitespace && fileContent.includes('  ')) {
    guidance.push('• PATTERN DETECTED: Search text may be missing indentation', '  → File uses indentation, but old_string starts without whitespace', '  → Copy exact text from Read output including leading spaces/tabs');
  }

  // PATTERN: Very short search
  if (searchLen < 30) {
    guidance.push('• PATTERN DETECTED: Search text is very short (<30 chars)', '  → Short strings are prone to false negatives due to whitespace', '  → Include more context: function body, surrounding statements');
  }

  // PATTERN: Potential escape sequence issues
  if (searchText.includes('\\n') || searchText.includes('\\t')) {
    guidance.push('• PATTERN DETECTED: Escaped characters in search text', '  → old_string contains \\n or \\t as literal strings', '  → Use actual newlines/tabs, not escaped versions');
  }

  // PATTERN: Function/class definition
  if (/^(function|class|def |const |let |var |export )/.test(searchText.trim())) {
    guidance.push('• PATTERN DETECTED: Function/class definition search', '  → Definitions often have complex indentation', '  → Read the exact definition including all decorators/comments above');
  }

  // Default guidance if no specific pattern detected
  if (guidance.length === 0) {
    guidance.push('• GENERAL GUIDANCE:', '  1. Use Read tool to view file around expected location', '  2. Copy exact text from Read output (including all whitespace)', '  3. Verify the text exists in file before Edit call', '  4. Include more context lines if text appears multiple times');
  }

  // Always add the critical reminder
  guidance.push('', 'CRITICAL: Always Read → Copy → Edit. Never guess file content.');
  return guidance.join('\n');
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfcHJvbWlzZXMiLCJyZXF1aXJlIiwiX25vZGVQYXRoIiwiX2Vycm9ycyIsIl9kaWZmVXRpbHMiLCJmaWxlRWRpdEF0dGVtcHRzIiwiTWFwIiwiTUFYX0VESVRfQVRURU1QVFNfUEVSX0ZJTEUiLCJFRElUX0FUVEVNUFRfUkVTRVRfTVMiLCJjcmVhdGVFZGl0VG9vbHMiLCJ3b3JraW5nRGlyIiwibmFtZSIsImRlc2NyaXB0aW9uIiwicGFyYW1ldGVycyIsInR5cGUiLCJwcm9wZXJ0aWVzIiwiZmlsZV9wYXRoIiwib2xkX3N0cmluZyIsIm5ld19zdHJpbmciLCJkZWZhdWx0IiwicmVwbGFjZV9hbGwiLCJyZXF1aXJlZCIsImFkZGl0aW9uYWxQcm9wZXJ0aWVzIiwiaGFuZGxlciIsImFyZ3MiLCJwZXJmb3JtU3VyZ2ljYWxFZGl0IiwicGF0aEFyZyIsIm9sZFN0cmluZyIsIm5ld1N0cmluZ1JhdyIsInJlcGxhY2VBbGwiLCJyZXBsYWNlbWVudFN0cmluZyIsInRyaW0iLCJ1bmRlZmluZWQiLCJmaWxlUGF0aCIsInJlc29sdmVGaWxlUGF0aCIsImZpbGVFeGlzdHMiLCJzdGF0IiwiZGlyIiwiZGlybmFtZSIsIm1rZGlyIiwicmVjdXJzaXZlIiwid3JpdGVGaWxlIiwicmVsYXRpdmVQYXRoIiwicmVsYXRpdmUiLCJkaXNwbGF5UGF0aCIsInN0YXJ0c1dpdGgiLCJsaW5lQ291bnQiLCJzcGxpdCIsImxlbmd0aCIsImRpZmZTZWdtZW50cyIsImJ1aWxkRGlmZlNlZ21lbnRzRmFzdCIsImFkZGVkTGluZXMiLCJmaWx0ZXIiLCJzIiwiZGlmZkxpbmVzIiwiZm9ybWF0RGlmZkxpbmVzIiwiZGlmZkJsb2NrIiwiam9pbiIsImN1cnJlbnRDb250ZW50IiwicmVhZEZpbGUiLCJ0YXJnZXRTdHJpbmciLCJtYXRjaE5vdGUiLCJpbmNsdWRlcyIsInVuZXNjYXBlZCIsInVuZXNjYXBlTGl0ZXJhbCIsImZsZXhpYmxlTWF0Y2giLCJtYXRjaFdpdGhGbGV4aWJsZVdoaXRlc3BhY2UiLCJmaXJzdExpbmUiLCJzdWdnZXN0aW9ucyIsImZpbmRTaW1pbGFyTGluZXNXaXRoU3VnZ2VzdGlvbiIsImFpR3VpZGFuY2UiLCJidWlsZEFJUmVjb3ZlcnlHdWlkYW5jZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdWJzdHJpbmciLCJoaW50cyIsImFjdGlvbmFibGUiLCJhZGp1c3RlZCIsImFsaWduSW5kZW50YXRpb24iLCJvY2N1cnJlbmNlcyIsImNvdW50T2NjdXJyZW5jZXMiLCJuZXdDb250ZW50IiwicmVwbGFjZSIsImRpZmZSZXN1bHQiLCJidWlsZERpZmZXaXRoQ29udGV4dCIsIm5vdyIsIkRhdGUiLCJhdHRlbXB0cyIsImdldCIsImxhc3RUaW1lc3RhbXAiLCJzZXQiLCJjb3VudCIsImxhc3RDb250ZW50IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwidmVyaWZ5Q29udGVudCIsImVkaXRBdHRlbXB0cyIsImFkZGl0aW9ucyIsInJlbW92YWxzIiwib2NjdXJyZW5jZXNUZXh0Iiwibm90ZVRleHQiLCJmb3JtYXREaWZmQ2xhdWRlU3R5bGUiLCJzZWdtZW50cyIsImFkZGl0aW9uVGV4dCIsInJlbW92YWxUZXh0Iiwic3VtbWFyeVBhcnRzIiwicHVzaCIsInN1bW1hcnlUZXh0IiwiZXJyb3IiLCJidWlsZEVycm9yIiwib2xkX3N0cmluZ19sZW5ndGgiLCJuZXdfc3RyaW5nX2xlbmd0aCIsInBhdGgiLCJub3JtYWxpemVkIiwidGV4dCIsInNlYXJjaCIsInBvc2l0aW9uIiwiaW5kZXhPZiIsInZhbHVlIiwiY29udGVudCIsIm5vcm1hbGl6ZWRQYXR0ZXJuIiwiYnVpbGRXaGl0ZXNwYWNlRmxleGlibGVQYXR0ZXJuIiwicmVnZXgiLCJSZWdFeHAiLCJtYXRjaCIsImVzY2FwZWQiLCJsaW5lcyIsImZsZXhpYmxlTGluZXMiLCJtYXAiLCJsaW5lIiwidGFyZ2V0IiwicmVwbGFjZW1lbnQiLCJ0YXJnZXRMaW5lcyIsInJlcGxhY2VtZW50TGluZXMiLCJpZHgiLCJ0YXJnZXRMaW5lIiwidGFyZ2V0SW5kZW50IiwibGluZUluZGVudCIsIm1pc3NpbmciLCJzbGljZSIsInRyaW1TdGFydCIsInNlYXJjaEZpcnN0TGluZSIsIl9mdWxsU2VhcmNoVGV4dCIsInNpbWlsYXJJbmZvIiwiZmluZFNpbWlsYXJMaW5lcyIsImxpbmVNYXRjaCIsImxpbmVOdW0iLCJwYXJzZUludCIsImFjdGlvbiIsIk1hdGgiLCJtYXgiLCJfZmlsZVBhdGgiLCJzZWFyY2hOb3JtYWxpemVkIiwidG9Mb3dlckNhc2UiLCJtYXRjaGVzIiwic2VhcmNoV29yZHMiLCJ3IiwiaSIsImxpbmVOb3JtYWxpemVkIiwiaGFzVGFicyIsImxlYWRpbmdEaWZmIiwiaXNzdWUiLCJzaW1pbGFyaXR5IiwibWF0Y2hpbmdXb3JkcyIsInNvcnQiLCJhIiwiYiIsInRvcE1hdGNoZXMiLCJtIiwidHJ1bmNhdGVkIiwiaXNzdWVOb3RlIiwid2hpdGVzcGFjZU1hdGNoIiwiZmluZCIsInNlYXJjaFRleHQiLCJmaWxlQ29udGVudCIsImd1aWRhbmNlIiwiaGFzTXVsdGlwbGVMaW5lcyIsImhhc0xlYWRpbmdXaGl0ZXNwYWNlIiwidGVzdCIsInNlYXJjaExlbiIsImZpbGVMZW4iXSwic291cmNlcyI6WyJlZGl0VG9vbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVhZEZpbGUsIHdyaXRlRmlsZSwgc3RhdCwgbWtkaXIgfSBmcm9tICdub2RlOmZzL3Byb21pc2VzJztcbmltcG9ydCB7IGpvaW4sIHJlbGF0aXZlLCBkaXJuYW1lIH0gZnJvbSAnbm9kZTpwYXRoJztcbmltcG9ydCB0eXBlIHsgVG9vbERlZmluaXRpb24gfSBmcm9tICcuLi9jb3JlL3Rvb2xSdW50aW1lLmpzJztcbmltcG9ydCB7IGJ1aWxkRXJyb3IgfSBmcm9tICcuLi9jb3JlL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBidWlsZERpZmZTZWdtZW50c0Zhc3QsIGZvcm1hdERpZmZMaW5lcywgYnVpbGREaWZmV2l0aENvbnRleHQsIGZvcm1hdERpZmZDbGF1ZGVTdHlsZSB9IGZyb20gJy4vZGlmZlV0aWxzLmpzJztcblxuLyoqXG4gKiBUcmFjayBlZGl0IGF0dGVtcHRzIHBlciBmaWxlIHRvIGRldGVjdCB3aGVuIGVkaXRzIGtlZXAgYmVpbmcgcmV2ZXJ0ZWQgKGUuZy4sIGJ5IGxpbnRlcnMvaG9va3MpXG4gKi9cbmNvbnN0IGZpbGVFZGl0QXR0ZW1wdHMgPSBuZXcgTWFwPHN0cmluZywgeyBjb3VudDogbnVtYmVyOyBsYXN0Q29udGVudDogc3RyaW5nOyBsYXN0VGltZXN0YW1wOiBudW1iZXIgfT4oKTtcbmNvbnN0IE1BWF9FRElUX0FUVEVNUFRTX1BFUl9GSUxFID0gMztcbmNvbnN0IEVESVRfQVRURU1QVF9SRVNFVF9NUyA9IDYwMDAwOyAvLyBSZXNldCBjb3VudGVyIGFmdGVyIDEgbWludXRlIG9mIG5vIGVkaXRzXG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgRWRpdCB0b29sIGZvciBzdXJnaWNhbCBmaWxlIG1vZGlmaWNhdGlvbnMgdXNpbmcgZXhhY3Qgc3RyaW5nIHJlcGxhY2VtZW50LlxuICpcbiAqIFRoaXMgdG9vbCBwZXJmb3JtcyBzdHJpbmctYmFzZWQgZWRpdHMgd2l0aG91dCByZXF1aXJpbmcgZnVsbCBmaWxlIHJld3JpdGVzLFxuICogbWFraW5nIGl0IGlkZWFsIGZvciB0YXJnZXRlZCBjaGFuZ2VzIHdoaWxlIHByZXNlcnZpbmcgZXhhY3QgZm9ybWF0dGluZyBhbmQgaW5kZW50YXRpb24uXG4gKlxuICogRmVhdHVyZXM6XG4gKiAtIEV4YWN0IHN0cmluZyBtYXRjaGluZyAocHJlc2VydmVzIGluZGVudGF0aW9uKVxuICogLSBSZXBsYWNlIGFsbCBvY2N1cnJlbmNlcyBvciBlbmZvcmNlIHVuaXF1ZW5lc3NcbiAqIC0gVW5pZmllZCBkaWZmIHByZXZpZXdcbiAqIC0gVmFsaWRhdGlvbiBiZWZvcmUgd3JpdGluZ1xuICpcbiAqIEBwYXJhbSB3b3JraW5nRGlyIC0gVGhlIHdvcmtpbmcgZGlyZWN0b3J5IGZvciByZXNvbHZpbmcgcmVsYXRpdmUgcGF0aHNcbiAqIEByZXR1cm5zIEFycmF5IGNvbnRhaW5pbmcgdGhlIEVkaXQgdG9vbCBkZWZpbml0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFZGl0VG9vbHMod29ya2luZ0Rpcjogc3RyaW5nKTogVG9vbERlZmluaXRpb25bXSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgbmFtZTogJ0VkaXQnLFxuICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICdQZXJmb3JtcyBleGFjdCBzdHJpbmcgcmVwbGFjZW1lbnRzIGluIGZpbGVzLiBDUklUSUNBTDogRm9yIGV4aXN0aW5nIGZpbGVzLCB5b3UgTVVTVCB1c2UgdGhlIFJlYWQgdG9vbCBGSVJTVCB0byBnZXQgdGhlIGV4YWN0IHRleHQgaW5jbHVkaW5nIHdoaXRlc3BhY2UgYW5kIGluZGVudGF0aW9uLCB0aGVuIGNvcHkgaXQgaW50byBvbGRfc3RyaW5nLiBUaGUgZWRpdCB3aWxsIEZBSUwgaWYgb2xkX3N0cmluZyBpcyBub3QgdW5pcXVlIHVubGVzcyByZXBsYWNlX2FsbCBpcyB0cnVlLiBUbyBDUkVBVEUgYSBuZXcgZmlsZSwgdXNlIGVtcHR5IG9sZF9zdHJpbmcgKG5vIHByaW9yIHJlYWQgbmVlZGVkKS4gVG8gREVMRVRFIHRleHQsIHVzZSBlbXB0eSBuZXdfc3RyaW5nLicsXG4gICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgZmlsZV9wYXRoOiB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIGFic29sdXRlIHBhdGggdG8gdGhlIGZpbGUgdG8gbW9kaWZ5IG9yIGNyZWF0ZScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbGRfc3RyaW5nOiB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIGV4YWN0IHRleHQgdG8gcmVwbGFjZSAobXVzdCBtYXRjaCBwcmVjaXNlbHkgaW5jbHVkaW5nIHdoaXRlc3BhY2UgYW5kIGluZGVudGF0aW9uKS4gRm9yIGV4aXN0aW5nIGZpbGVzLCB1c2UgcmVhZF9maWxlIEZJUlNULCB0aGVuIGNvcHkgdGhlIGV4YWN0IHRleHQgZnJvbSBpdHMgb3V0cHV0IChleGNsdWRpbmcgbGluZSBudW1iZXJzKS4gVXNlIGVtcHR5IHN0cmluZyBcIlwiIHRvIGNyZWF0ZSBhIG5ldyBmaWxlIHdpdGhvdXQgbmVlZGluZyBhIHByaW9yIHJlYWQuJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIG5ld19zdHJpbmc6IHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgZGVmYXVsdDogJycsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAgICAgJ1RoZSB0ZXh0IHRvIHJlcGxhY2UgaXQgd2l0aC4gVXNlIGVtcHR5IHN0cmluZyBcIlwiIHRvIGRlbGV0ZSB0aGUgb2xkX3N0cmluZy4gRm9yIG5ldyBmaWxlcywgdGhpcyBpcyB0aGUgZnVsbCBjb250ZW50LiBEZWZhdWx0cyB0byBcIlwiIHdoZW4gb21pdHRlZC4nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVwbGFjZV9hbGw6IHtcbiAgICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgICAgICAnUmVwbGFjZSBhbGwgb2NjdXJyZW5jZXMgb2Ygb2xkX3N0cmluZyAoZGVmYXVsdCBmYWxzZSkuIFdoZW4gZmFsc2UsIHRoZSBlZGl0IGZhaWxzIGlmIG9sZF9zdHJpbmcgYXBwZWFycyBtdWx0aXBsZSB0aW1lcy4nLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVpcmVkOiBbJ2ZpbGVfcGF0aCcsICdvbGRfc3RyaW5nJ10sXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICBoYW5kbGVyOiBhc3luYyAoYXJncykgPT4gcGVyZm9ybVN1cmdpY2FsRWRpdCh3b3JraW5nRGlyLCBhcmdzKSxcbiAgICB9LFxuICBdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVkaXRBcmd1bWVudHMge1xuICBmaWxlX3BhdGg/OiB1bmtub3duO1xuICBvbGRfc3RyaW5nPzogdW5rbm93bjtcbiAgbmV3X3N0cmluZz86IHVua25vd247XG4gIHJlcGxhY2VfYWxsPzogdW5rbm93bjtcbn1cblxuLyoqXG4gKiBTaGFyZWQgZWRpdCBleGVjdXRvciB1c2VkIGJ5IGJvdGggbGVnYWN5IGFuZCB1bmlmaWVkIHRvb2wgZmxvd3MuXG4gKiBQcm92aWRlcyBjb25zaXN0ZW50IHZhbGlkYXRpb24sIGNyZWF0aW9uL2RlbGV0aW9uIGhhbmRsaW5nLCBhbmQgZGlmZiBvdXRwdXQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwZXJmb3JtU3VyZ2ljYWxFZGl0KFxuICB3b3JraW5nRGlyOiBzdHJpbmcsXG4gIGFyZ3M6IEVkaXRBcmd1bWVudHMgfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgcGF0aEFyZyA9IChhcmdzIGFzIEVkaXRBcmd1bWVudHMpWydmaWxlX3BhdGgnXTtcbiAgY29uc3Qgb2xkU3RyaW5nID0gKGFyZ3MgYXMgRWRpdEFyZ3VtZW50cylbJ29sZF9zdHJpbmcnXTtcbiAgY29uc3QgbmV3U3RyaW5nUmF3ID0gKGFyZ3MgYXMgRWRpdEFyZ3VtZW50cylbJ25ld19zdHJpbmcnXTtcbiAgY29uc3QgcmVwbGFjZUFsbCA9IChhcmdzIGFzIEVkaXRBcmd1bWVudHMpWydyZXBsYWNlX2FsbCddID09PSB0cnVlO1xuICBsZXQgcmVwbGFjZW1lbnRTdHJpbmcgPSB0eXBlb2YgbmV3U3RyaW5nUmF3ID09PSAnc3RyaW5nJyA/IG5ld1N0cmluZ1JhdyA6ICcnO1xuXG4gIC8vIFZhbGlkYXRlIGlucHV0c1xuICBpZiAodHlwZW9mIHBhdGhBcmcgIT09ICdzdHJpbmcnIHx8ICFwYXRoQXJnLnRyaW0oKSkge1xuICAgIHJldHVybiAnRXJyb3I6IGZpbGVfcGF0aCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZy4nO1xuICB9XG4gIGlmICh0eXBlb2Ygb2xkU3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiAnRXJyb3I6IG9sZF9zdHJpbmcgbXVzdCBiZSBhIHN0cmluZyAodXNlIFwiXCIgZm9yIGVtcHR5KS4nO1xuICB9XG4gIGlmIChuZXdTdHJpbmdSYXcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgbmV3U3RyaW5nUmF3ICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiAnRXJyb3I6IG5ld19zdHJpbmcgbXVzdCBiZSBhIHN0cmluZyAodXNlIFwiXCIgZm9yIGVtcHR5KS4nO1xuICB9XG4gIC8vIE9ubHkgZXJyb3IgaWYgYm90aCBhcmUgaWRlbnRpY2FsIEFORCBub24tZW1wdHkgKG5vLW9wIGVkaXQpXG4gIC8vIEFsbG93OiBlbXB0eSBvbGQgKyBjb250ZW50ID0gY3JlYXRlLCBjb250ZW50ICsgZW1wdHkgbmV3ID0gZGVsZXRlXG4gIGlmIChvbGRTdHJpbmcgPT09IHJlcGxhY2VtZW50U3RyaW5nICYmIG9sZFN0cmluZyAhPT0gJycpIHtcbiAgICByZXR1cm4gJ0Vycm9yOiBvbGRfc3RyaW5nIGFuZCBuZXdfc3RyaW5nIGFyZSBpZGVudGljYWwuIE5vIGNoYW5nZXMgd291bGQgYmUgbWFkZS4nO1xuICB9XG4gIC8vIEJvdGggZW1wdHkgaXMgYWxzbyBhIG5vLW9wXG4gIGlmIChvbGRTdHJpbmcgPT09ICcnICYmIHJlcGxhY2VtZW50U3RyaW5nID09PSAnJykge1xuICAgIHJldHVybiAnRXJyb3I6IEJvdGggb2xkX3N0cmluZyBhbmQgbmV3X3N0cmluZyBhcmUgZW1wdHkuIFByb3ZpZGUgY29udGVudCB0byBjcmVhdGUgYSBmaWxlIG9yIHRleHQgdG8gcmVwbGFjZS4nO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IHJlc29sdmVGaWxlUGF0aCh3b3JraW5nRGlyLCBwYXRoQXJnKTtcblxuICAgIC8vIENoZWNrIGlmIGZpbGUgZXhpc3RzXG4gICAgbGV0IGZpbGVFeGlzdHMgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgc3RhdChmaWxlUGF0aCk7XG4gICAgICBmaWxlRXhpc3RzID0gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGZpbGVFeGlzdHMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgZmlsZSBjcmVhdGlvbiBtb2RlIChlbXB0eSBvbGRfc3RyaW5nKVxuICAgIGlmIChvbGRTdHJpbmcgPT09ICcnKSB7XG4gICAgICBpZiAoZmlsZUV4aXN0cykge1xuICAgICAgICByZXR1cm4gYEVycm9yOiBGaWxlIGFscmVhZHkgZXhpc3RzOiAke2ZpbGVQYXRofVxcblRvIG1vZGlmeSBhbiBleGlzdGluZyBmaWxlLCBwcm92aWRlIHRoZSBleGFjdCB0ZXh0IHRvIHJlcGxhY2UgaW4gb2xkX3N0cmluZy5gO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgcGFyZW50IGRpcmVjdG9yaWVzIGlmIG5lZWRlZFxuICAgICAgY29uc3QgZGlyID0gZGlybmFtZShmaWxlUGF0aCk7XG4gICAgICBhd2FpdCBta2RpcihkaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuXG4gICAgICAvLyBXcml0ZSBuZXcgZmlsZVxuICAgICAgYXdhaXQgd3JpdGVGaWxlKGZpbGVQYXRoLCByZXBsYWNlbWVudFN0cmluZywgJ3V0Zi04Jyk7XG5cbiAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IHJlbGF0aXZlKHdvcmtpbmdEaXIsIGZpbGVQYXRoKTtcbiAgICAgIGNvbnN0IGRpc3BsYXlQYXRoID0gcmVsYXRpdmVQYXRoICYmICFyZWxhdGl2ZVBhdGguc3RhcnRzV2l0aCgnLi4nKSA/IHJlbGF0aXZlUGF0aCA6IGZpbGVQYXRoO1xuICAgICAgY29uc3QgbGluZUNvdW50ID0gcmVwbGFjZW1lbnRTdHJpbmcuc3BsaXQoJ1xcbicpLmxlbmd0aDtcbiAgICAgIGNvbnN0IGRpZmZTZWdtZW50cyA9IGJ1aWxkRGlmZlNlZ21lbnRzRmFzdCgnJywgcmVwbGFjZW1lbnRTdHJpbmcpO1xuICAgICAgY29uc3QgYWRkZWRMaW5lcyA9IGRpZmZTZWdtZW50cy5maWx0ZXIoKHMpID0+IHMudHlwZSA9PT0gJ2FkZGVkJykubGVuZ3RoO1xuICAgICAgY29uc3QgZGlmZkxpbmVzID0gZm9ybWF0RGlmZkxpbmVzKGRpZmZTZWdtZW50cywgdHJ1ZSk7XG4gICAgICBjb25zdCBkaWZmQmxvY2sgPVxuICAgICAgICBkaWZmTGluZXMubGVuZ3RoID4gMCA/IGRpZmZMaW5lcy5qb2luKCdcXG4nKSA6ICcoTm8gdmlzdWFsIGRpZmYgLSB3aGl0ZXNwYWNlIG9yIGZvcm1hdHRpbmcgY2hhbmdlcyBvbmx5KSc7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIGDij7ogQ3JlYXRlKCR7ZGlzcGxheVBhdGh9KWAsXG4gICAgICAgIGAgIOKOvyAgQ3JlYXRlZCAke2Rpc3BsYXlQYXRofSB3aXRoICR7YWRkZWRMaW5lc30gYWRkaXRpb25zYCxcbiAgICAgICAgYCAgICAgJHtsaW5lQ291bnR9IGxpbmUke2xpbmVDb3VudCA9PT0gMSA/ICcnIDogJ3MnfSB3cml0dGVuYCxcbiAgICAgICAgZGlmZkJsb2NrLFxuICAgICAgXS5qb2luKCdcXG4nKTtcbiAgICB9XG5cbiAgICAvLyBGb3IgbW9kaWZpY2F0aW9ucywgZmlsZSBtdXN0IGV4aXN0XG4gICAgaWYgKCFmaWxlRXhpc3RzKSB7XG4gICAgICByZXR1cm4gYEVycm9yOiBGaWxlIG5vdCBmb3VuZDogJHtmaWxlUGF0aH1cXG5UbyBjcmVhdGUgYSBuZXcgZmlsZSwgdXNlIGVtcHR5IG9sZF9zdHJpbmcgKFwiXCIpLmA7XG4gICAgfVxuXG4gICAgLy8gUmVhZCBjdXJyZW50IGNvbnRlbnQgKGFzeW5jIGZvciBzcGVlZClcbiAgICBjb25zdCBjdXJyZW50Q29udGVudCA9IGF3YWl0IHJlYWRGaWxlKGZpbGVQYXRoLCAndXRmLTgnKTtcblxuICAgIC8vIE5vcm1hbGl6ZSBlc2NhcGVkIGxpdGVyYWxzIGFuZCB3aGl0ZXNwYWNlIGRpZmZlcmVuY2VzIHRvIHJlZHVjZSBtaXNtYXRjaCBlcnJvcnNcbiAgICBsZXQgdGFyZ2V0U3RyaW5nID0gb2xkU3RyaW5nO1xuICAgIGxldCBtYXRjaE5vdGU6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgIGlmICghY3VycmVudENvbnRlbnQuaW5jbHVkZXModGFyZ2V0U3RyaW5nKSkge1xuICAgICAgY29uc3QgdW5lc2NhcGVkID0gdW5lc2NhcGVMaXRlcmFsKG9sZFN0cmluZyk7XG4gICAgICBpZiAodW5lc2NhcGVkICE9PSBvbGRTdHJpbmcgJiYgY3VycmVudENvbnRlbnQuaW5jbHVkZXModW5lc2NhcGVkKSkge1xuICAgICAgICB0YXJnZXRTdHJpbmcgPSB1bmVzY2FwZWQ7XG4gICAgICAgIG1hdGNoTm90ZSA9ICdub3JtYWxpemVkIGVzY2FwZWQgb2xkX3N0cmluZyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjdXJyZW50Q29udGVudC5pbmNsdWRlcyh0YXJnZXRTdHJpbmcpKSB7XG4gICAgICBjb25zdCBmbGV4aWJsZU1hdGNoID0gbWF0Y2hXaXRoRmxleGlibGVXaGl0ZXNwYWNlKGN1cnJlbnRDb250ZW50LCB0YXJnZXRTdHJpbmcpO1xuICAgICAgaWYgKGZsZXhpYmxlTWF0Y2gpIHtcbiAgICAgICAgdGFyZ2V0U3RyaW5nID0gZmxleGlibGVNYXRjaDtcbiAgICAgICAgbWF0Y2hOb3RlID0gbWF0Y2hOb3RlID8gbWF0Y2hOb3RlIDogJ25vcm1hbGl6ZWQgd2hpdGVzcGFjZSBpbiBvbGRfc3RyaW5nJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBvbGRfc3RyaW5nIGV4aXN0cyBpbiBmaWxlXG4gICAgaWYgKCFjdXJyZW50Q29udGVudC5pbmNsdWRlcyh0YXJnZXRTdHJpbmcpKSB7XG4gICAgICAvLyBQcm92aWRlIGhlbHBmdWwgZGVidWdnaW5nIGluZm8gd2hlbiBtYXRjaCBmYWlsc1xuICAgICAgY29uc3QgZmlyc3RMaW5lID0gb2xkU3RyaW5nLnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gZmluZFNpbWlsYXJMaW5lc1dpdGhTdWdnZXN0aW9uKGN1cnJlbnRDb250ZW50LCBmaXJzdExpbmUsIG9sZFN0cmluZywgZmlsZVBhdGgsIHdvcmtpbmdEaXIpO1xuXG4gICAgICAvLyBBSSBGbG93IERlc2lnbjogUHJvdmlkZSBzdHJ1Y3R1cmVkIGd1aWRhbmNlIGZvciBzZWxmLWNvcnJlY3Rpb25cbiAgICAgIGNvbnN0IGFpR3VpZGFuY2UgPSBidWlsZEFJUmVjb3ZlcnlHdWlkYW5jZShvbGRTdHJpbmcsIGN1cnJlbnRDb250ZW50KTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJ0Vycm9yOiBvbGRfc3RyaW5nIG5vdCBmb3VuZCBpbiBmaWxlLicsXG4gICAgICAgICcnLFxuICAgICAgICBgRmlsZTogJHtmaWxlUGF0aH1gLFxuICAgICAgICBgU2VhcmNoaW5nIGZvcjogJHtKU09OLnN0cmluZ2lmeShmaXJzdExpbmUuc3Vic3RyaW5nKDAsIDgwKSl9JHtmaXJzdExpbmUubGVuZ3RoID4gODAgPyAnLi4uJyA6ICcnfWAsXG4gICAgICAgICcnLFxuICAgICAgICBzdWdnZXN0aW9ucy5oaW50cyxcbiAgICAgICAgJycsXG4gICAgICAgIHN1Z2dlc3Rpb25zLmFjdGlvbmFibGUgPyAnUkVDT01NRU5ERUQgQUNUSU9OOicgOiAnR3VpZGFuY2U6JyxcbiAgICAgICAgc3VnZ2VzdGlvbnMuYWN0aW9uYWJsZSA/IHN1Z2dlc3Rpb25zLmFjdGlvbmFibGUgOiAnLSBFbnN1cmUgZXhhY3Qgd2hpdGVzcGFjZS9pbmRlbnRhdGlvbiBtYXRjaGVzXFxuLSBDb3B5IHRleHQgZGlyZWN0bHkgZnJvbSBSZWFkIG91dHB1dFxcbi0gQ2hlY2sgZm9yIHRhYnMgdnMgc3BhY2VzJyxcbiAgICAgICAgJycsXG4gICAgICAgICctLS0nLFxuICAgICAgICAnQUkgU0VMRi1DT1JSRUNUSU9OIEdVSURBTkNFOicsXG4gICAgICAgIGFpR3VpZGFuY2UsXG4gICAgICBdLmpvaW4oJ1xcbicpO1xuICAgIH1cblxuICAgIC8vIENvdW50IG9jY3VycmVuY2VzXG4gICAgLy8gUHJlc2VydmUgaW5kZW50YXRpb24gd2hlbiB3ZSBoYWQgdG8gbm9ybWFsaXplIHdoaXRlc3BhY2UgdG8gZmluZCB0aGUgbWF0Y2hcbiAgICBpZiAobWF0Y2hOb3RlID09PSAnbm9ybWFsaXplZCB3aGl0ZXNwYWNlIGluIG9sZF9zdHJpbmcnKSB7XG4gICAgICBjb25zdCBhZGp1c3RlZCA9IGFsaWduSW5kZW50YXRpb24odGFyZ2V0U3RyaW5nLCByZXBsYWNlbWVudFN0cmluZyk7XG4gICAgICBpZiAoYWRqdXN0ZWQgIT09IHJlcGxhY2VtZW50U3RyaW5nKSB7XG4gICAgICAgIHJlcGxhY2VtZW50U3RyaW5nID0gYWRqdXN0ZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb2NjdXJyZW5jZXMgPSBjb3VudE9jY3VycmVuY2VzKGN1cnJlbnRDb250ZW50LCB0YXJnZXRTdHJpbmcpO1xuXG4gICAgaWYgKCFyZXBsYWNlQWxsICYmIG9jY3VycmVuY2VzID4gMSkge1xuICAgICAgcmV0dXJuIGBFcnJvcjogb2xkX3N0cmluZyBhcHBlYXJzICR7b2NjdXJyZW5jZXN9IHRpbWVzIGluIHRoZSBmaWxlLiBFaXRoZXI6XFxuMS4gUHJvdmlkZSBhIGxhcmdlciB1bmlxdWUgc3RyaW5nIHRoYXQgaW5jbHVkZXMgbW9yZSBjb250ZXh0XFxuMi4gU2V0IHJlcGxhY2VfYWxsOiB0cnVlIHRvIHJlcGxhY2UgYWxsICR7b2NjdXJyZW5jZXN9IG9jY3VycmVuY2VzXFxuXFxuRmlsZTogJHtmaWxlUGF0aH1gO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gcmVwbGFjZW1lbnRcbiAgICBjb25zdCBuZXdDb250ZW50ID0gcmVwbGFjZUFsbFxuICAgICAgPyBjdXJyZW50Q29udGVudC5zcGxpdCh0YXJnZXRTdHJpbmcpLmpvaW4ocmVwbGFjZW1lbnRTdHJpbmcpXG4gICAgICA6IGN1cnJlbnRDb250ZW50LnJlcGxhY2UodGFyZ2V0U3RyaW5nLCByZXBsYWNlbWVudFN0cmluZyk7XG5cbiAgICAvLyBHZW5lcmF0ZSBkaWZmIHdpdGggY29udGV4dCBsaW5lcyAoRXJvc29sYXItQ0xJIHN0eWxlKVxuICAgIGNvbnN0IGRpZmZSZXN1bHQgPSBidWlsZERpZmZXaXRoQ29udGV4dChjdXJyZW50Q29udGVudCwgbmV3Q29udGVudCwgMik7XG5cbiAgICAvLyBDaGVjayBmb3IgcmVwZWF0ZWQgZWRpdCBhdHRlbXB0cyBvbiBzYW1lIGZpbGUgKGRldGVjdCBsaW50ZXIvaG9vayByZXZlcnNpb24gbG9vcHMpXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBhdHRlbXB0cyA9IGZpbGVFZGl0QXR0ZW1wdHMuZ2V0KGZpbGVQYXRoKTtcbiAgICBpZiAoYXR0ZW1wdHMpIHtcbiAgICAgIC8vIFJlc2V0IGlmIGVub3VnaCB0aW1lIGhhcyBwYXNzZWRcbiAgICAgIGlmIChub3cgLSBhdHRlbXB0cy5sYXN0VGltZXN0YW1wID4gRURJVF9BVFRFTVBUX1JFU0VUX01TKSB7XG4gICAgICAgIGZpbGVFZGl0QXR0ZW1wdHMuc2V0KGZpbGVQYXRoLCB7IGNvdW50OiAxLCBsYXN0Q29udGVudDogbmV3Q29udGVudCwgbGFzdFRpbWVzdGFtcDogbm93IH0pO1xuICAgICAgfSBlbHNlIGlmIChhdHRlbXB0cy5sYXN0Q29udGVudCA9PT0gbmV3Q29udGVudCkge1xuICAgICAgICAvLyBTYW1lIGV4YWN0IGVkaXQgYmVpbmcgYXR0ZW1wdGVkIGFnYWluIC0gbGlrZWx5IGluIGEgbG9vcFxuICAgICAgICBhdHRlbXB0cy5jb3VudCsrO1xuICAgICAgICBhdHRlbXB0cy5sYXN0VGltZXN0YW1wID0gbm93O1xuICAgICAgICBpZiAoYXR0ZW1wdHMuY291bnQgPiBNQVhfRURJVF9BVFRFTVBUU19QRVJfRklMRSkge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBgRXJyb3I6IEVkaXQgbG9vcCBkZXRlY3RlZCBvbiAke2ZpbGVQYXRofWAsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgIGBUaGlzIGVkaXQgaGFzIGJlZW4gYXR0ZW1wdGVkICR7YXR0ZW1wdHMuY291bnR9IHRpbWVzIGluIHF1aWNrIHN1Y2Nlc3Npb24uYCxcbiAgICAgICAgICAgICdUaGUgZmlsZSBtYXkgYmUgZ2V0dGluZyByZXZlcnRlZCBieSBhIGxpbnRlciwgZm9ybWF0dGVyLCBvciBwcmUtY29tbWl0IGhvb2suJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJ1RvIHJlc29sdmU6JyxcbiAgICAgICAgICAgICcxLiBDaGVjayBmb3IgYWN0aXZlIGZpbGUgd2F0Y2hlcnMgb3IgZm9ybWF0dGVycycsXG4gICAgICAgICAgICAnMi4gRGlzYWJsZSBhdXRvLWZvcm1hdHRpbmcgdGVtcG9yYXJpbHknLFxuICAgICAgICAgICAgJzMuIE9yIGFjY2VwdCB0aGUgY3VycmVudCBmaWxlIHN0YXRlIGFuZCBtb3ZlIG9uJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJ1NUT1BQSU5HIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcC4nLFxuICAgICAgICAgIF0uam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERpZmZlcmVudCBlZGl0IC0gcmVzZXQgY291bnRlciBidXQgdHJhY2sgdGhlIG5ldyBjb250ZW50XG4gICAgICAgIGZpbGVFZGl0QXR0ZW1wdHMuc2V0KGZpbGVQYXRoLCB7IGNvdW50OiAxLCBsYXN0Q29udGVudDogbmV3Q29udGVudCwgbGFzdFRpbWVzdGFtcDogbm93IH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmaWxlRWRpdEF0dGVtcHRzLnNldChmaWxlUGF0aCwgeyBjb3VudDogMSwgbGFzdENvbnRlbnQ6IG5ld0NvbnRlbnQsIGxhc3RUaW1lc3RhbXA6IG5vdyB9KTtcbiAgICB9XG5cbiAgICAvLyBXcml0ZSBmaWxlIChhc3luYyBmb3Igc3BlZWQpXG4gICAgYXdhaXQgd3JpdGVGaWxlKGZpbGVQYXRoLCBuZXdDb250ZW50LCAndXRmLTgnKTtcblxuICAgIC8vIFZlcmlmeSB0aGUgZWRpdCBwZXJzaXN0ZWQgKGRldGVjdCBpbW1lZGlhdGUgcmV2ZXJzaW9uIGJ5IGhvb2tzL3dhdGNoZXJzKVxuICAgIC8vIFNtYWxsIGRlbGF5IHRvIGFsbG93IGFueSBmaWxlIHdhdGNoZXJzIHRvIHRyaWdnZXJcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTApKTtcbiAgICBjb25zdCB2ZXJpZnlDb250ZW50ID0gYXdhaXQgcmVhZEZpbGUoZmlsZVBhdGgsICd1dGYtOCcpO1xuICAgIGlmICh2ZXJpZnlDb250ZW50ICE9PSBuZXdDb250ZW50KSB7XG4gICAgICAvLyBGaWxlIHdhcyBtb2RpZmllZCBhZnRlciBvdXIgd3JpdGUgLSBsaWtlbHkgYnkgYSBsaW50ZXIvZm9ybWF0dGVyXG4gICAgICBjb25zdCBlZGl0QXR0ZW1wdHMgPSBmaWxlRWRpdEF0dGVtcHRzLmdldChmaWxlUGF0aCk7XG4gICAgICBpZiAoZWRpdEF0dGVtcHRzKSB7XG4gICAgICAgIGVkaXRBdHRlbXB0cy5jb3VudCsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYFdhcm5pbmc6IEVkaXQgd2FzIGltbWVkaWF0ZWx5IG1vZGlmaWVkIGJ5IGFuIGV4dGVybmFsIHByb2Nlc3MuYCxcbiAgICAgICAgJycsXG4gICAgICAgIGBGaWxlOiAke2ZpbGVQYXRofWAsXG4gICAgICAgICdUaGUgZWRpdCB3YXMgd3JpdHRlbiBidXQgdGhlIGZpbGUgY29udGVudCBjaGFuZ2VkIGltbWVkaWF0ZWx5IGFmdGVyLicsXG4gICAgICAgICdUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBsaW50ZXIsIGZvcm1hdHRlciwgb3IgZmlsZSB3YXRjaGVyLicsXG4gICAgICAgICcnLFxuICAgICAgICAnVGhlIGN1cnJlbnQgZmlsZSBzdGF0ZSBtYXkgZGlmZmVyIGZyb20gdGhlIGludGVuZGVkIGVkaXQuJyxcbiAgICAgICAgJ0NvbnNpZGVyIGRpc2FibGluZyBhdXRvLWZvcm1hdHRpbmcgb3IgYWNjZXB0aW5nIHRoZSBtb2RpZmllZCByZXN1bHQuJyxcbiAgICAgIF0uam9pbignXFxuJyk7XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgc3VtbWFyeSAoRXJvc29sYXItQ0xJIHN0eWxlKVxuICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IHJlbGF0aXZlKHdvcmtpbmdEaXIsIGZpbGVQYXRoKTtcbiAgICBjb25zdCBkaXNwbGF5UGF0aCA9IHJlbGF0aXZlUGF0aCAmJiAhcmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgoJy4uJykgPyByZWxhdGl2ZVBhdGggOiBmaWxlUGF0aDtcbiAgICBjb25zdCB7IGFkZGl0aW9ucywgcmVtb3ZhbHMgfSA9IGRpZmZSZXN1bHQ7XG4gICAgY29uc3Qgb2NjdXJyZW5jZXNUZXh0ID0gcmVwbGFjZUFsbCA/IGAgKCR7b2NjdXJyZW5jZXN9IG9jY3VycmVuY2Uke29jY3VycmVuY2VzID4gMSA/ICdzJyA6ICcnfSlgIDogJyc7XG4gICAgY29uc3Qgbm90ZVRleHQgPSBtYXRjaE5vdGUgPyBgIFske21hdGNoTm90ZX1dYCA6ICcnO1xuXG4gICAgLy8gRm9ybWF0IGRpZmYgd2l0aCBjb2xvcnMgZm9yIHRlcm1pbmFsIGRpc3BsYXkgKEVyb3NvbGFyLUNMSSBzdHlsZSlcbiAgICBjb25zdCBkaWZmTGluZXMgPSBmb3JtYXREaWZmQ2xhdWRlU3R5bGUoZGlmZlJlc3VsdC5zZWdtZW50cywgdHJ1ZSk7XG4gICAgY29uc3QgZGlmZkJsb2NrID1cbiAgICAgIGRpZmZMaW5lcy5sZW5ndGggPiAwID8gZGlmZkxpbmVzLmpvaW4oJ1xcbicpIDogJyAgICAgIChObyB2aXN1YWwgZGlmZiAtIHdoaXRlc3BhY2Ugb3IgZm9ybWF0dGluZyBjaGFuZ2VzIG9ubHkpJztcblxuICAgIC8vIEJ1aWxkIEVyb3NvbGFyLUNMSSBzdHlsZSBvdXRwdXQ6XG4gICAgLy8g4o+6IFVwZGF0ZShmaWxlcGF0aClcbiAgICAvLyAgIOKOvyAgVXBkYXRlZCBmaWxlcGF0aCB3aXRoIE4gYWRkaXRpb25zIGFuZCBNIHJlbW92YWxzXG4gICAgLy8gICAgICAgNDEgICAgfVxuICAgIC8vICAgICAgIDQyICsgICBuZXcgbGluZVxuICAgIGNvbnN0IGFkZGl0aW9uVGV4dCA9IGFkZGl0aW9ucyA9PT0gMSA/ICcxIGFkZGl0aW9uJyA6IGAke2FkZGl0aW9uc30gYWRkaXRpb25zYDtcbiAgICBjb25zdCByZW1vdmFsVGV4dCA9IHJlbW92YWxzID09PSAxID8gJzEgcmVtb3ZhbCcgOiBgJHtyZW1vdmFsc30gcmVtb3ZhbHNgO1xuICAgIGNvbnN0IHN1bW1hcnlQYXJ0cyA9IFtdO1xuICAgIGlmIChhZGRpdGlvbnMgPiAwKSBzdW1tYXJ5UGFydHMucHVzaChhZGRpdGlvblRleHQpO1xuICAgIGlmIChyZW1vdmFscyA+IDApIHN1bW1hcnlQYXJ0cy5wdXNoKHJlbW92YWxUZXh0KTtcbiAgICBjb25zdCBzdW1tYXJ5VGV4dCA9IHN1bW1hcnlQYXJ0cy5sZW5ndGggPiAwID8gc3VtbWFyeVBhcnRzLmpvaW4oJyBhbmQgJykgOiAnbm8gY2hhbmdlcyc7XG5cbiAgICByZXR1cm4gW1xuICAgICAgYOKPuiBVcGRhdGUoJHtkaXNwbGF5UGF0aH0pJHtvY2N1cnJlbmNlc1RleHR9JHtub3RlVGV4dH1gLFxuICAgICAgYCAg4o6/ICBVcGRhdGVkICR7ZGlzcGxheVBhdGh9IHdpdGggJHtzdW1tYXJ5VGV4dH1gLFxuICAgICAgZGlmZkJsb2NrLFxuICAgIF0uam9pbignXFxuJyk7XG4gIH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG4gICAgcmV0dXJuIGJ1aWxkRXJyb3IoJ2VkaXRpbmcgZmlsZScsIGVycm9yLCB7XG4gICAgICBmaWxlX3BhdGg6IHR5cGVvZiBwYXRoQXJnID09PSAnc3RyaW5nJyA/IHBhdGhBcmcgOiAnJyxcbiAgICAgIG9sZF9zdHJpbmdfbGVuZ3RoOiB0eXBlb2Ygb2xkU3RyaW5nID09PSAnc3RyaW5nJyA/IG9sZFN0cmluZy5sZW5ndGggOiAwLFxuICAgICAgbmV3X3N0cmluZ19sZW5ndGg6IHR5cGVvZiByZXBsYWNlbWVudFN0cmluZyA9PT0gJ3N0cmluZycgPyByZXBsYWNlbWVudFN0cmluZy5sZW5ndGggOiAwLFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVGaWxlUGF0aCh3b3JraW5nRGlyOiBzdHJpbmcsIHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBwYXRoLnRyaW0oKTtcbiAgcmV0dXJuIG5vcm1hbGl6ZWQuc3RhcnRzV2l0aCgnLycpID8gbm9ybWFsaXplZCA6IGpvaW4od29ya2luZ0Rpciwgbm9ybWFsaXplZCk7XG59XG5cbmZ1bmN0aW9uIGNvdW50T2NjdXJyZW5jZXModGV4dDogc3RyaW5nLCBzZWFyY2g6IHN0cmluZyk6IG51bWJlciB7XG4gIGlmICghc2VhcmNoKSByZXR1cm4gMDtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IHBvc2l0aW9uID0gMDtcblxuICB3aGlsZSAoKHBvc2l0aW9uID0gdGV4dC5pbmRleE9mKHNlYXJjaCwgcG9zaXRpb24pKSAhPT0gLTEpIHtcbiAgICBjb3VudCsrO1xuICAgIHBvc2l0aW9uICs9IHNlYXJjaC5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gY291bnQ7XG59XG5cbi8qKlxuICogQ29udmVydCBjb21tb24gZXNjYXBlZCBzZXF1ZW5jZXMgKFxcXFxuLCBcXFxcciwgXFxcXHQsIFxcXFxcXFxcKSBpbnRvIHRoZWlyIGxpdGVyYWwgZm9ybXMuXG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlTGl0ZXJhbCh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKCF2YWx1ZS5pbmNsdWRlcygnXFxcXCcpKSByZXR1cm4gdmFsdWU7XG4gIHJldHVybiB2YWx1ZVxuICAgIC5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnXFxcXCcpXG4gICAgLnJlcGxhY2UoL1xcXFxuL2csICdcXG4nKVxuICAgIC5yZXBsYWNlKC9cXFxcci9nLCAnXFxyJylcbiAgICAucmVwbGFjZSgvXFxcXHQvZywgJ1xcdCcpO1xufVxuXG4vKipcbiAqIFRyeSB0byBsb2NhdGUgdGhlIHNlYXJjaCBzdHJpbmcgYWxsb3dpbmcgd2hpdGVzcGFjZSBkaWZmZXJlbmNlcyAoaW5kZW50YXRpb24sIHNwYWNpbmcpLlxuICogUmV0dXJucyB0aGUgZXhhY3Qgc3Vic3RyaW5nIGZyb20gdGhlIG9yaWdpbmFsIGNvbnRlbnQgd2hlbiBtYXRjaGVkLlxuICovXG5mdW5jdGlvbiBtYXRjaFdpdGhGbGV4aWJsZVdoaXRlc3BhY2UoY29udGVudDogc3RyaW5nLCBzZWFyY2g6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICBjb25zdCBub3JtYWxpemVkUGF0dGVybiA9IGJ1aWxkV2hpdGVzcGFjZUZsZXhpYmxlUGF0dGVybihzZWFyY2gpO1xuICBpZiAoIW5vcm1hbGl6ZWRQYXR0ZXJuKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKG5vcm1hbGl6ZWRQYXR0ZXJuLCAncycpO1xuICBjb25zdCBtYXRjaCA9IGNvbnRlbnQubWF0Y2gocmVnZXgpO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFswXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkV2hpdGVzcGFjZUZsZXhpYmxlUGF0dGVybihzZWFyY2g6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICBpZiAoIXNlYXJjaC50cmltKCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBFc2NhcGUgcmVnZXggbWV0YWNoYXJhY3RlcnNcbiAgY29uc3QgZXNjYXBlZCA9IHNlYXJjaC5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xuICAvLyBPbmx5IGFsbG93IGZsZXhpYmxlIHdoaXRlc3BhY2UgV0lUSElOIGxpbmVzLCBub3QgYWNyb3NzIGxpbmVzXG4gIC8vIFRoaXMgcHJldmVudHMgbWF0Y2hpbmcgYWNyb3NzIGNvbXBsZXRlbHkgZGlmZmVyZW50IGNvZGUgc3RydWN0dXJlc1xuICAvLyBTcGxpdCBieSBuZXdsaW5lcywgbWFrZSBlYWNoIGxpbmUgZmxleGlibGUsIHRoZW4gcmVxdWlyZSBleGFjdCBuZXdsaW5lIGJvdW5kYXJpZXNcbiAgY29uc3QgbGluZXMgPSBlc2NhcGVkLnNwbGl0KC9cXFxcbnxcXG4vKTtcbiAgY29uc3QgZmxleGlibGVMaW5lcyA9IGxpbmVzLm1hcChsaW5lID0+IGxpbmUucmVwbGFjZSgvWyBcXHRdKy9nLCAnWyBcXFxcdF0rJykpO1xuICAvLyBSZWpvaW4gd2l0aCBmbGV4aWJsZSBuZXdsaW5lIG1hdGNoaW5nIChhbGxvd3MgXFxyXFxuIG9yIFxcbilcbiAgcmV0dXJuIGZsZXhpYmxlTGluZXMuam9pbignXFxcXHI/XFxcXG4nKTtcbn1cblxuLyoqXG4gKiBXaGVuIHdoaXRlc3BhY2Ugbm9ybWFsaXphdGlvbiBpcyB1c2VkLCBrZWVwIHRoZSByZXBsYWNlbWVudCBhbGlnbmVkIHdpdGggdGhlIG1hdGNoZWQgaW5kZW50YXRpb24uXG4gKiBJZiBhIGxpbmUgaW4gdGhlIHJlcGxhY2VtZW50IGhhcyBubyBpbmRlbnRhdGlvbiwgaW5oZXJpdCBpbmRlbnRhdGlvbiBmcm9tIHRoZSBtYXRjaGVkIGxpbmUuXG4gKi9cbmZ1bmN0aW9uIGFsaWduSW5kZW50YXRpb24odGFyZ2V0OiBzdHJpbmcsIHJlcGxhY2VtZW50OiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCB0YXJnZXRMaW5lcyA9IHRhcmdldC5zcGxpdCgnXFxuJyk7XG4gIGNvbnN0IHJlcGxhY2VtZW50TGluZXMgPSByZXBsYWNlbWVudC5zcGxpdCgnXFxuJyk7XG4gIGlmICh0YXJnZXRMaW5lcy5sZW5ndGggIT09IHJlcGxhY2VtZW50TGluZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VtZW50O1xuICB9XG5cbiAgY29uc3QgYWRqdXN0ZWQgPSByZXBsYWNlbWVudExpbmVzLm1hcCgobGluZSwgaWR4KSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0TGluZSA9IHRhcmdldExpbmVzW2lkeF0gPz8gJyc7XG4gICAgY29uc3QgdGFyZ2V0SW5kZW50ID0gdGFyZ2V0TGluZS5tYXRjaCgvXlxccyovKT8uWzBdID8/ICcnO1xuICAgIGlmICghbGluZS50cmltKCkpIHtcbiAgICAgIHJldHVybiB0YXJnZXRJbmRlbnQ7XG4gICAgfVxuICAgIGNvbnN0IGxpbmVJbmRlbnQgPSBsaW5lLm1hdGNoKC9eXFxzKi8pPy5bMF0gPz8gJyc7XG4gICAgaWYgKGxpbmVJbmRlbnQubGVuZ3RoIDwgdGFyZ2V0SW5kZW50Lmxlbmd0aCkge1xuICAgICAgY29uc3QgbWlzc2luZyA9IHRhcmdldEluZGVudC5zbGljZShsaW5lSW5kZW50Lmxlbmd0aCk7XG4gICAgICByZXR1cm4gYCR7bGluZUluZGVudH0ke21pc3Npbmd9JHtsaW5lLnRyaW1TdGFydCgpfWA7XG4gICAgfVxuICAgIHJldHVybiBsaW5lO1xuICB9KTtcblxuICByZXR1cm4gYWRqdXN0ZWQuam9pbignXFxuJyk7XG59XG5cbi8qKlxuICogRW5oYW5jZWQgc2ltaWxhciBsaW5lIGZpbmRlciB3aXRoIGFjdGlvbmFibGUgc3VnZ2VzdGlvbnMgZm9yIEFJLlxuICogUHJvdmlkZXMgZXhhY3QgdGV4dCB0byB1c2UgaW4gb2xkX3N0cmluZyBhbmQgY2xlYXIgbmV4dCBzdGVwcy5cbiAqL1xuZnVuY3Rpb24gZmluZFNpbWlsYXJMaW5lc1dpdGhTdWdnZXN0aW9uKFxuICBjb250ZW50OiBzdHJpbmcsXG4gIHNlYXJjaEZpcnN0TGluZTogc3RyaW5nLFxuICBfZnVsbFNlYXJjaFRleHQ6IHN0cmluZyxcbiAgZmlsZVBhdGg6IHN0cmluZyxcbiAgd29ya2luZ0Rpcjogc3RyaW5nXG4pOiB7IGhpbnRzOiBzdHJpbmc7IGFjdGlvbmFibGU6IHN0cmluZyB8IG51bGwgfSB7XG4gIGNvbnN0IHNpbWlsYXJJbmZvID0gZmluZFNpbWlsYXJMaW5lcyhjb250ZW50LCBzZWFyY2hGaXJzdExpbmUsIGZpbGVQYXRoKTtcblxuICAvLyBFeHRyYWN0IGxpbmUgbnVtYmVycyBmcm9tIHNpbWlsYXIgbGluZXNcbiAgY29uc3QgbGluZU1hdGNoID0gc2ltaWxhckluZm8ubWF0Y2goL0xpbmUgKFxcZCspLyk7XG4gIGlmIChsaW5lTWF0Y2ggJiYgbGluZU1hdGNoWzFdKSB7XG4gICAgY29uc3QgbGluZU51bSA9IHBhcnNlSW50KGxpbmVNYXRjaFsxXSwgMTApO1xuICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IHJlbGF0aXZlKHdvcmtpbmdEaXIsIGZpbGVQYXRoKTtcbiAgICBjb25zdCBkaXNwbGF5UGF0aCA9IHJlbGF0aXZlUGF0aCAmJiAhcmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgoJy4uJykgPyByZWxhdGl2ZVBhdGggOiBmaWxlUGF0aDtcblxuICAgIC8vIFByb3ZpZGUgY29uY3JldGUgYWN0aW9uOiBSZWFkIHRoZSBmaWxlIHRvIGdldCBleGFjdCB0ZXh0XG4gICAgY29uc3QgYWN0aW9uID0gW1xuICAgICAgYDEuIFVzZSBSZWFkIHRvb2wgdG8gdmlldyAke2Rpc3BsYXlQYXRofSBzdGFydGluZyBhdCBsaW5lICR7TWF0aC5tYXgoMSwgbGluZU51bSAtIDUpfWAsXG4gICAgICBgMi4gQ29weSB0aGUgRVhBQ1QgdGV4dCBmcm9tIHRoZSBSZWFkIG91dHB1dCAoaW5jbHVkaW5nIGFsbCBpbmRlbnRhdGlvbilgLFxuICAgICAgYDMuIFVzZSB0aGF0IGV4YWN0IHRleHQgYXMgb2xkX3N0cmluZyBpbiB5b3VyIEVkaXQgY2FsbGAsXG4gICAgICBgNC4gRW5zdXJlIHlvdSBjb3B5IG11bHRpcGxlIGxpbmVzIGlmIG5lZWRlZCBmb3IgdW5pcXVlbmVzc2AsXG4gICAgXS5qb2luKCdcXG4gICAnKTtcblxuICAgIHJldHVybiB7IGhpbnRzOiBzaW1pbGFySW5mbywgYWN0aW9uYWJsZTogYWN0aW9uIH07XG4gIH1cblxuICAvLyBObyBzaW1pbGFyIGxpbmVzIGZvdW5kIC0gc3VnZ2VzdCByZWFkaW5nIGVudGlyZSBmaWxlXG4gIGNvbnN0IHJlbGF0aXZlUGF0aCA9IHJlbGF0aXZlKHdvcmtpbmdEaXIsIGZpbGVQYXRoKTtcbiAgY29uc3QgZGlzcGxheVBhdGggPSByZWxhdGl2ZVBhdGggJiYgIXJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKCcuLicpID8gcmVsYXRpdmVQYXRoIDogZmlsZVBhdGg7XG4gIGNvbnN0IGFjdGlvbiA9IFtcbiAgICBgMS4gVXNlIFJlYWQgdG9vbCB0byB2aWV3IHRoZSBlbnRpcmUgZmlsZTogJHtkaXNwbGF5UGF0aH1gLFxuICAgIGAyLiBMb2NhdGUgdGhlIHRleHQgeW91IHdhbnQgdG8gY2hhbmdlYCxcbiAgICBgMy4gQ29weSB0aGUgRVhBQ1QgdGV4dCBpbmNsdWRpbmcgd2hpdGVzcGFjZWAsXG4gICAgYDQuIFBhc3RlIGl0IGFzIG9sZF9zdHJpbmcgaW4geW91ciBFZGl0IGNhbGxgLFxuICBdLmpvaW4oJ1xcbiAgICcpO1xuXG4gIHJldHVybiB7IGhpbnRzOiBzaW1pbGFySW5mbywgYWN0aW9uYWJsZTogYWN0aW9uIH07XG59XG5cbi8qKlxuICogRmluZCBsaW5lcyBpbiB0aGUgZmlsZSB0aGF0IGFyZSBzaW1pbGFyIHRvIHRoZSBzZWFyY2ggdGV4dC5cbiAqIEVuaGFuY2VkIHdpdGggd2hpdGVzcGFjZSBkZXRlY3Rpb24gYW5kIGF1dG8tY29ycmVjdGlvbiBzdWdnZXN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZmluZFNpbWlsYXJMaW5lcyhjb250ZW50OiBzdHJpbmcsIHNlYXJjaEZpcnN0TGluZTogc3RyaW5nLCBfZmlsZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICghc2VhcmNoRmlyc3RMaW5lLnRyaW0oKSkge1xuICAgIHJldHVybiAnVGhlIHNlYXJjaCBzdHJpbmcgc3RhcnRzIHdpdGggYW4gZW1wdHkgbGluZS4nO1xuICB9XG5cbiAgY29uc3QgbGluZXMgPSBjb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgY29uc3Qgc2VhcmNoTm9ybWFsaXplZCA9IHNlYXJjaEZpcnN0TGluZS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgbWF0Y2hlczogQXJyYXk8eyBsaW5lTnVtOiBudW1iZXI7IGxpbmU6IHN0cmluZzsgc2ltaWxhcml0eTogbnVtYmVyOyBpc3N1ZT86IHN0cmluZyB9PiA9IFtdO1xuXG4gIC8vIEZpbmQgbGluZXMgdGhhdCBjb250YWluIGtleSB3b3JkcyBmcm9tIHRoZSBzZWFyY2hcbiAgY29uc3Qgc2VhcmNoV29yZHMgPSBzZWFyY2hOb3JtYWxpemVkLnNwbGl0KC9cXHMrLykuZmlsdGVyKCh3KSA9PiB3Lmxlbmd0aCA+IDIpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaW5lID0gbGluZXNbaV0gfHwgJyc7XG4gICAgY29uc3QgbGluZU5vcm1hbGl6ZWQgPSBsaW5lLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gQ2hlY2sgZm9yIGV4YWN0IG1hdGNoIHdpdGggZGlmZmVyZW50IHdoaXRlc3BhY2VcbiAgICBpZiAobGluZU5vcm1hbGl6ZWQgPT09IHNlYXJjaE5vcm1hbGl6ZWQgJiYgbGluZSAhPT0gc2VhcmNoRmlyc3RMaW5lKSB7XG4gICAgICBjb25zdCBoYXNUYWJzID0gbGluZS5pbmNsdWRlcygnXFx0JykgIT09IHNlYXJjaEZpcnN0TGluZS5pbmNsdWRlcygnXFx0Jyk7XG4gICAgICBjb25zdCBsZWFkaW5nRGlmZiA9IGxpbmUubWF0Y2goL15cXHMqLyk/LlswXT8ubGVuZ3RoICE9PSBzZWFyY2hGaXJzdExpbmUubWF0Y2goL15cXHMqLyk/LlswXT8ubGVuZ3RoO1xuICAgICAgY29uc3QgaXNzdWUgPSBoYXNUYWJzID8gJ3RhYnMgdnMgc3BhY2VzJyA6IGxlYWRpbmdEaWZmID8gJ2RpZmZlcmVudCBpbmRlbnRhdGlvbicgOiAnd2hpdGVzcGFjZSBkaWZmZXJlbmNlJztcbiAgICAgIG1hdGNoZXMucHVzaCh7IGxpbmVOdW06IGkgKyAxLCBsaW5lLCBzaW1pbGFyaXR5OiAwLjk5LCBpc3N1ZSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBwYXJ0aWFsIG1hdGNoIChjb250YWlucyBzaWduaWZpY2FudCBwb3J0aW9uIG9mIHRoZSBzZWFyY2gpXG4gICAgaWYgKGxpbmVOb3JtYWxpemVkLmluY2x1ZGVzKHNlYXJjaE5vcm1hbGl6ZWQuc3Vic3RyaW5nKDAsIDIwKSkpIHtcbiAgICAgIG1hdGNoZXMucHVzaCh7IGxpbmVOdW06IGkgKyAxLCBsaW5lLCBzaW1pbGFyaXR5OiAxLjAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3Igd29yZCBvdmVybGFwXG4gICAgaWYgKHNlYXJjaFdvcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG1hdGNoaW5nV29yZHMgPSBzZWFyY2hXb3Jkcy5maWx0ZXIoKHcpID0+IGxpbmVOb3JtYWxpemVkLmluY2x1ZGVzKHcpKTtcbiAgICAgIGNvbnN0IHNpbWlsYXJpdHkgPSBtYXRjaGluZ1dvcmRzLmxlbmd0aCAvIHNlYXJjaFdvcmRzLmxlbmd0aDtcbiAgICAgIGlmIChzaW1pbGFyaXR5ID49IDAuNSkge1xuICAgICAgICBtYXRjaGVzLnB1c2goeyBsaW5lTnVtOiBpICsgMSwgbGluZSwgc2ltaWxhcml0eSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ05vIHNpbWlsYXIgbGluZXMgZm91bmQuIFRoZSB0ZXh0IG1heSBub3QgZXhpc3QgaW4gdGhpcyBmaWxlLic7XG4gIH1cblxuICAvLyBTb3J0IGJ5IHNpbWlsYXJpdHkgYW5kIHRha2UgdG9wIDNcbiAgbWF0Y2hlcy5zb3J0KChhLCBiKSA9PiBiLnNpbWlsYXJpdHkgLSBhLnNpbWlsYXJpdHkpO1xuICBjb25zdCB0b3BNYXRjaGVzID0gbWF0Y2hlcy5zbGljZSgwLCAzKTtcblxuICBjb25zdCBzdWdnZXN0aW9ucyA9IHRvcE1hdGNoZXMubWFwKChtKSA9PiB7XG4gICAgY29uc3QgdHJ1bmNhdGVkID0gbS5saW5lLmxlbmd0aCA+IDgwID8gYCR7bS5saW5lLnN1YnN0cmluZygwLCA3NykgIH0uLi5gIDogbS5saW5lO1xuICAgIGNvbnN0IGlzc3VlTm90ZSA9IG0uaXNzdWUgPyBgICgke20uaXNzdWV9KWAgOiAnJztcbiAgICByZXR1cm4gYCAgTGluZSAke20ubGluZU51bX0ke2lzc3VlTm90ZX06ICR7SlNPTi5zdHJpbmdpZnkodHJ1bmNhdGVkKX1gO1xuICB9KTtcblxuICAvLyBBZGQgYXV0by1jb3JyZWN0aW9uIGhpbnQgZm9yIHdoaXRlc3BhY2UgaXNzdWVzXG4gIGNvbnN0IHdoaXRlc3BhY2VNYXRjaCA9IHRvcE1hdGNoZXMuZmluZCgobSkgPT4gbS5pc3N1ZSk7XG4gIGlmICh3aGl0ZXNwYWNlTWF0Y2gpIHtcbiAgICByZXR1cm4gYFNpbWlsYXIgbGluZXMgZm91bmQgKHBvc3NpYmxlIHdoaXRlc3BhY2UgbWlzbWF0Y2gpOlxcbiR7c3VnZ2VzdGlvbnMuam9pbignXFxuJyl9XFxuXFxuQ29weSB0aGUgZXhhY3QgdGV4dCBmcm9tIFJlYWQgb3V0cHV0IGluY2x1ZGluZyBpbmRlbnRhdGlvbi5gO1xuICB9XG5cbiAgcmV0dXJuIGBTaW1pbGFyIGxpbmVzIGZvdW5kOlxcbiR7c3VnZ2VzdGlvbnMuam9pbignXFxuJyl9YDtcbn1cblxuLyoqXG4gKiBCdWlsZCBBSS1zcGVjaWZpYyByZWNvdmVyeSBndWlkYW5jZSBiYXNlZCBvbiB0aGUgZmFpbHVyZSBwYXR0ZXJuLlxuICogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIEFJIGZsb3cgZGVzaWduIHByaW5jaXBsZXMgZm9yIHNlbGYtY29ycmVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gYnVpbGRBSVJlY292ZXJ5R3VpZGFuY2Uoc2VhcmNoVGV4dDogc3RyaW5nLCBmaWxlQ29udGVudDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgZ3VpZGFuY2U6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gQW5hbHl6ZSB0aGUgZmFpbHVyZSBwYXR0ZXJuXG4gIGNvbnN0IGhhc011bHRpcGxlTGluZXMgPSBzZWFyY2hUZXh0LmluY2x1ZGVzKCdcXG4nKTtcbiAgY29uc3QgaGFzTGVhZGluZ1doaXRlc3BhY2UgPSAvXlxccy8udGVzdChzZWFyY2hUZXh0KTtcbiAgY29uc3Qgc2VhcmNoTGVuID0gc2VhcmNoVGV4dC5sZW5ndGg7XG4gIGNvbnN0IGZpbGVMZW4gPSBmaWxlQ29udGVudC5sZW5ndGg7XG5cbiAgLy8gUEFUVEVSTjogU2luZ2xlIGxpbmUgc2VhcmNoIGluIG11bHRpLWxpbmUgZmlsZVxuICBpZiAoIWhhc011bHRpcGxlTGluZXMgJiYgZmlsZUxlbiA+IDEwMDApIHtcbiAgICBndWlkYW5jZS5wdXNoKFxuICAgICAgJ+KAoiBQQVRURVJOIERFVEVDVEVEOiBTaW5nbGUtbGluZSBzZWFyY2ggaW4gbGFyZ2UgZmlsZScsXG4gICAgICAnICDihpIgSW5jbHVkZSAyLTMgc3Vycm91bmRpbmcgbGluZXMgZm9yIHVuaXF1ZW5lc3MnLFxuICAgICAgJyAg4oaSIFVzZSBSZWFkIHRvb2wgd2l0aCBzcGVjaWZpYyBsaW5lIG9mZnNldCB0byBnZXQgZXhhY3QgY29udGV4dCdcbiAgICApO1xuICB9XG5cbiAgLy8gUEFUVEVSTjogTWlzc2luZyBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgaWYgKCFoYXNMZWFkaW5nV2hpdGVzcGFjZSAmJiBmaWxlQ29udGVudC5pbmNsdWRlcygnICAnKSkge1xuICAgIGd1aWRhbmNlLnB1c2goXG4gICAgICAn4oCiIFBBVFRFUk4gREVURUNURUQ6IFNlYXJjaCB0ZXh0IG1heSBiZSBtaXNzaW5nIGluZGVudGF0aW9uJyxcbiAgICAgICcgIOKGkiBGaWxlIHVzZXMgaW5kZW50YXRpb24sIGJ1dCBvbGRfc3RyaW5nIHN0YXJ0cyB3aXRob3V0IHdoaXRlc3BhY2UnLFxuICAgICAgJyAg4oaSIENvcHkgZXhhY3QgdGV4dCBmcm9tIFJlYWQgb3V0cHV0IGluY2x1ZGluZyBsZWFkaW5nIHNwYWNlcy90YWJzJ1xuICAgICk7XG4gIH1cblxuICAvLyBQQVRURVJOOiBWZXJ5IHNob3J0IHNlYXJjaFxuICBpZiAoc2VhcmNoTGVuIDwgMzApIHtcbiAgICBndWlkYW5jZS5wdXNoKFxuICAgICAgJ+KAoiBQQVRURVJOIERFVEVDVEVEOiBTZWFyY2ggdGV4dCBpcyB2ZXJ5IHNob3J0ICg8MzAgY2hhcnMpJyxcbiAgICAgICcgIOKGkiBTaG9ydCBzdHJpbmdzIGFyZSBwcm9uZSB0byBmYWxzZSBuZWdhdGl2ZXMgZHVlIHRvIHdoaXRlc3BhY2UnLFxuICAgICAgJyAg4oaSIEluY2x1ZGUgbW9yZSBjb250ZXh0OiBmdW5jdGlvbiBib2R5LCBzdXJyb3VuZGluZyBzdGF0ZW1lbnRzJ1xuICAgICk7XG4gIH1cblxuICAvLyBQQVRURVJOOiBQb3RlbnRpYWwgZXNjYXBlIHNlcXVlbmNlIGlzc3Vlc1xuICBpZiAoc2VhcmNoVGV4dC5pbmNsdWRlcygnXFxcXG4nKSB8fCBzZWFyY2hUZXh0LmluY2x1ZGVzKCdcXFxcdCcpKSB7XG4gICAgZ3VpZGFuY2UucHVzaChcbiAgICAgICfigKIgUEFUVEVSTiBERVRFQ1RFRDogRXNjYXBlZCBjaGFyYWN0ZXJzIGluIHNlYXJjaCB0ZXh0JyxcbiAgICAgICcgIOKGkiBvbGRfc3RyaW5nIGNvbnRhaW5zIFxcXFxuIG9yIFxcXFx0IGFzIGxpdGVyYWwgc3RyaW5ncycsXG4gICAgICAnICDihpIgVXNlIGFjdHVhbCBuZXdsaW5lcy90YWJzLCBub3QgZXNjYXBlZCB2ZXJzaW9ucydcbiAgICApO1xuICB9XG5cbiAgLy8gUEFUVEVSTjogRnVuY3Rpb24vY2xhc3MgZGVmaW5pdGlvblxuICBpZiAoL14oZnVuY3Rpb258Y2xhc3N8ZGVmIHxjb25zdCB8bGV0IHx2YXIgfGV4cG9ydCApLy50ZXN0KHNlYXJjaFRleHQudHJpbSgpKSkge1xuICAgIGd1aWRhbmNlLnB1c2goXG4gICAgICAn4oCiIFBBVFRFUk4gREVURUNURUQ6IEZ1bmN0aW9uL2NsYXNzIGRlZmluaXRpb24gc2VhcmNoJyxcbiAgICAgICcgIOKGkiBEZWZpbml0aW9ucyBvZnRlbiBoYXZlIGNvbXBsZXggaW5kZW50YXRpb24nLFxuICAgICAgJyAg4oaSIFJlYWQgdGhlIGV4YWN0IGRlZmluaXRpb24gaW5jbHVkaW5nIGFsbCBkZWNvcmF0b3JzL2NvbW1lbnRzIGFib3ZlJ1xuICAgICk7XG4gIH1cblxuICAvLyBEZWZhdWx0IGd1aWRhbmNlIGlmIG5vIHNwZWNpZmljIHBhdHRlcm4gZGV0ZWN0ZWRcbiAgaWYgKGd1aWRhbmNlLmxlbmd0aCA9PT0gMCkge1xuICAgIGd1aWRhbmNlLnB1c2goXG4gICAgICAn4oCiIEdFTkVSQUwgR1VJREFOQ0U6JyxcbiAgICAgICcgIDEuIFVzZSBSZWFkIHRvb2wgdG8gdmlldyBmaWxlIGFyb3VuZCBleHBlY3RlZCBsb2NhdGlvbicsXG4gICAgICAnICAyLiBDb3B5IGV4YWN0IHRleHQgZnJvbSBSZWFkIG91dHB1dCAoaW5jbHVkaW5nIGFsbCB3aGl0ZXNwYWNlKScsXG4gICAgICAnICAzLiBWZXJpZnkgdGhlIHRleHQgZXhpc3RzIGluIGZpbGUgYmVmb3JlIEVkaXQgY2FsbCcsXG4gICAgICAnICA0LiBJbmNsdWRlIG1vcmUgY29udGV4dCBsaW5lcyBpZiB0ZXh0IGFwcGVhcnMgbXVsdGlwbGUgdGltZXMnXG4gICAgKTtcbiAgfVxuXG4gIC8vIEFsd2F5cyBhZGQgdGhlIGNyaXRpY2FsIHJlbWluZGVyXG4gIGd1aWRhbmNlLnB1c2goXG4gICAgJycsXG4gICAgJ0NSSVRJQ0FMOiBBbHdheXMgUmVhZCDihpIgQ29weSDihpIgRWRpdC4gTmV2ZXIgZ3Vlc3MgZmlsZSBjb250ZW50LidcbiAgKTtcblxuICByZXR1cm4gZ3VpZGFuY2Uuam9pbignXFxuJyk7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxJQUFBQSxT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