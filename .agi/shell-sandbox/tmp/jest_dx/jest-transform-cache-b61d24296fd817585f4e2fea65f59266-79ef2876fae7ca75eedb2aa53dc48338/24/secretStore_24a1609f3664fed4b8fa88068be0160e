c8e228ff99d42c0275100705b4fdab33
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MissingSecretError = void 0;
exports.ensureSecretForProvider = ensureSecretForProvider;
exports.getSecretDefinition = getSecretDefinition;
exports.getSecretDefinitionForProvider = getSecretDefinitionForProvider;
exports.getSecretValue = getSecretValue;
exports.listSecretDefinitions = listSecretDefinitions;
exports.loadAllSecrets = loadAllSecrets;
exports.maskSecret = maskSecret;
exports.safeErrorMessage = safeErrorMessage;
exports.sanitizeError = sanitizeError;
exports.sanitizeErrorMessage = sanitizeErrorMessage;
exports.setSecretValue = setSecretValue;
var _nodeFs = require("node:fs");
var _nodeOs = require("node:os");
var _nodePath = require("node:path");
const SECRET_DEFINITIONS = [{
  id: 'OPENAI_API_KEY',
  label: 'OpenAI API Key',
  description: 'Required to run OpenAI GPT and Erosolar Code models.',
  envVar: 'OPENAI_API_KEY',
  providers: ['openai']
}, {
  id: 'ANTHROPIC_API_KEY',
  label: 'Anthropic API Key',
  description: 'Required to run Anthropic Sonnet, Opus, or Haiku models.',
  envVar: 'ANTHROPIC_API_KEY',
  providers: ['anthropic']
}, {
  id: 'DEEPSEEK_API_KEY',
  label: 'DeepSeek API Key',
  description: 'Required to run DeepSeek Reasoner or Chat models.',
  envVar: 'DEEPSEEK_API_KEY',
  providers: ['deepseek']
}, {
  id: 'XAI_API_KEY',
  label: 'xAI API Key',
  description: 'Required to run Grok models from xAI.',
  envVar: 'XAI_API_KEY',
  providers: ['xai']
}, {
  id: 'GEMINI_API_KEY',
  label: 'Google Gemini API Key',
  description: 'Required to run Gemini 2.5 Pro or Flash models.',
  envVar: 'GEMINI_API_KEY',
  providers: ['google']
}, {
  id: 'BRAVE_SEARCH_API_KEY',
  label: 'Brave Search API Key',
  description: 'Optional: unlock WebSearch using the Brave Search API.',
  envVar: 'BRAVE_SEARCH_API_KEY',
  providers: []
}, {
  id: 'SERPAPI_API_KEY',
  label: 'SerpAPI Key',
  description: 'Optional: fallback WebSearch provider via SerpAPI.',
  envVar: 'SERPAPI_API_KEY',
  providers: []
}, {
  id: 'TAVILY_API_KEY',
  label: 'Tavily API Key',
  description: 'Recommended: Primary WebSearch and WebExtract provider. Get yours at https://tavily.com',
  envVar: 'TAVILY_API_KEY',
  providers: []
}, {
  id: 'SMTP_USER',
  label: 'Email Address',
  description: 'Your email address for sending emails (e.g., you@gmail.com).',
  envVar: 'SMTP_USER',
  providers: []
}, {
  id: 'SMTP_PASSWORD',
  label: 'Email App Password',
  description: 'App password for your email (NOT your regular password). For Gmail: https://myaccount.google.com/apppasswords',
  envVar: 'SMTP_PASSWORD',
  providers: []
}, {
  id: 'SMTP_PROVIDER',
  label: 'Email Provider',
  description: 'Email provider: gmail, outlook, yahoo, icloud, zoho (default: gmail).',
  envVar: 'SMTP_PROVIDER',
  providers: []
}, {
  id: 'SMTP_FROM_NAME',
  label: 'Email Display Name',
  description: 'Optional: Display name shown in sent emails (e.g., "John Doe").',
  envVar: 'SMTP_FROM_NAME',
  providers: []
}, {
  id: 'SMTP_HOST',
  label: 'Custom SMTP Host',
  description: 'Optional: Custom SMTP server hostname (only for non-standard providers).',
  envVar: 'SMTP_HOST',
  providers: []
}, {
  id: 'SMTP_PORT',
  label: 'Custom SMTP Port',
  description: 'Optional: Custom SMTP port (only for non-standard providers, default: 587).',
  envVar: 'SMTP_PORT',
  providers: []
}];
const envErosolarHome = process.env['EROSOLAR_HOME'];
const SECRET_DIR = envErosolarHome ? (0, _nodePath.resolve)(envErosolarHome) : (0, _nodePath.join)((0, _nodeOs.homedir)(), '.agi');
const SECRET_FILE = (0, _nodePath.join)(SECRET_DIR, 'secrets.json');
class MissingSecretError extends Error {
  constructor(secret) {
    super(`${secret.label} is not configured.`);
    this.secret = secret;
    this.name = 'MissingSecretError';
  }
}
exports.MissingSecretError = MissingSecretError;
function listSecretDefinitions() {
  return [...SECRET_DEFINITIONS];
}
function getSecretDefinition(id) {
  return SECRET_DEFINITIONS.find(entry => entry.id === id) ?? null;
}
function getSecretValue(id) {
  const envValue = sanitize(process.env[id]);
  if (envValue) {
    return envValue;
  }
  const store = readSecretStore();
  const storedValue = sanitize(store[id]);
  if (!storedValue) {
    return null;
  }
  process.env[id] = storedValue;
  return storedValue;
}

/**
 * Load all stored secrets into process.env at startup.
 * This ensures secrets are available before any provider checks.
 *
 * IMPORTANT: Stored secrets always take precedence over environment variables
 * for provider API keys. This ensures keys set via /secrets are used even if
 * the user has old/stale keys exported in their shell environment.
 */
function loadAllSecrets() {
  const store = readSecretStore();
  for (const definition of SECRET_DEFINITIONS) {
    const storedValue = sanitize(store[definition.id]);
    if (storedValue) {
      // Always use stored value for API keys to ensure /secrets takes precedence
      // over potentially stale environment variables
      process.env[definition.id] = storedValue;
    }
  }

  // Sync GEMINI_API_KEY and GOOGLE_API_KEY for Google SDK compatibility
  // The Google SDK checks both vars and warns if both are set
  // We standardize on GEMINI_API_KEY as the canonical key
  syncGoogleApiKeys();
}

/**
 * Sync GEMINI_API_KEY and GOOGLE_API_KEY environment variables.
 * The Google SDK prefers GOOGLE_API_KEY if both are set, but we use GEMINI_API_KEY
 * as the canonical stored key. This function ensures consistency.
 */
function syncGoogleApiKeys() {
  const geminiKey = process.env['GEMINI_API_KEY'];
  const googleKey = process.env['GOOGLE_API_KEY'];
  if (geminiKey && !googleKey) {
    // Only GEMINI_API_KEY set - also set GOOGLE_API_KEY to avoid SDK confusion
    process.env['GOOGLE_API_KEY'] = geminiKey;
  } else if (googleKey && !geminiKey) {
    // Only GOOGLE_API_KEY set (from env export) - copy to GEMINI_API_KEY
    process.env['GEMINI_API_KEY'] = googleKey;
  } else if (geminiKey && googleKey && geminiKey !== googleKey) {
    // Both set with different values - prefer GEMINI_API_KEY (the stored one)
    // and sync GOOGLE_API_KEY to match
    process.env['GOOGLE_API_KEY'] = geminiKey;
  }
  // If both are set and equal, no action needed
}
function setSecretValue(id, rawValue) {
  const value = sanitize(rawValue);
  if (!value) {
    throw new Error('Secret value cannot be blank.');
  }
  const store = readSecretStore();
  store[id] = value;
  writeSecretStore(store);
  process.env[id] = value;

  // If setting GEMINI_API_KEY, also sync GOOGLE_API_KEY for SDK compatibility
  if (id === 'GEMINI_API_KEY') {
    process.env['GOOGLE_API_KEY'] = value;
  }
}
function maskSecret(value) {
  if (!value) {
    return '';
  }
  if (value.length <= 4) {
    return '*'.repeat(value.length);
  }
  const suffix = value.slice(-4);
  const prefix = '*'.repeat(Math.max(0, value.length - 4));
  return `${prefix}${suffix}`;
}
function ensureSecretForProvider(provider) {
  const definition = findDefinitionForProvider(provider);
  const value = getSecretValue(definition.id);
  if (!value) {
    throw new MissingSecretError(definition);
  }
  process.env[definition.envVar] = value;
  return value;
}
function getSecretDefinitionForProvider(provider) {
  return SECRET_DEFINITIONS.find(entry => entry.providers.includes(provider)) ?? null;
}
function readSecretStore() {
  if (!(0, _nodeFs.existsSync)(SECRET_FILE)) {
    return {};
  }
  try {
    const content = (0, _nodeFs.readFileSync)(SECRET_FILE, 'utf8');
    const parsed = JSON.parse(content);
    if (parsed && typeof parsed === 'object') {
      return parsed;
    }
  } catch {
    return {};
  }
  return {};
}
function writeSecretStore(store) {
  const directory = (0, _nodePath.dirname)(SECRET_FILE);
  (0, _nodeFs.mkdirSync)(directory, {
    recursive: true
  });
  const payload = JSON.stringify(store, null, 2);
  (0, _nodeFs.writeFileSync)(SECRET_FILE, `${payload}
`);
}
function findDefinitionForProvider(provider) {
  const definition = getSecretDefinitionForProvider(provider);
  if (!definition) {
    throw new Error(`No secret configuration for provider "${provider}".`);
  }
  return definition;
}
function sanitize(value) {
  if (typeof value !== 'string') {
    return null;
  }
  const trimmed = value.trim();
  return trimmed.length ? trimmed : null;
}

// ============================================================================
// Secret Sanitization for Error Messages
// ============================================================================

/**
 * Known API key patterns to detect and sanitize in error messages.
 * These patterns match common API key formats from various providers.
 */
const API_KEY_PATTERNS = [
// Anthropic API keys: sk-ant-api03-...
/sk-ant-api\d{2}-[A-Za-z0-9_-]{20,}/g,
// OpenAI API keys: sk-proj-... or sk-...
/sk-(?:proj-)?[A-Za-z0-9_-]{20,}/g,
// Generic Bearer tokens in headers
/Bearer\s+[A-Za-z0-9_.-]{20,}/gi,
// x-api-key header values
/x-api-key['":\s]+[A-Za-z0-9_.-]{20,}/gi,
// API keys in URLs (key=value pattern)
/[?&](?:key|api_key|apiKey|api-key|token|access_token)=([A-Za-z0-9_.-]{16,})/gi,
// DeepSeek keys
/sk-[a-f0-9]{32,}/gi,
// xAI/Grok keys
/xai-[A-Za-z0-9_-]{20,}/gi,
// Google/Gemini API keys (AIza...)
/AIza[A-Za-z0-9_-]{30,}/g,
// Generic long alphanumeric tokens that look like API keys
/(?:api[_-]?key|token|secret|password|credential)['"]?\s*[:=]\s*['"]?([A-Za-z0-9_.-]{20,})['"]?/gi];

/**
 * Sanitize error messages to remove potential API keys and secrets.
 * This prevents accidental token leakage in logs, error reports, and console output.
 *
 * @param message - The error message or string to sanitize
 * @returns The sanitized string with secrets replaced by [REDACTED]
 */
function sanitizeErrorMessage(message) {
  if (!message || typeof message !== 'string') {
    return message;
  }
  let sanitized = message;

  // Apply all API key patterns
  for (const pattern of API_KEY_PATTERNS) {
    // Reset lastIndex for global patterns
    pattern.lastIndex = 0;
    sanitized = sanitized.replace(pattern, match => {
      // For patterns with capture groups, try to preserve context
      if (match.includes('=') || match.includes(':')) {
        const separator = match.includes('=') ? '=' : ':';
        const parts = match.split(separator);
        if (parts.length === 2) {
          return `${parts[0]}${separator}[REDACTED]`;
        }
      }
      return '[REDACTED]';
    });
  }

  // Additionally sanitize any env var values that are currently loaded
  sanitized = sanitizeAgainstLoadedSecrets(sanitized);
  return sanitized;
}

/**
 * Sanitize a string against currently loaded secret values.
 * This catches any secrets that might not match the pattern-based detection.
 */
function sanitizeAgainstLoadedSecrets(message) {
  const secretNames = ['OPENAI_API_KEY', 'ANTHROPIC_API_KEY', 'DEEPSEEK_API_KEY', 'XAI_API_KEY', 'GEMINI_API_KEY', 'BRAVE_SEARCH_API_KEY', 'SERPAPI_API_KEY', 'TAVILY_API_KEY', 'SMTP_PASSWORD'];
  let sanitized = message;
  for (const name of secretNames) {
    const value = process.env[name];
    if (value && value.length >= 8) {
      // Only sanitize if the value appears in the message
      // Use a case-sensitive exact match to avoid false positives
      if (sanitized.includes(value)) {
        sanitized = sanitized.split(value).join('[REDACTED]');
      }
    }
  }
  return sanitized;
}

/**
 * Sanitize an Error object's message and stack trace.
 * Returns a new error message string with secrets removed.
 */
function sanitizeError(error) {
  const message = sanitizeErrorMessage(error.message);
  const stack = error.stack ? sanitizeErrorMessage(error.stack) : '';
  if (stack && stack !== message) {
    return `${message}\n${stack}`;
  }
  return message;
}

/**
 * Create a safe error message from an unknown error value.
 * Ensures no secrets are leaked regardless of error type.
 */
function safeErrorMessage(error) {
  if (error instanceof Error) {
    return sanitizeErrorMessage(error.message);
  }
  if (typeof error === 'string') {
    return sanitizeErrorMessage(error);
  }
  return 'Unknown error occurred';
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfbm9kZUZzIiwicmVxdWlyZSIsIl9ub2RlT3MiLCJfbm9kZVBhdGgiLCJTRUNSRVRfREVGSU5JVElPTlMiLCJpZCIsImxhYmVsIiwiZGVzY3JpcHRpb24iLCJlbnZWYXIiLCJwcm92aWRlcnMiLCJlbnZFcm9zb2xhckhvbWUiLCJwcm9jZXNzIiwiZW52IiwiU0VDUkVUX0RJUiIsInJlc29sdmUiLCJqb2luIiwiaG9tZWRpciIsIlNFQ1JFVF9GSUxFIiwiTWlzc2luZ1NlY3JldEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsInNlY3JldCIsIm5hbWUiLCJleHBvcnRzIiwibGlzdFNlY3JldERlZmluaXRpb25zIiwiZ2V0U2VjcmV0RGVmaW5pdGlvbiIsImZpbmQiLCJlbnRyeSIsImdldFNlY3JldFZhbHVlIiwiZW52VmFsdWUiLCJzYW5pdGl6ZSIsInN0b3JlIiwicmVhZFNlY3JldFN0b3JlIiwic3RvcmVkVmFsdWUiLCJsb2FkQWxsU2VjcmV0cyIsImRlZmluaXRpb24iLCJzeW5jR29vZ2xlQXBpS2V5cyIsImdlbWluaUtleSIsImdvb2dsZUtleSIsInNldFNlY3JldFZhbHVlIiwicmF3VmFsdWUiLCJ2YWx1ZSIsIndyaXRlU2VjcmV0U3RvcmUiLCJtYXNrU2VjcmV0IiwibGVuZ3RoIiwicmVwZWF0Iiwic3VmZml4Iiwic2xpY2UiLCJwcmVmaXgiLCJNYXRoIiwibWF4IiwiZW5zdXJlU2VjcmV0Rm9yUHJvdmlkZXIiLCJwcm92aWRlciIsImZpbmREZWZpbml0aW9uRm9yUHJvdmlkZXIiLCJnZXRTZWNyZXREZWZpbml0aW9uRm9yUHJvdmlkZXIiLCJpbmNsdWRlcyIsImV4aXN0c1N5bmMiLCJjb250ZW50IiwicmVhZEZpbGVTeW5jIiwicGFyc2VkIiwiSlNPTiIsInBhcnNlIiwiZGlyZWN0b3J5IiwiZGlybmFtZSIsIm1rZGlyU3luYyIsInJlY3Vyc2l2ZSIsInBheWxvYWQiLCJzdHJpbmdpZnkiLCJ3cml0ZUZpbGVTeW5jIiwidHJpbW1lZCIsInRyaW0iLCJBUElfS0VZX1BBVFRFUk5TIiwic2FuaXRpemVFcnJvck1lc3NhZ2UiLCJtZXNzYWdlIiwic2FuaXRpemVkIiwicGF0dGVybiIsImxhc3RJbmRleCIsInJlcGxhY2UiLCJtYXRjaCIsInNlcGFyYXRvciIsInBhcnRzIiwic3BsaXQiLCJzYW5pdGl6ZUFnYWluc3RMb2FkZWRTZWNyZXRzIiwic2VjcmV0TmFtZXMiLCJzYW5pdGl6ZUVycm9yIiwiZXJyb3IiLCJzdGFjayIsInNhZmVFcnJvck1lc3NhZ2UiXSwic291cmNlcyI6WyJzZWNyZXRTdG9yZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGlzdHNTeW5jLCBta2RpclN5bmMsIHJlYWRGaWxlU3luYywgd3JpdGVGaWxlU3luYyB9IGZyb20gJ25vZGU6ZnMnO1xuaW1wb3J0IHsgaG9tZWRpciB9IGZyb20gJ25vZGU6b3MnO1xuaW1wb3J0IHsgZGlybmFtZSwgam9pbiwgcmVzb2x2ZSB9IGZyb20gJ25vZGU6cGF0aCc7XG5pbXBvcnQgdHlwZSB7IFByb3ZpZGVySWQgfSBmcm9tICcuL3R5cGVzLmpzJztcblxuZXhwb3J0IHR5cGUgU2VjcmV0TmFtZSA9XG4gIHwgJ09QRU5BSV9BUElfS0VZJ1xuICB8ICdBTlRIUk9QSUNfQVBJX0tFWSdcbiAgfCAnREVFUFNFRUtfQVBJX0tFWSdcbiAgfCAnWEFJX0FQSV9LRVknXG4gIHwgJ0dFTUlOSV9BUElfS0VZJ1xuICB8ICdCUkFWRV9TRUFSQ0hfQVBJX0tFWSdcbiAgfCAnU0VSUEFQSV9BUElfS0VZJ1xuICB8ICdUQVZJTFlfQVBJX0tFWSdcbiAgfCAnU01UUF9VU0VSJ1xuICB8ICdTTVRQX1BBU1NXT1JEJ1xuICB8ICdTTVRQX1BST1ZJREVSJ1xuICB8ICdTTVRQX0ZST01fTkFNRSdcbiAgfCAnU01UUF9IT1NUJ1xuICB8ICdTTVRQX1BPUlQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlY3JldERlZmluaXRpb24ge1xuICBpZDogU2VjcmV0TmFtZTtcbiAgbGFiZWw6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgZW52VmFyOiBTZWNyZXROYW1lO1xuICBwcm92aWRlcnM6IFByb3ZpZGVySWRbXTtcbn1cblxuaW50ZXJmYWNlIFNlY3JldFN0b3JlRGF0YSB7XG4gIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZDtcbn1cblxuY29uc3QgU0VDUkVUX0RFRklOSVRJT05TOiBTZWNyZXREZWZpbml0aW9uW10gPSBbXG4gIHtcbiAgICBpZDogJ09QRU5BSV9BUElfS0VZJyxcbiAgICBsYWJlbDogJ09wZW5BSSBBUEkgS2V5JyxcbiAgICBkZXNjcmlwdGlvbjogJ1JlcXVpcmVkIHRvIHJ1biBPcGVuQUkgR1BUIGFuZCBFcm9zb2xhciBDb2RlIG1vZGVscy4nLFxuICAgIGVudlZhcjogJ09QRU5BSV9BUElfS0VZJyxcbiAgICBwcm92aWRlcnM6IFsnb3BlbmFpJ10sXG4gIH0sXG4gIHtcbiAgICBpZDogJ0FOVEhST1BJQ19BUElfS0VZJyxcbiAgICBsYWJlbDogJ0FudGhyb3BpYyBBUEkgS2V5JyxcbiAgICBkZXNjcmlwdGlvbjogJ1JlcXVpcmVkIHRvIHJ1biBBbnRocm9waWMgU29ubmV0LCBPcHVzLCBvciBIYWlrdSBtb2RlbHMuJyxcbiAgICBlbnZWYXI6ICdBTlRIUk9QSUNfQVBJX0tFWScsXG4gICAgcHJvdmlkZXJzOiBbJ2FudGhyb3BpYyddLFxuICB9LFxuICB7XG4gICAgaWQ6ICdERUVQU0VFS19BUElfS0VZJyxcbiAgICBsYWJlbDogJ0RlZXBTZWVrIEFQSSBLZXknLFxuICAgIGRlc2NyaXB0aW9uOiAnUmVxdWlyZWQgdG8gcnVuIERlZXBTZWVrIFJlYXNvbmVyIG9yIENoYXQgbW9kZWxzLicsXG4gICAgZW52VmFyOiAnREVFUFNFRUtfQVBJX0tFWScsXG4gICAgcHJvdmlkZXJzOiBbJ2RlZXBzZWVrJ10sXG4gIH0sXG4gIHtcbiAgICBpZDogJ1hBSV9BUElfS0VZJyxcbiAgICBsYWJlbDogJ3hBSSBBUEkgS2V5JyxcbiAgICBkZXNjcmlwdGlvbjogJ1JlcXVpcmVkIHRvIHJ1biBHcm9rIG1vZGVscyBmcm9tIHhBSS4nLFxuICAgIGVudlZhcjogJ1hBSV9BUElfS0VZJyxcbiAgICBwcm92aWRlcnM6IFsneGFpJ10sXG4gIH0sXG4gIHtcbiAgICBpZDogJ0dFTUlOSV9BUElfS0VZJyxcbiAgICBsYWJlbDogJ0dvb2dsZSBHZW1pbmkgQVBJIEtleScsXG4gICAgZGVzY3JpcHRpb246ICdSZXF1aXJlZCB0byBydW4gR2VtaW5pIDIuNSBQcm8gb3IgRmxhc2ggbW9kZWxzLicsXG4gICAgZW52VmFyOiAnR0VNSU5JX0FQSV9LRVknLFxuICAgIHByb3ZpZGVyczogWydnb29nbGUnXSxcbiAgfSxcbiAge1xuICAgIGlkOiAnQlJBVkVfU0VBUkNIX0FQSV9LRVknLFxuICAgIGxhYmVsOiAnQnJhdmUgU2VhcmNoIEFQSSBLZXknLFxuICAgIGRlc2NyaXB0aW9uOiAnT3B0aW9uYWw6IHVubG9jayBXZWJTZWFyY2ggdXNpbmcgdGhlIEJyYXZlIFNlYXJjaCBBUEkuJyxcbiAgICBlbnZWYXI6ICdCUkFWRV9TRUFSQ0hfQVBJX0tFWScsXG4gICAgcHJvdmlkZXJzOiBbXSxcbiAgfSxcbiAge1xuICAgIGlkOiAnU0VSUEFQSV9BUElfS0VZJyxcbiAgICBsYWJlbDogJ1NlcnBBUEkgS2V5JyxcbiAgICBkZXNjcmlwdGlvbjogJ09wdGlvbmFsOiBmYWxsYmFjayBXZWJTZWFyY2ggcHJvdmlkZXIgdmlhIFNlcnBBUEkuJyxcbiAgICBlbnZWYXI6ICdTRVJQQVBJX0FQSV9LRVknLFxuICAgIHByb3ZpZGVyczogW10sXG4gIH0sXG4gIHtcbiAgICBpZDogJ1RBVklMWV9BUElfS0VZJyxcbiAgICBsYWJlbDogJ1RhdmlseSBBUEkgS2V5JyxcbiAgICBkZXNjcmlwdGlvbjogJ1JlY29tbWVuZGVkOiBQcmltYXJ5IFdlYlNlYXJjaCBhbmQgV2ViRXh0cmFjdCBwcm92aWRlci4gR2V0IHlvdXJzIGF0IGh0dHBzOi8vdGF2aWx5LmNvbScsXG4gICAgZW52VmFyOiAnVEFWSUxZX0FQSV9LRVknLFxuICAgIHByb3ZpZGVyczogW10sXG4gIH0sXG4gIHtcbiAgICBpZDogJ1NNVFBfVVNFUicsXG4gICAgbGFiZWw6ICdFbWFpbCBBZGRyZXNzJyxcbiAgICBkZXNjcmlwdGlvbjogJ1lvdXIgZW1haWwgYWRkcmVzcyBmb3Igc2VuZGluZyBlbWFpbHMgKGUuZy4sIHlvdUBnbWFpbC5jb20pLicsXG4gICAgZW52VmFyOiAnU01UUF9VU0VSJyxcbiAgICBwcm92aWRlcnM6IFtdLFxuICB9LFxuICB7XG4gICAgaWQ6ICdTTVRQX1BBU1NXT1JEJyxcbiAgICBsYWJlbDogJ0VtYWlsIEFwcCBQYXNzd29yZCcsXG4gICAgZGVzY3JpcHRpb246ICdBcHAgcGFzc3dvcmQgZm9yIHlvdXIgZW1haWwgKE5PVCB5b3VyIHJlZ3VsYXIgcGFzc3dvcmQpLiBGb3IgR21haWw6IGh0dHBzOi8vbXlhY2NvdW50Lmdvb2dsZS5jb20vYXBwcGFzc3dvcmRzJyxcbiAgICBlbnZWYXI6ICdTTVRQX1BBU1NXT1JEJyxcbiAgICBwcm92aWRlcnM6IFtdLFxuICB9LFxuICB7XG4gICAgaWQ6ICdTTVRQX1BST1ZJREVSJyxcbiAgICBsYWJlbDogJ0VtYWlsIFByb3ZpZGVyJyxcbiAgICBkZXNjcmlwdGlvbjogJ0VtYWlsIHByb3ZpZGVyOiBnbWFpbCwgb3V0bG9vaywgeWFob28sIGljbG91ZCwgem9obyAoZGVmYXVsdDogZ21haWwpLicsXG4gICAgZW52VmFyOiAnU01UUF9QUk9WSURFUicsXG4gICAgcHJvdmlkZXJzOiBbXSxcbiAgfSxcbiAge1xuICAgIGlkOiAnU01UUF9GUk9NX05BTUUnLFxuICAgIGxhYmVsOiAnRW1haWwgRGlzcGxheSBOYW1lJyxcbiAgICBkZXNjcmlwdGlvbjogJ09wdGlvbmFsOiBEaXNwbGF5IG5hbWUgc2hvd24gaW4gc2VudCBlbWFpbHMgKGUuZy4sIFwiSm9obiBEb2VcIikuJyxcbiAgICBlbnZWYXI6ICdTTVRQX0ZST01fTkFNRScsXG4gICAgcHJvdmlkZXJzOiBbXSxcbiAgfSxcbiAge1xuICAgIGlkOiAnU01UUF9IT1NUJyxcbiAgICBsYWJlbDogJ0N1c3RvbSBTTVRQIEhvc3QnLFxuICAgIGRlc2NyaXB0aW9uOiAnT3B0aW9uYWw6IEN1c3RvbSBTTVRQIHNlcnZlciBob3N0bmFtZSAob25seSBmb3Igbm9uLXN0YW5kYXJkIHByb3ZpZGVycykuJyxcbiAgICBlbnZWYXI6ICdTTVRQX0hPU1QnLFxuICAgIHByb3ZpZGVyczogW10sXG4gIH0sXG4gIHtcbiAgICBpZDogJ1NNVFBfUE9SVCcsXG4gICAgbGFiZWw6ICdDdXN0b20gU01UUCBQb3J0JyxcbiAgICBkZXNjcmlwdGlvbjogJ09wdGlvbmFsOiBDdXN0b20gU01UUCBwb3J0IChvbmx5IGZvciBub24tc3RhbmRhcmQgcHJvdmlkZXJzLCBkZWZhdWx0OiA1ODcpLicsXG4gICAgZW52VmFyOiAnU01UUF9QT1JUJyxcbiAgICBwcm92aWRlcnM6IFtdLFxuICB9LFxuXTtcblxuY29uc3QgZW52RXJvc29sYXJIb21lID0gcHJvY2Vzcy5lbnZbJ0VST1NPTEFSX0hPTUUnXTtcbmNvbnN0IFNFQ1JFVF9ESVIgPSBlbnZFcm9zb2xhckhvbWUgPyByZXNvbHZlKGVudkVyb3NvbGFySG9tZSkgOiBqb2luKGhvbWVkaXIoKSwgJy5hZ2knKTtcbmNvbnN0IFNFQ1JFVF9GSUxFID0gam9pbihTRUNSRVRfRElSLCAnc2VjcmV0cy5qc29uJyk7XG5cbmV4cG9ydCBjbGFzcyBNaXNzaW5nU2VjcmV0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBzZWNyZXQ6IFNlY3JldERlZmluaXRpb24pIHtcbiAgICBzdXBlcihgJHtzZWNyZXQubGFiZWx9IGlzIG5vdCBjb25maWd1cmVkLmApO1xuICAgIHRoaXMubmFtZSA9ICdNaXNzaW5nU2VjcmV0RXJyb3InO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaXN0U2VjcmV0RGVmaW5pdGlvbnMoKTogU2VjcmV0RGVmaW5pdGlvbltdIHtcbiAgcmV0dXJuIFsuLi5TRUNSRVRfREVGSU5JVElPTlNdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VjcmV0RGVmaW5pdGlvbihpZDogU2VjcmV0TmFtZSk6IFNlY3JldERlZmluaXRpb24gfCBudWxsIHtcbiAgcmV0dXJuIFNFQ1JFVF9ERUZJTklUSU9OUy5maW5kKChlbnRyeSkgPT4gZW50cnkuaWQgPT09IGlkKSA/PyBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VjcmV0VmFsdWUoaWQ6IFNlY3JldE5hbWUpOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgZW52VmFsdWUgPSBzYW5pdGl6ZShwcm9jZXNzLmVudltpZF0pO1xuICBpZiAoZW52VmFsdWUpIHtcbiAgICByZXR1cm4gZW52VmFsdWU7XG4gIH1cblxuICBjb25zdCBzdG9yZSA9IHJlYWRTZWNyZXRTdG9yZSgpO1xuICBjb25zdCBzdG9yZWRWYWx1ZSA9IHNhbml0aXplKHN0b3JlW2lkXSk7XG4gIGlmICghc3RvcmVkVmFsdWUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHByb2Nlc3MuZW52W2lkXSA9IHN0b3JlZFZhbHVlO1xuICByZXR1cm4gc3RvcmVkVmFsdWU7XG59XG5cbi8qKlxuICogTG9hZCBhbGwgc3RvcmVkIHNlY3JldHMgaW50byBwcm9jZXNzLmVudiBhdCBzdGFydHVwLlxuICogVGhpcyBlbnN1cmVzIHNlY3JldHMgYXJlIGF2YWlsYWJsZSBiZWZvcmUgYW55IHByb3ZpZGVyIGNoZWNrcy5cbiAqXG4gKiBJTVBPUlRBTlQ6IFN0b3JlZCBzZWNyZXRzIGFsd2F5cyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAqIGZvciBwcm92aWRlciBBUEkga2V5cy4gVGhpcyBlbnN1cmVzIGtleXMgc2V0IHZpYSAvc2VjcmV0cyBhcmUgdXNlZCBldmVuIGlmXG4gKiB0aGUgdXNlciBoYXMgb2xkL3N0YWxlIGtleXMgZXhwb3J0ZWQgaW4gdGhlaXIgc2hlbGwgZW52aXJvbm1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkQWxsU2VjcmV0cygpOiB2b2lkIHtcbiAgY29uc3Qgc3RvcmUgPSByZWFkU2VjcmV0U3RvcmUoKTtcbiAgZm9yIChjb25zdCBkZWZpbml0aW9uIG9mIFNFQ1JFVF9ERUZJTklUSU9OUykge1xuICAgIGNvbnN0IHN0b3JlZFZhbHVlID0gc2FuaXRpemUoc3RvcmVbZGVmaW5pdGlvbi5pZF0pO1xuICAgIGlmIChzdG9yZWRWYWx1ZSkge1xuICAgICAgLy8gQWx3YXlzIHVzZSBzdG9yZWQgdmFsdWUgZm9yIEFQSSBrZXlzIHRvIGVuc3VyZSAvc2VjcmV0cyB0YWtlcyBwcmVjZWRlbmNlXG4gICAgICAvLyBvdmVyIHBvdGVudGlhbGx5IHN0YWxlIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgICAgcHJvY2Vzcy5lbnZbZGVmaW5pdGlvbi5pZF0gPSBzdG9yZWRWYWx1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBTeW5jIEdFTUlOSV9BUElfS0VZIGFuZCBHT09HTEVfQVBJX0tFWSBmb3IgR29vZ2xlIFNESyBjb21wYXRpYmlsaXR5XG4gIC8vIFRoZSBHb29nbGUgU0RLIGNoZWNrcyBib3RoIHZhcnMgYW5kIHdhcm5zIGlmIGJvdGggYXJlIHNldFxuICAvLyBXZSBzdGFuZGFyZGl6ZSBvbiBHRU1JTklfQVBJX0tFWSBhcyB0aGUgY2Fub25pY2FsIGtleVxuICBzeW5jR29vZ2xlQXBpS2V5cygpO1xufVxuXG4vKipcbiAqIFN5bmMgR0VNSU5JX0FQSV9LRVkgYW5kIEdPT0dMRV9BUElfS0VZIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqIFRoZSBHb29nbGUgU0RLIHByZWZlcnMgR09PR0xFX0FQSV9LRVkgaWYgYm90aCBhcmUgc2V0LCBidXQgd2UgdXNlIEdFTUlOSV9BUElfS0VZXG4gKiBhcyB0aGUgY2Fub25pY2FsIHN0b3JlZCBrZXkuIFRoaXMgZnVuY3Rpb24gZW5zdXJlcyBjb25zaXN0ZW5jeS5cbiAqL1xuZnVuY3Rpb24gc3luY0dvb2dsZUFwaUtleXMoKTogdm9pZCB7XG4gIGNvbnN0IGdlbWluaUtleSA9IHByb2Nlc3MuZW52WydHRU1JTklfQVBJX0tFWSddO1xuICBjb25zdCBnb29nbGVLZXkgPSBwcm9jZXNzLmVudlsnR09PR0xFX0FQSV9LRVknXTtcblxuICBpZiAoZ2VtaW5pS2V5ICYmICFnb29nbGVLZXkpIHtcbiAgICAvLyBPbmx5IEdFTUlOSV9BUElfS0VZIHNldCAtIGFsc28gc2V0IEdPT0dMRV9BUElfS0VZIHRvIGF2b2lkIFNESyBjb25mdXNpb25cbiAgICBwcm9jZXNzLmVudlsnR09PR0xFX0FQSV9LRVknXSA9IGdlbWluaUtleTtcbiAgfSBlbHNlIGlmIChnb29nbGVLZXkgJiYgIWdlbWluaUtleSkge1xuICAgIC8vIE9ubHkgR09PR0xFX0FQSV9LRVkgc2V0IChmcm9tIGVudiBleHBvcnQpIC0gY29weSB0byBHRU1JTklfQVBJX0tFWVxuICAgIHByb2Nlc3MuZW52WydHRU1JTklfQVBJX0tFWSddID0gZ29vZ2xlS2V5O1xuICB9IGVsc2UgaWYgKGdlbWluaUtleSAmJiBnb29nbGVLZXkgJiYgZ2VtaW5pS2V5ICE9PSBnb29nbGVLZXkpIHtcbiAgICAvLyBCb3RoIHNldCB3aXRoIGRpZmZlcmVudCB2YWx1ZXMgLSBwcmVmZXIgR0VNSU5JX0FQSV9LRVkgKHRoZSBzdG9yZWQgb25lKVxuICAgIC8vIGFuZCBzeW5jIEdPT0dMRV9BUElfS0VZIHRvIG1hdGNoXG4gICAgcHJvY2Vzcy5lbnZbJ0dPT0dMRV9BUElfS0VZJ10gPSBnZW1pbmlLZXk7XG4gIH1cbiAgLy8gSWYgYm90aCBhcmUgc2V0IGFuZCBlcXVhbCwgbm8gYWN0aW9uIG5lZWRlZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0U2VjcmV0VmFsdWUoaWQ6IFNlY3JldE5hbWUsIHJhd1ZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcbiAgY29uc3QgdmFsdWUgPSBzYW5pdGl6ZShyYXdWYWx1ZSk7XG4gIGlmICghdmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3JldCB2YWx1ZSBjYW5ub3QgYmUgYmxhbmsuJyk7XG4gIH1cblxuICBjb25zdCBzdG9yZSA9IHJlYWRTZWNyZXRTdG9yZSgpO1xuICBzdG9yZVtpZF0gPSB2YWx1ZTtcbiAgd3JpdGVTZWNyZXRTdG9yZShzdG9yZSk7XG4gIHByb2Nlc3MuZW52W2lkXSA9IHZhbHVlO1xuXG4gIC8vIElmIHNldHRpbmcgR0VNSU5JX0FQSV9LRVksIGFsc28gc3luYyBHT09HTEVfQVBJX0tFWSBmb3IgU0RLIGNvbXBhdGliaWxpdHlcbiAgaWYgKGlkID09PSAnR0VNSU5JX0FQSV9LRVknKSB7XG4gICAgcHJvY2Vzcy5lbnZbJ0dPT0dMRV9BUElfS0VZJ10gPSB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFza1NlY3JldCh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBpZiAodmFsdWUubGVuZ3RoIDw9IDQpIHtcbiAgICByZXR1cm4gJyonLnJlcGVhdCh2YWx1ZS5sZW5ndGgpO1xuICB9XG4gIGNvbnN0IHN1ZmZpeCA9IHZhbHVlLnNsaWNlKC00KTtcbiAgY29uc3QgcHJlZml4ID0gJyonLnJlcGVhdChNYXRoLm1heCgwLCB2YWx1ZS5sZW5ndGggLSA0KSk7XG4gIHJldHVybiBgJHtwcmVmaXh9JHtzdWZmaXh9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVNlY3JldEZvclByb3ZpZGVyKHByb3ZpZGVyOiBQcm92aWRlcklkKTogc3RyaW5nIHtcbiAgY29uc3QgZGVmaW5pdGlvbiA9IGZpbmREZWZpbml0aW9uRm9yUHJvdmlkZXIocHJvdmlkZXIpO1xuICBjb25zdCB2YWx1ZSA9IGdldFNlY3JldFZhbHVlKGRlZmluaXRpb24uaWQpO1xuICBpZiAoIXZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IE1pc3NpbmdTZWNyZXRFcnJvcihkZWZpbml0aW9uKTtcbiAgfVxuICBwcm9jZXNzLmVudltkZWZpbml0aW9uLmVudlZhcl0gPSB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VjcmV0RGVmaW5pdGlvbkZvclByb3ZpZGVyKHByb3ZpZGVyOiBQcm92aWRlcklkKTogU2VjcmV0RGVmaW5pdGlvbiB8IG51bGwge1xuICByZXR1cm4gU0VDUkVUX0RFRklOSVRJT05TLmZpbmQoKGVudHJ5KSA9PiBlbnRyeS5wcm92aWRlcnMuaW5jbHVkZXMocHJvdmlkZXIpKSA/PyBudWxsO1xufVxuXG5mdW5jdGlvbiByZWFkU2VjcmV0U3RvcmUoKTogU2VjcmV0U3RvcmVEYXRhIHtcbiAgaWYgKCFleGlzdHNTeW5jKFNFQ1JFVF9GSUxFKSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgY29udGVudCA9IHJlYWRGaWxlU3luYyhTRUNSRVRfRklMRSwgJ3V0ZjgnKTtcbiAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGNvbnRlbnQpO1xuICAgIGlmIChwYXJzZWQgJiYgdHlwZW9mIHBhcnNlZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBwYXJzZWQgYXMgU2VjcmV0U3RvcmVEYXRhO1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gd3JpdGVTZWNyZXRTdG9yZShzdG9yZTogU2VjcmV0U3RvcmVEYXRhKTogdm9pZCB7XG4gIGNvbnN0IGRpcmVjdG9yeSA9IGRpcm5hbWUoU0VDUkVUX0ZJTEUpO1xuICBta2RpclN5bmMoZGlyZWN0b3J5LCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgY29uc3QgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHN0b3JlLCBudWxsLCAyKTtcbiAgd3JpdGVGaWxlU3luYyhTRUNSRVRfRklMRSwgYCR7cGF5bG9hZH1cbmApO1xufVxuXG5mdW5jdGlvbiBmaW5kRGVmaW5pdGlvbkZvclByb3ZpZGVyKHByb3ZpZGVyOiBQcm92aWRlcklkKTogU2VjcmV0RGVmaW5pdGlvbiB7XG4gIGNvbnN0IGRlZmluaXRpb24gPSBnZXRTZWNyZXREZWZpbml0aW9uRm9yUHJvdmlkZXIocHJvdmlkZXIpO1xuICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHNlY3JldCBjb25maWd1cmF0aW9uIGZvciBwcm92aWRlciBcIiR7cHJvdmlkZXJ9XCIuYCk7XG4gIH1cbiAgcmV0dXJuIGRlZmluaXRpb247XG59XG5cbmZ1bmN0aW9uIHNhbml0aXplKHZhbHVlOiB1bmtub3duKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgdHJpbW1lZCA9IHZhbHVlLnRyaW0oKTtcbiAgcmV0dXJuIHRyaW1tZWQubGVuZ3RoID8gdHJpbW1lZCA6IG51bGw7XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFNlY3JldCBTYW5pdGl6YXRpb24gZm9yIEVycm9yIE1lc3NhZ2VzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogS25vd24gQVBJIGtleSBwYXR0ZXJucyB0byBkZXRlY3QgYW5kIHNhbml0aXplIGluIGVycm9yIG1lc3NhZ2VzLlxuICogVGhlc2UgcGF0dGVybnMgbWF0Y2ggY29tbW9uIEFQSSBrZXkgZm9ybWF0cyBmcm9tIHZhcmlvdXMgcHJvdmlkZXJzLlxuICovXG5jb25zdCBBUElfS0VZX1BBVFRFUk5TOiBSZWdFeHBbXSA9IFtcbiAgLy8gQW50aHJvcGljIEFQSSBrZXlzOiBzay1hbnQtYXBpMDMtLi4uXG4gIC9zay1hbnQtYXBpXFxkezJ9LVtBLVphLXowLTlfLV17MjAsfS9nLFxuICAvLyBPcGVuQUkgQVBJIGtleXM6IHNrLXByb2otLi4uIG9yIHNrLS4uLlxuICAvc2stKD86cHJvai0pP1tBLVphLXowLTlfLV17MjAsfS9nLFxuICAvLyBHZW5lcmljIEJlYXJlciB0b2tlbnMgaW4gaGVhZGVyc1xuICAvQmVhcmVyXFxzK1tBLVphLXowLTlfLi1dezIwLH0vZ2ksXG4gIC8vIHgtYXBpLWtleSBoZWFkZXIgdmFsdWVzXG4gIC94LWFwaS1rZXlbJ1wiOlxcc10rW0EtWmEtejAtOV8uLV17MjAsfS9naSxcbiAgLy8gQVBJIGtleXMgaW4gVVJMcyAoa2V5PXZhbHVlIHBhdHRlcm4pXG4gIC9bPyZdKD86a2V5fGFwaV9rZXl8YXBpS2V5fGFwaS1rZXl8dG9rZW58YWNjZXNzX3Rva2VuKT0oW0EtWmEtejAtOV8uLV17MTYsfSkvZ2ksXG4gIC8vIERlZXBTZWVrIGtleXNcbiAgL3NrLVthLWYwLTldezMyLH0vZ2ksXG4gIC8vIHhBSS9Hcm9rIGtleXNcbiAgL3hhaS1bQS1aYS16MC05Xy1dezIwLH0vZ2ksXG4gIC8vIEdvb2dsZS9HZW1pbmkgQVBJIGtleXMgKEFJemEuLi4pXG4gIC9BSXphW0EtWmEtejAtOV8tXXszMCx9L2csXG4gIC8vIEdlbmVyaWMgbG9uZyBhbHBoYW51bWVyaWMgdG9rZW5zIHRoYXQgbG9vayBsaWtlIEFQSSBrZXlzXG4gIC8oPzphcGlbXy1dP2tleXx0b2tlbnxzZWNyZXR8cGFzc3dvcmR8Y3JlZGVudGlhbClbJ1wiXT9cXHMqWzo9XVxccypbJ1wiXT8oW0EtWmEtejAtOV8uLV17MjAsfSlbJ1wiXT8vZ2ksXG5dO1xuXG4vKipcbiAqIFNhbml0aXplIGVycm9yIG1lc3NhZ2VzIHRvIHJlbW92ZSBwb3RlbnRpYWwgQVBJIGtleXMgYW5kIHNlY3JldHMuXG4gKiBUaGlzIHByZXZlbnRzIGFjY2lkZW50YWwgdG9rZW4gbGVha2FnZSBpbiBsb2dzLCBlcnJvciByZXBvcnRzLCBhbmQgY29uc29sZSBvdXRwdXQuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBzdHJpbmcgdG8gc2FuaXRpemVcbiAqIEByZXR1cm5zIFRoZSBzYW5pdGl6ZWQgc3RyaW5nIHdpdGggc2VjcmV0cyByZXBsYWNlZCBieSBbUkVEQUNURURdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZUVycm9yTWVzc2FnZShtZXNzYWdlOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoIW1lc3NhZ2UgfHwgdHlwZW9mIG1lc3NhZ2UgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH1cblxuICBsZXQgc2FuaXRpemVkID0gbWVzc2FnZTtcblxuICAvLyBBcHBseSBhbGwgQVBJIGtleSBwYXR0ZXJuc1xuICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgQVBJX0tFWV9QQVRURVJOUykge1xuICAgIC8vIFJlc2V0IGxhc3RJbmRleCBmb3IgZ2xvYmFsIHBhdHRlcm5zXG4gICAgcGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICAgIHNhbml0aXplZCA9IHNhbml0aXplZC5yZXBsYWNlKHBhdHRlcm4sIChtYXRjaCkgPT4ge1xuICAgICAgLy8gRm9yIHBhdHRlcm5zIHdpdGggY2FwdHVyZSBncm91cHMsIHRyeSB0byBwcmVzZXJ2ZSBjb250ZXh0XG4gICAgICBpZiAobWF0Y2guaW5jbHVkZXMoJz0nKSB8fCBtYXRjaC5pbmNsdWRlcygnOicpKSB7XG4gICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IG1hdGNoLmluY2x1ZGVzKCc9JykgPyAnPScgOiAnOic7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gbWF0Y2guc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHJldHVybiBgJHtwYXJ0c1swXX0ke3NlcGFyYXRvcn1bUkVEQUNURURdYDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICdbUkVEQUNURURdJztcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEFkZGl0aW9uYWxseSBzYW5pdGl6ZSBhbnkgZW52IHZhciB2YWx1ZXMgdGhhdCBhcmUgY3VycmVudGx5IGxvYWRlZFxuICBzYW5pdGl6ZWQgPSBzYW5pdGl6ZUFnYWluc3RMb2FkZWRTZWNyZXRzKHNhbml0aXplZCk7XG5cbiAgcmV0dXJuIHNhbml0aXplZDtcbn1cblxuLyoqXG4gKiBTYW5pdGl6ZSBhIHN0cmluZyBhZ2FpbnN0IGN1cnJlbnRseSBsb2FkZWQgc2VjcmV0IHZhbHVlcy5cbiAqIFRoaXMgY2F0Y2hlcyBhbnkgc2VjcmV0cyB0aGF0IG1pZ2h0IG5vdCBtYXRjaCB0aGUgcGF0dGVybi1iYXNlZCBkZXRlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNhbml0aXplQWdhaW5zdExvYWRlZFNlY3JldHMobWVzc2FnZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3Qgc2VjcmV0TmFtZXM6IFNlY3JldE5hbWVbXSA9IFtcbiAgICAnT1BFTkFJX0FQSV9LRVknLFxuICAgICdBTlRIUk9QSUNfQVBJX0tFWScsXG4gICAgJ0RFRVBTRUVLX0FQSV9LRVknLFxuICAgICdYQUlfQVBJX0tFWScsXG4gICAgJ0dFTUlOSV9BUElfS0VZJyxcbiAgICAnQlJBVkVfU0VBUkNIX0FQSV9LRVknLFxuICAgICdTRVJQQVBJX0FQSV9LRVknLFxuICAgICdUQVZJTFlfQVBJX0tFWScsXG4gICAgJ1NNVFBfUEFTU1dPUkQnLFxuICBdO1xuXG4gIGxldCBzYW5pdGl6ZWQgPSBtZXNzYWdlO1xuXG4gIGZvciAoY29uc3QgbmFtZSBvZiBzZWNyZXROYW1lcykge1xuICAgIGNvbnN0IHZhbHVlID0gcHJvY2Vzcy5lbnZbbmFtZV07XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCA+PSA4KSB7XG4gICAgICAvLyBPbmx5IHNhbml0aXplIGlmIHRoZSB2YWx1ZSBhcHBlYXJzIGluIHRoZSBtZXNzYWdlXG4gICAgICAvLyBVc2UgYSBjYXNlLXNlbnNpdGl2ZSBleGFjdCBtYXRjaCB0byBhdm9pZCBmYWxzZSBwb3NpdGl2ZXNcbiAgICAgIGlmIChzYW5pdGl6ZWQuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgIHNhbml0aXplZCA9IHNhbml0aXplZC5zcGxpdCh2YWx1ZSkuam9pbignW1JFREFDVEVEXScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzYW5pdGl6ZWQ7XG59XG5cbi8qKlxuICogU2FuaXRpemUgYW4gRXJyb3Igb2JqZWN0J3MgbWVzc2FnZSBhbmQgc3RhY2sgdHJhY2UuXG4gKiBSZXR1cm5zIGEgbmV3IGVycm9yIG1lc3NhZ2Ugc3RyaW5nIHdpdGggc2VjcmV0cyByZW1vdmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVFcnJvcihlcnJvcjogRXJyb3IpOiBzdHJpbmcge1xuICBjb25zdCBtZXNzYWdlID0gc2FuaXRpemVFcnJvck1lc3NhZ2UoZXJyb3IubWVzc2FnZSk7XG4gIGNvbnN0IHN0YWNrID0gZXJyb3Iuc3RhY2sgPyBzYW5pdGl6ZUVycm9yTWVzc2FnZShlcnJvci5zdGFjaykgOiAnJztcblxuICBpZiAoc3RhY2sgJiYgc3RhY2sgIT09IG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gYCR7bWVzc2FnZX1cXG4ke3N0YWNrfWA7XG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2U7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgc2FmZSBlcnJvciBtZXNzYWdlIGZyb20gYW4gdW5rbm93biBlcnJvciB2YWx1ZS5cbiAqIEVuc3VyZXMgbm8gc2VjcmV0cyBhcmUgbGVha2VkIHJlZ2FyZGxlc3Mgb2YgZXJyb3IgdHlwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhZmVFcnJvck1lc3NhZ2UoZXJyb3I6IHVua25vd24pOiBzdHJpbmcge1xuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBzYW5pdGl6ZUVycm9yTWVzc2FnZShlcnJvci5tZXNzYWdlKTtcbiAgfVxuICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzYW5pdGl6ZUVycm9yTWVzc2FnZShlcnJvcik7XG4gIH1cbiAgcmV0dXJuICdVbmtub3duIGVycm9yIG9jY3VycmVkJztcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFBQSxPQUFBLEdBQUFDLE9BQUE7QUFDQSxJQUFBQyxPQUFBLEdBQUFELE9BQUE7QUFDQSxJQUFBRSxTQUFBLEdBQUFGLE9BQUE7QUErQkEsTUFBTUcsa0JBQXNDLEdBQUcsQ0FDN0M7RUFDRUMsRUFBRSxFQUFFLGdCQUFnQjtFQUNwQkMsS0FBSyxFQUFFLGdCQUFnQjtFQUN2QkMsV0FBVyxFQUFFLHNEQUFzRDtFQUNuRUMsTUFBTSxFQUFFLGdCQUFnQjtFQUN4QkMsU0FBUyxFQUFFLENBQUMsUUFBUTtBQUN0QixDQUFDLEVBQ0Q7RUFDRUosRUFBRSxFQUFFLG1CQUFtQjtFQUN2QkMsS0FBSyxFQUFFLG1CQUFtQjtFQUMxQkMsV0FBVyxFQUFFLDBEQUEwRDtFQUN2RUMsTUFBTSxFQUFFLG1CQUFtQjtFQUMzQkMsU0FBUyxFQUFFLENBQUMsV0FBVztBQUN6QixDQUFDLEVBQ0Q7RUFDRUosRUFBRSxFQUFFLGtCQUFrQjtFQUN0QkMsS0FBSyxFQUFFLGtCQUFrQjtFQUN6QkMsV0FBVyxFQUFFLG1EQUFtRDtFQUNoRUMsTUFBTSxFQUFFLGtCQUFrQjtFQUMxQkMsU0FBUyxFQUFFLENBQUMsVUFBVTtBQUN4QixDQUFDLEVBQ0Q7RUFDRUosRUFBRSxFQUFFLGFBQWE7RUFDakJDLEtBQUssRUFBRSxhQUFhO0VBQ3BCQyxXQUFXLEVBQUUsdUNBQXVDO0VBQ3BEQyxNQUFNLEVBQUUsYUFBYTtFQUNyQkMsU0FBUyxFQUFFLENBQUMsS0FBSztBQUNuQixDQUFDLEVBQ0Q7RUFDRUosRUFBRSxFQUFFLGdCQUFnQjtFQUNwQkMsS0FBSyxFQUFFLHVCQUF1QjtFQUM5QkMsV0FBVyxFQUFFLGlEQUFpRDtFQUM5REMsTUFBTSxFQUFFLGdCQUFnQjtFQUN4QkMsU0FBUyxFQUFFLENBQUMsUUFBUTtBQUN0QixDQUFDLEVBQ0Q7RUFDRUosRUFBRSxFQUFFLHNCQUFzQjtFQUMxQkMsS0FBSyxFQUFFLHNCQUFzQjtFQUM3QkMsV0FBVyxFQUFFLHdEQUF3RDtFQUNyRUMsTUFBTSxFQUFFLHNCQUFzQjtFQUM5QkMsU0FBUyxFQUFFO0FBQ2IsQ0FBQyxFQUNEO0VBQ0VKLEVBQUUsRUFBRSxpQkFBaUI7RUFDckJDLEtBQUssRUFBRSxhQUFhO0VBQ3BCQyxXQUFXLEVBQUUsb0RBQW9EO0VBQ2pFQyxNQUFNLEVBQUUsaUJBQWlCO0VBQ3pCQyxTQUFTLEVBQUU7QUFDYixDQUFDLEVBQ0Q7RUFDRUosRUFBRSxFQUFFLGdCQUFnQjtFQUNwQkMsS0FBSyxFQUFFLGdCQUFnQjtFQUN2QkMsV0FBVyxFQUFFLHlGQUF5RjtFQUN0R0MsTUFBTSxFQUFFLGdCQUFnQjtFQUN4QkMsU0FBUyxFQUFFO0FBQ2IsQ0FBQyxFQUNEO0VBQ0VKLEVBQUUsRUFBRSxXQUFXO0VBQ2ZDLEtBQUssRUFBRSxlQUFlO0VBQ3RCQyxXQUFXLEVBQUUsOERBQThEO0VBQzNFQyxNQUFNLEVBQUUsV0FBVztFQUNuQkMsU0FBUyxFQUFFO0FBQ2IsQ0FBQyxFQUNEO0VBQ0VKLEVBQUUsRUFBRSxlQUFlO0VBQ25CQyxLQUFLLEVBQUUsb0JBQW9CO0VBQzNCQyxXQUFXLEVBQUUsK0dBQStHO0VBQzVIQyxNQUFNLEVBQUUsZUFBZTtFQUN2QkMsU0FBUyxFQUFFO0FBQ2IsQ0FBQyxFQUNEO0VBQ0VKLEVBQUUsRUFBRSxlQUFlO0VBQ25CQyxLQUFLLEVBQUUsZ0JBQWdCO0VBQ3ZCQyxXQUFXLEVBQUUsdUVBQXVFO0VBQ3BGQyxNQUFNLEVBQUUsZUFBZTtFQUN2QkMsU0FBUyxFQUFFO0FBQ2IsQ0FBQyxFQUNEO0VBQ0VKLEVBQUUsRUFBRSxnQkFBZ0I7RUFDcEJDLEtBQUssRUFBRSxvQkFBb0I7RUFDM0JDLFdBQVcsRUFBRSxpRUFBaUU7RUFDOUVDLE1BQU0sRUFBRSxnQkFBZ0I7RUFDeEJDLFNBQVMsRUFBRTtBQUNiLENBQUMsRUFDRDtFQUNFSixFQUFFLEVBQUUsV0FBVztFQUNmQyxLQUFLLEVBQUUsa0JBQWtCO0VBQ3pCQyxXQUFXLEVBQUUsMEVBQTBFO0VBQ3ZGQyxNQUFNLEVBQUUsV0FBVztFQUNuQkMsU0FBUyxFQUFFO0FBQ2IsQ0FBQyxFQUNEO0VBQ0VKLEVBQUUsRUFBRSxXQUFXO0VBQ2ZDLEtBQUssRUFBRSxrQkFBa0I7RUFDekJDLFdBQVcsRUFBRSw2RUFBNkU7RUFDMUZDLE1BQU0sRUFBRSxXQUFXO0VBQ25CQyxTQUFTLEVBQUU7QUFDYixDQUFDLENBQ0Y7QUFFRCxNQUFNQyxlQUFlLEdBQUdDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLGVBQWUsQ0FBQztBQUNwRCxNQUFNQyxVQUFVLEdBQUdILGVBQWUsR0FBRyxJQUFBSSxpQkFBTyxFQUFDSixlQUFlLENBQUMsR0FBRyxJQUFBSyxjQUFJLEVBQUMsSUFBQUMsZUFBTyxFQUFDLENBQUMsRUFBRSxNQUFNLENBQUM7QUFDdkYsTUFBTUMsV0FBVyxHQUFHLElBQUFGLGNBQUksRUFBQ0YsVUFBVSxFQUFFLGNBQWMsQ0FBQztBQUU3QyxNQUFNSyxrQkFBa0IsU0FBU0MsS0FBSyxDQUFDO0VBQzVDQyxXQUFXQSxDQUFpQkMsTUFBd0IsRUFBRTtJQUNwRCxLQUFLLENBQUMsR0FBR0EsTUFBTSxDQUFDZixLQUFLLHFCQUFxQixDQUFDO0lBQUMsS0FEbEJlLE1BQXdCLEdBQXhCQSxNQUF3QjtJQUVsRCxJQUFJLENBQUNDLElBQUksR0FBRyxvQkFBb0I7RUFDbEM7QUFDRjtBQUFDQyxPQUFBLENBQUFMLGtCQUFBLEdBQUFBLGtCQUFBO0FBRU0sU0FBU00scUJBQXFCQSxDQUFBLEVBQXVCO0VBQzFELE9BQU8sQ0FBQyxHQUFHcEIsa0JBQWtCLENBQUM7QUFDaEM7QUFFTyxTQUFTcUIsbUJBQW1CQSxDQUFDcEIsRUFBYyxFQUEyQjtFQUMzRSxPQUFPRCxrQkFBa0IsQ0FBQ3NCLElBQUksQ0FBRUMsS0FBSyxJQUFLQSxLQUFLLENBQUN0QixFQUFFLEtBQUtBLEVBQUUsQ0FBQyxJQUFJLElBQUk7QUFDcEU7QUFFTyxTQUFTdUIsY0FBY0EsQ0FBQ3ZCLEVBQWMsRUFBaUI7RUFDNUQsTUFBTXdCLFFBQVEsR0FBR0MsUUFBUSxDQUFDbkIsT0FBTyxDQUFDQyxHQUFHLENBQUNQLEVBQUUsQ0FBQyxDQUFDO0VBQzFDLElBQUl3QixRQUFRLEVBQUU7SUFDWixPQUFPQSxRQUFRO0VBQ2pCO0VBRUEsTUFBTUUsS0FBSyxHQUFHQyxlQUFlLENBQUMsQ0FBQztFQUMvQixNQUFNQyxXQUFXLEdBQUdILFFBQVEsQ0FBQ0MsS0FBSyxDQUFDMUIsRUFBRSxDQUFDLENBQUM7RUFDdkMsSUFBSSxDQUFDNEIsV0FBVyxFQUFFO0lBQ2hCLE9BQU8sSUFBSTtFQUNiO0VBRUF0QixPQUFPLENBQUNDLEdBQUcsQ0FBQ1AsRUFBRSxDQUFDLEdBQUc0QixXQUFXO0VBQzdCLE9BQU9BLFdBQVc7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNDLGNBQWNBLENBQUEsRUFBUztFQUNyQyxNQUFNSCxLQUFLLEdBQUdDLGVBQWUsQ0FBQyxDQUFDO0VBQy9CLEtBQUssTUFBTUcsVUFBVSxJQUFJL0Isa0JBQWtCLEVBQUU7SUFDM0MsTUFBTTZCLFdBQVcsR0FBR0gsUUFBUSxDQUFDQyxLQUFLLENBQUNJLFVBQVUsQ0FBQzlCLEVBQUUsQ0FBQyxDQUFDO0lBQ2xELElBQUk0QixXQUFXLEVBQUU7TUFDZjtNQUNBO01BQ0F0QixPQUFPLENBQUNDLEdBQUcsQ0FBQ3VCLFVBQVUsQ0FBQzlCLEVBQUUsQ0FBQyxHQUFHNEIsV0FBVztJQUMxQztFQUNGOztFQUVBO0VBQ0E7RUFDQTtFQUNBRyxpQkFBaUIsQ0FBQyxDQUFDO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQSxpQkFBaUJBLENBQUEsRUFBUztFQUNqQyxNQUFNQyxTQUFTLEdBQUcxQixPQUFPLENBQUNDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQztFQUMvQyxNQUFNMEIsU0FBUyxHQUFHM0IsT0FBTyxDQUFDQyxHQUFHLENBQUMsZ0JBQWdCLENBQUM7RUFFL0MsSUFBSXlCLFNBQVMsSUFBSSxDQUFDQyxTQUFTLEVBQUU7SUFDM0I7SUFDQTNCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLGdCQUFnQixDQUFDLEdBQUd5QixTQUFTO0VBQzNDLENBQUMsTUFBTSxJQUFJQyxTQUFTLElBQUksQ0FBQ0QsU0FBUyxFQUFFO0lBQ2xDO0lBQ0ExQixPQUFPLENBQUNDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHMEIsU0FBUztFQUMzQyxDQUFDLE1BQU0sSUFBSUQsU0FBUyxJQUFJQyxTQUFTLElBQUlELFNBQVMsS0FBS0MsU0FBUyxFQUFFO0lBQzVEO0lBQ0E7SUFDQTNCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLGdCQUFnQixDQUFDLEdBQUd5QixTQUFTO0VBQzNDO0VBQ0E7QUFDRjtBQUVPLFNBQVNFLGNBQWNBLENBQUNsQyxFQUFjLEVBQUVtQyxRQUFnQixFQUFRO0VBQ3JFLE1BQU1DLEtBQUssR0FBR1gsUUFBUSxDQUFDVSxRQUFRLENBQUM7RUFDaEMsSUFBSSxDQUFDQyxLQUFLLEVBQUU7SUFDVixNQUFNLElBQUl0QixLQUFLLENBQUMsK0JBQStCLENBQUM7RUFDbEQ7RUFFQSxNQUFNWSxLQUFLLEdBQUdDLGVBQWUsQ0FBQyxDQUFDO0VBQy9CRCxLQUFLLENBQUMxQixFQUFFLENBQUMsR0FBR29DLEtBQUs7RUFDakJDLGdCQUFnQixDQUFDWCxLQUFLLENBQUM7RUFDdkJwQixPQUFPLENBQUNDLEdBQUcsQ0FBQ1AsRUFBRSxDQUFDLEdBQUdvQyxLQUFLOztFQUV2QjtFQUNBLElBQUlwQyxFQUFFLEtBQUssZ0JBQWdCLEVBQUU7SUFDM0JNLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLGdCQUFnQixDQUFDLEdBQUc2QixLQUFLO0VBQ3ZDO0FBQ0Y7QUFFTyxTQUFTRSxVQUFVQSxDQUFDRixLQUFhLEVBQVU7RUFDaEQsSUFBSSxDQUFDQSxLQUFLLEVBQUU7SUFDVixPQUFPLEVBQUU7RUFDWDtFQUNBLElBQUlBLEtBQUssQ0FBQ0csTUFBTSxJQUFJLENBQUMsRUFBRTtJQUNyQixPQUFPLEdBQUcsQ0FBQ0MsTUFBTSxDQUFDSixLQUFLLENBQUNHLE1BQU0sQ0FBQztFQUNqQztFQUNBLE1BQU1FLE1BQU0sR0FBR0wsS0FBSyxDQUFDTSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDOUIsTUFBTUMsTUFBTSxHQUFHLEdBQUcsQ0FBQ0gsTUFBTSxDQUFDSSxJQUFJLENBQUNDLEdBQUcsQ0FBQyxDQUFDLEVBQUVULEtBQUssQ0FBQ0csTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0VBQ3hELE9BQU8sR0FBR0ksTUFBTSxHQUFHRixNQUFNLEVBQUU7QUFDN0I7QUFFTyxTQUFTSyx1QkFBdUJBLENBQUNDLFFBQW9CLEVBQVU7RUFDcEUsTUFBTWpCLFVBQVUsR0FBR2tCLHlCQUF5QixDQUFDRCxRQUFRLENBQUM7RUFDdEQsTUFBTVgsS0FBSyxHQUFHYixjQUFjLENBQUNPLFVBQVUsQ0FBQzlCLEVBQUUsQ0FBQztFQUMzQyxJQUFJLENBQUNvQyxLQUFLLEVBQUU7SUFDVixNQUFNLElBQUl2QixrQkFBa0IsQ0FBQ2lCLFVBQVUsQ0FBQztFQUMxQztFQUNBeEIsT0FBTyxDQUFDQyxHQUFHLENBQUN1QixVQUFVLENBQUMzQixNQUFNLENBQUMsR0FBR2lDLEtBQUs7RUFDdEMsT0FBT0EsS0FBSztBQUNkO0FBRU8sU0FBU2EsOEJBQThCQSxDQUFDRixRQUFvQixFQUEyQjtFQUM1RixPQUFPaEQsa0JBQWtCLENBQUNzQixJQUFJLENBQUVDLEtBQUssSUFBS0EsS0FBSyxDQUFDbEIsU0FBUyxDQUFDOEMsUUFBUSxDQUFDSCxRQUFRLENBQUMsQ0FBQyxJQUFJLElBQUk7QUFDdkY7QUFFQSxTQUFTcEIsZUFBZUEsQ0FBQSxFQUFvQjtFQUMxQyxJQUFJLENBQUMsSUFBQXdCLGtCQUFVLEVBQUN2QyxXQUFXLENBQUMsRUFBRTtJQUM1QixPQUFPLENBQUMsQ0FBQztFQUNYO0VBRUEsSUFBSTtJQUNGLE1BQU13QyxPQUFPLEdBQUcsSUFBQUMsb0JBQVksRUFBQ3pDLFdBQVcsRUFBRSxNQUFNLENBQUM7SUFDakQsTUFBTTBDLE1BQU0sR0FBR0MsSUFBSSxDQUFDQyxLQUFLLENBQUNKLE9BQU8sQ0FBQztJQUNsQyxJQUFJRSxNQUFNLElBQUksT0FBT0EsTUFBTSxLQUFLLFFBQVEsRUFBRTtNQUN4QyxPQUFPQSxNQUFNO0lBQ2Y7RUFDRixDQUFDLENBQUMsTUFBTTtJQUNOLE9BQU8sQ0FBQyxDQUFDO0VBQ1g7RUFDQSxPQUFPLENBQUMsQ0FBQztBQUNYO0FBRUEsU0FBU2pCLGdCQUFnQkEsQ0FBQ1gsS0FBc0IsRUFBUTtFQUN0RCxNQUFNK0IsU0FBUyxHQUFHLElBQUFDLGlCQUFPLEVBQUM5QyxXQUFXLENBQUM7RUFDdEMsSUFBQStDLGlCQUFTLEVBQUNGLFNBQVMsRUFBRTtJQUFFRyxTQUFTLEVBQUU7RUFBSyxDQUFDLENBQUM7RUFDekMsTUFBTUMsT0FBTyxHQUFHTixJQUFJLENBQUNPLFNBQVMsQ0FBQ3BDLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0VBQzlDLElBQUFxQyxxQkFBYSxFQUFDbkQsV0FBVyxFQUFFLEdBQUdpRCxPQUFPO0FBQ3ZDLENBQUMsQ0FBQztBQUNGO0FBRUEsU0FBU2IseUJBQXlCQSxDQUFDRCxRQUFvQixFQUFvQjtFQUN6RSxNQUFNakIsVUFBVSxHQUFHbUIsOEJBQThCLENBQUNGLFFBQVEsQ0FBQztFQUMzRCxJQUFJLENBQUNqQixVQUFVLEVBQUU7SUFDZixNQUFNLElBQUloQixLQUFLLENBQUMseUNBQXlDaUMsUUFBUSxJQUFJLENBQUM7RUFDeEU7RUFDQSxPQUFPakIsVUFBVTtBQUNuQjtBQUVBLFNBQVNMLFFBQVFBLENBQUNXLEtBQWMsRUFBaUI7RUFDL0MsSUFBSSxPQUFPQSxLQUFLLEtBQUssUUFBUSxFQUFFO0lBQzdCLE9BQU8sSUFBSTtFQUNiO0VBQ0EsTUFBTTRCLE9BQU8sR0FBRzVCLEtBQUssQ0FBQzZCLElBQUksQ0FBQyxDQUFDO0VBQzVCLE9BQU9ELE9BQU8sQ0FBQ3pCLE1BQU0sR0FBR3lCLE9BQU8sR0FBRyxJQUFJO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1FLGdCQUEwQixHQUFHO0FBQ2pDO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esa0dBQWtHLENBQ25HOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU0Msb0JBQW9CQSxDQUFDQyxPQUFlLEVBQVU7RUFDNUQsSUFBSSxDQUFDQSxPQUFPLElBQUksT0FBT0EsT0FBTyxLQUFLLFFBQVEsRUFBRTtJQUMzQyxPQUFPQSxPQUFPO0VBQ2hCO0VBRUEsSUFBSUMsU0FBUyxHQUFHRCxPQUFPOztFQUV2QjtFQUNBLEtBQUssTUFBTUUsT0FBTyxJQUFJSixnQkFBZ0IsRUFBRTtJQUN0QztJQUNBSSxPQUFPLENBQUNDLFNBQVMsR0FBRyxDQUFDO0lBQ3JCRixTQUFTLEdBQUdBLFNBQVMsQ0FBQ0csT0FBTyxDQUFDRixPQUFPLEVBQUdHLEtBQUssSUFBSztNQUNoRDtNQUNBLElBQUlBLEtBQUssQ0FBQ3ZCLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSXVCLEtBQUssQ0FBQ3ZCLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUM5QyxNQUFNd0IsU0FBUyxHQUFHRCxLQUFLLENBQUN2QixRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUc7UUFDakQsTUFBTXlCLEtBQUssR0FBR0YsS0FBSyxDQUFDRyxLQUFLLENBQUNGLFNBQVMsQ0FBQztRQUNwQyxJQUFJQyxLQUFLLENBQUNwQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1VBQ3RCLE9BQU8sR0FBR29DLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBR0QsU0FBUyxZQUFZO1FBQzVDO01BQ0Y7TUFDQSxPQUFPLFlBQVk7SUFDckIsQ0FBQyxDQUFDO0VBQ0o7O0VBRUE7RUFDQUwsU0FBUyxHQUFHUSw0QkFBNEIsQ0FBQ1IsU0FBUyxDQUFDO0VBRW5ELE9BQU9BLFNBQVM7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTUSw0QkFBNEJBLENBQUNULE9BQWUsRUFBVTtFQUM3RCxNQUFNVSxXQUF5QixHQUFHLENBQ2hDLGdCQUFnQixFQUNoQixtQkFBbUIsRUFDbkIsa0JBQWtCLEVBQ2xCLGFBQWEsRUFDYixnQkFBZ0IsRUFDaEIsc0JBQXNCLEVBQ3RCLGlCQUFpQixFQUNqQixnQkFBZ0IsRUFDaEIsZUFBZSxDQUNoQjtFQUVELElBQUlULFNBQVMsR0FBR0QsT0FBTztFQUV2QixLQUFLLE1BQU1uRCxJQUFJLElBQUk2RCxXQUFXLEVBQUU7SUFDOUIsTUFBTTFDLEtBQUssR0FBRzlCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDVSxJQUFJLENBQUM7SUFDL0IsSUFBSW1CLEtBQUssSUFBSUEsS0FBSyxDQUFDRyxNQUFNLElBQUksQ0FBQyxFQUFFO01BQzlCO01BQ0E7TUFDQSxJQUFJOEIsU0FBUyxDQUFDbkIsUUFBUSxDQUFDZCxLQUFLLENBQUMsRUFBRTtRQUM3QmlDLFNBQVMsR0FBR0EsU0FBUyxDQUFDTyxLQUFLLENBQUN4QyxLQUFLLENBQUMsQ0FBQzFCLElBQUksQ0FBQyxZQUFZLENBQUM7TUFDdkQ7SUFDRjtFQUNGO0VBRUEsT0FBTzJELFNBQVM7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTVSxhQUFhQSxDQUFDQyxLQUFZLEVBQVU7RUFDbEQsTUFBTVosT0FBTyxHQUFHRCxvQkFBb0IsQ0FBQ2EsS0FBSyxDQUFDWixPQUFPLENBQUM7RUFDbkQsTUFBTWEsS0FBSyxHQUFHRCxLQUFLLENBQUNDLEtBQUssR0FBR2Qsb0JBQW9CLENBQUNhLEtBQUssQ0FBQ0MsS0FBSyxDQUFDLEdBQUcsRUFBRTtFQUVsRSxJQUFJQSxLQUFLLElBQUlBLEtBQUssS0FBS2IsT0FBTyxFQUFFO0lBQzlCLE9BQU8sR0FBR0EsT0FBTyxLQUFLYSxLQUFLLEVBQUU7RUFDL0I7RUFDQSxPQUFPYixPQUFPO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU2MsZ0JBQWdCQSxDQUFDRixLQUFjLEVBQVU7RUFDdkQsSUFBSUEsS0FBSyxZQUFZbEUsS0FBSyxFQUFFO0lBQzFCLE9BQU9xRCxvQkFBb0IsQ0FBQ2EsS0FBSyxDQUFDWixPQUFPLENBQUM7RUFDNUM7RUFDQSxJQUFJLE9BQU9ZLEtBQUssS0FBSyxRQUFRLEVBQUU7SUFDN0IsT0FBT2Isb0JBQW9CLENBQUNhLEtBQUssQ0FBQztFQUNwQztFQUNBLE9BQU8sd0JBQXdCO0FBQ2pDIiwiaWdub3JlTGlzdCI6W119