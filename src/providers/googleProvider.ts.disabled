import { GoogleGenerativeAI, HarmBlockThreshold, HarmCategory } from '@google/genai';
import type {
  Content,
  GenerateContentRequest,
  GenerateContentResponse,
  FunctionDeclaration,
  Tool,
  Part,
  GenerateContentResponseUsageMetadata,
} from '@google/genai';
import type {
  ConversationMessage,
  LLMProvider,
  ProviderId,
  ProviderModelInfo,
  ProviderResponse,
  ProviderToolDefinition,
  ToolCallRequest,
  ProviderUsage,
  StreamChunk,
} from '../core/types.js';
import { sanitizeErrorMessage, safeErrorMessage } from '../core/secretStore.js';
import { logDebug } from '../utils/debugLogger.js';
import { securityValidator, securityLogger, globalRateLimiter } from '../utils/securityUtils.js';
import { safeJSONParse } from './openaiChatCompletionsProvider.js';

const REQUEST_CHAR_LIMIT = 800_000; // Hard cap to avoid provider 413 errors

// ============================================================================
// Error Types for Detection
// ============================================================================

const RECOVERABLE_ERROR_PATTERNS = [
  'premature close',
  'premature end',
  'unexpected end',
  'aborted',
  'fetcherror',
  'invalid response body',
  'gunzip',
  'decompress',
  'econnreset',
  'econnrefused',
  'epipe',
  'socket hang up',
  'network',
  'timeout',
] as const;

/**
 * Custom error class for provider-specific failures
 */
export class GoogleProviderError extends Error {
  readonly isRetryable: boolean;
  readonly originalError?: Error;
  readonly providerId: string;

  constructor(message: string, providerId: string, originalError?: Error, isRetryable = true) {
    // SECURITY: Sanitize the error message to prevent token leakage
    super(sanitizeErrorMessage(message));
    this.name = 'GoogleProviderError';
    this.providerId = providerId;
    this.originalError = originalError;
    this.isRetryable = isRetryable;

    // SECURITY: Sanitize stack trace to prevent token leakage
    if (originalError?.stack) {
      this.stack = `${this.stack}\nCaused by: ${sanitizeErrorMessage(originalError.stack)}`;
    }
  }
}

/**
 * Check if an error is recoverable (should be retried)
 */
function isRecoverableError(error: unknown): boolean {
  if (!(error instanceof Error)) return false;

  const message = error.message.toLowerCase();
  const errorName = error.name?.toLowerCase() ?? '';
  const errorCode = (error as { code?: string }).code?.toLowerCase() ?? '';

  // Check all sources for recoverable patterns
  const allText = `${message} ${errorName} ${errorCode}`;

  return RECOVERABLE_ERROR_PATTERNS.some(pattern => allText.includes(pattern));
}

// ============================================================================
// Security Utilities
// ============================================================================

/**
 * Security audit: Google API key validation and protection
 * Enhanced with comprehensive validation and security controls
 */
function validateAndProtectApiKey(apiKey: string): string {
  if (!apiKey || typeof apiKey !== 'string') {
    throw new Error('Google API key is required and must be a string');
  }
  
  // Remove whitespace
  apiKey = apiKey.trim();
  
  // Comprehensive format validation
  const validation = validateGoogleKeyFormat(apiKey);
  if (!validation.isValid) {
    throw new Error(`Invalid Google API key: ${validation.reason}`);
  }
  
  // Security logging (redacted)
  const redactedKey = apiKey.length > 8 ? `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 4)}` : '[REDACTED]';
  logDebug(`[SECURITY] Using Google API key (type: ${validation.keyType}, redacted: ${redactedKey})`);
  
  // Check for known revoked/compromised key patterns
  if (isPotentiallyCompromisedKey(apiKey)) {
    console.warn('SECURITY WARNING: Google API key matches patterns associated with compromised keys. Rotate immediately.');
  }
  
  return apiKey;
}

/**
 * Comprehensive Google key format validation
 */
function validateGoogleKeyFormat(apiKey: string): {
  isValid: boolean;
  reason?: string;
  keyType: 'gemini' | 'oauth2' | 'service_account' | 'unknown';
} {
  // Length validation
  if (apiKey.length < 30 || apiKey.length > 5000) {
    return { isValid: false, reason: `Invalid key length: ${apiKey.length} chars (expected 30-5000)`, keyType: 'unknown' };
  }
  
  // Google AI API key format (starts with AIza)
  if (apiKey.startsWith('AIza')) {
    // Typical format: AIzaSyA... (39 chars for standard keys)
    if (apiKey.length < 39 || apiKey.length > 100) {
      return { isValid: false, reason: `Google AI key should be 39-100 chars, got ${apiKey.length}`, keyType: 'gemini' };
    }
    return { isValid: true, keyType: 'gemini' };
  }
  
  // OAuth2 token format (starts with ya29. or 1//)
  if (apiKey.startsWith('ya29.') || apiKey.startsWith('1//')) {
    // OAuth2 tokens can vary in length
    if (apiKey.length < 100 || apiKey.length > 2000) {
      return { isValid: false, reason: `OAuth2 token length ${apiKey.length} outside expected range`, keyType: 'oauth2' };
    }
    return { isValid: true, keyType: 'oauth2' };
  }
  
  // Service account JSON key (starts with {)
  if (apiKey.trim().startsWith('{')) {
    try {
      // Validate it's valid JSON
      const parsed = safeJSONParse<Record<string, unknown>>(apiKey, { maxDepth: 10, maxProperties: 50 });
      if (parsed.type === 'service_account' && parsed.private_key) {
        return { isValid: true, keyType: 'service_account' };
      }
    } catch {
      // Not valid JSON
    }
  }
  
  // Unknown format but might be valid (custom deployments, etc.)
  console.warn(`Unrecognized Google API key format: ${apiKey.substring(0, 12)}...`);
  return { isValid: true, keyType: 'unknown' };
}

/**
 * Check for patterns associated with compromised keys
 */
function isPotentiallyCompromisedKey(apiKey: string): boolean {
  // Check for test keys or placeholder patterns
  const compromisedPatterns = [
    'test_',
    'demo_',
    'example_',
    'placeholder',
    'changeme',
    'your-api-key-here',
  ];
  
  const lowerKey = apiKey.toLowerCase();
  for (const pattern of compromisedPatterns) {
    if (lowerKey.includes(pattern)) {
      return true;
    }
  }
  
  // Check for sequential or repeating patterns
  const sequentialPattern = /(\d{3,})/;
  const match = sequentialPattern.exec(apiKey);
  if (match) {
    const sequence = match[1];
    if (isSequentialDigits(sequence)) {
      return true;
    }
  }
  
  return false;
}

/**
 * Check if a string of digits is sequential
 */
function isSequentialDigits(str: string): boolean {
  if (str.length < 3) return false;
  
  // Check ascending
  let ascending = true;
  for (let i = 1; i < str.length; i++) {
    if (parseInt(str[i]) !== parseInt(str[i-1]) + 1) {
      ascending = false;
      break;
    }
  }
  
  if (ascending) return true;
  
  // Check descending
  let descending = true;
  for (let i = 1; i < str.length; i++) {
    if (parseInt(str[i]) !== parseInt(str[i-1]) - 1) {
      descending = false;
      break;
    }
  }
  
  return descending;
}

// ============================================================================
// Provider Configuration
// ============================================================================

interface GoogleProviderOptions {
  apiKey: string;
  model: string;
  providerId?: ProviderId;
  /** Request timeout in milliseconds (default: 120000) */
  timeout?: number;
  /** Maximum retries for transient errors (default: 3) */
  maxRetries?: number;
  /** Optional temperature override */
  temperature?: number;
  /** Maximum completion tokens to request (default: 4096) */
  maxTokens?: number;
  /** Safety settings configuration */
  safetySettings?: Array<{
    category: HarmCategory;
    threshold: HarmBlockThreshold;
  }>;
}

export class GoogleProvider implements LLMProvider {
  readonly id: ProviderId;
  readonly model: string;
  private readonly client: GoogleGenerativeAI;
  private readonly maxRetries: number;
  private readonly temperature?: number;
  private readonly maxTokens: number;
  private readonly safetySettings?: Array<{
    category: HarmCategory;
    threshold: HarmBlockThreshold;
  }>;
  private readonly requestCount: number = 0;
  private readonly lastRequestTime: number = Date.now();
  
  constructor(options: GoogleProviderOptions) {
    // SECURITY: Validate and protect API key before use
    const validatedApiKey = validateAndProtectApiKey(options.apiKey);
    
    // SECURITY: Rate limiting check
    if (!globalRateLimiter.isAllowed('google-provider')) {
      throw new Error('Rate limit exceeded for Google provider. Please wait before making more requests.');
    }
    
    // SECURITY: Log security event
    securityLogger.logSecurityEvent({
      type: 'google_provider_initialized',
      command: 'constructor',
      success: true,
      timestamp: new Date(),
      details: {
        model: options.model,
        providerId: options.providerId,
        keyType: validateGoogleKeyFormat(validatedApiKey).keyType
      }
    });
    
    this.client = new GoogleGenerativeAI(validatedApiKey);
    this.id = options.providerId ?? 'google';
    this.model = options.model;
    this.maxRetries = options.maxRetries ?? 3;
    this.temperature = typeof options.temperature === 'number' ? options.temperature : undefined;
    this.maxTokens = Math.max(1, options.maxTokens ?? 4096);
    this.safetySettings = options.safetySettings;
  }

  /**
   * Sleep for a given number of milliseconds
   */
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Calculate exponential backoff delay
   */
  private getBackoffDelay(attempt: number, baseDelay = 1000, maxDelay = 30000): number {
    const delay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);
    // Add jitter to prevent thundering herd
    return delay + Math.random() * delay * 0.1;
  }

  /**
   * Execute request with retry logic for transient errors
   */
  private async executeWithRetry<T>(
    operation: () => Promise<T>,
    operationName: string
  ): Promise<T> {
    let lastError: Error | undefined;

    for (let attempt = 0; attempt <= this.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));

        // Check if this is a recoverable error
        if (isRecoverableError(error) && attempt < this.maxRetries) {
          const delay = this.getBackoffDelay(attempt);
          // SECURITY: Sanitize error message to prevent token leakage
          logDebug(
            `[${this.id}] ${operationName} failed (attempt ${attempt + 1}/${this.maxRetries + 1}): ` +
            `${safeErrorMessage(lastError)}. Retrying in ${Math.round(delay)}ms...`
          );
          await this.sleep(delay);
          continue;
        }

        // Non-recoverable error or out of retries
        throw new GoogleProviderError(
          `${operationName} failed after ${attempt + 1} attempts: ${lastError.message}`,
          this.id,
          lastError,
          isRecoverableError(error)
        );
      }
    }

    // Should not reach here, but TypeScript needs this
    throw lastError!;
  }

  async generate(messages: ConversationMessage[], tools: ProviderToolDefinition[]): Promise<ProviderResponse> {
    const { messages: boundedMessages } = enforceRequestSizeLimit(messages);

    return this.executeWithRetry(async () => {
      const model = this.client.getGenerativeModel({ 
        model: this.model,
        generationConfig: {
          temperature: this.temperature,
          maxOutputTokens: this.maxTokens,
        },
        safetySettings: this.safetySettings,
      });

      const request: GenerateContentRequest = {
        contents: mapMessages(boundedMessages),
        tools: tools.length ? [{ functionDeclarations: tools.map(mapTool) }] : undefined,
        toolConfig: tools.length ? { functionCallingConfig: { mode: 'ANY' } } : undefined,
      };

      const response = await model.generateContent(request);
      const result = response.response;
      
      // Extract content and tool calls
      const content = extractTextFromResponse(result);
      const toolCalls = extractToolCalls(result);
      const usage = mapUsage(result.usageMetadata);

      if (toolCalls.length > 0) {
        return {
          type: 'tool_calls',
          toolCalls,
          content,
          usage,
        };
      }

      return {
        type: 'message',
        content,
        usage,
      };
    }, 'generate');
  }

  async *generateStream(
    messages: ConversationMessage[],
    tools: ProviderToolDefinition[]
  ): AsyncIterableIterator<StreamChunk> {
    const { messages: boundedMessages } = enforceRequestSizeLimit(messages);

    const model = this.client.getGenerativeModel({ 
      model: this.model,
      generationConfig: {
        temperature: this.temperature,
        maxOutputTokens: this.maxTokens,
      },
      safetySettings: this.safetySettings,
    });

    const request: GenerateContentRequest = {
      contents: mapMessages(boundedMessages),
      tools: tools.length ? [{ functionDeclarations: tools.map(mapTool) }] : undefined,
      toolConfig: tools.length ? { functionCallingConfig: { mode: 'ANY' } } : undefined,
    };

    const stream = await model.generateContentStream(request);
    
    for await (const chunk of stream.stream) {
      if (chunk.candidates && chunk.candidates.length > 0) {
        const candidate = chunk.candidates[0];
        
        // Handle content updates
        if (candidate.content && candidate.content.parts) {
          const text = candidate.content.parts
            .filter(part => part.text)
            .map(part => part.text!)
            .join('');
          
          if (text) {
            yield {
              type: 'content',
              content: text,
            };
          }
        }
        
        // Handle function calls
        if (candidate.content?.parts?.some(part => part.functionCall)) {
          const functionCalls = candidate.content.parts
            .filter(part => part.functionCall)
            .map(part => part.functionCall!);
          
          for (const funcCall of functionCalls) {
            yield {
              type: 'tool_call',
              toolCall: {
                id: `call_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
                name: funcCall.name,
                arguments: safeJSONParse<Record<string, unknown>>(JSON.stringify(funcCall.args || {}), {
                  maxDepth: 10,
                  maxProperties: 100
                }),
              },
            };
          }
        }
      }
      
      // Handle usage updates
      if (chunk.usageMetadata) {
        yield {
          type: 'usage',
          usage: mapUsage(chunk.usageMetadata),
        };
      }
    }
    
    yield { type: 'done' };
  }

  private cachedModelInfo: ProviderModelInfo | null = null;

  async getModelInfo(): Promise<ProviderModelInfo | null> {
    if (this.cachedModelInfo) {
      return this.cachedModelInfo;
    }

    try {
      // Google Gemini models have known context windows
      // gemini-1.5-pro: 1M tokens, gemini-1.0-pro: 32K tokens, etc.
      const modelContextWindows: Record<string, number> = {
        'gemini-1.5-pro': 1000000,
        'gemini-1.5-pro-latest': 1000000,
        'gemini-1.5-flash': 1000000,
        'gemini-1.5-flash-latest': 1000000,
        'gemini-1.0-pro': 32768,
        'gemini-1.0-pro-latest': 32768,
        'gemini-pro': 32768,
        'gemini-pro-vision': 16384,
      };

      const contextWindow = modelContextWindows[this.model] || 32768;
      const maxOutputTokens = this.model.includes('1.5') ? 8192 : 2048;

      this.cachedModelInfo = {
        id: this.model,
        contextWindow,
        maxOutputTokens,
        inputTokenLimit: contextWindow,
        outputTokenLimit: maxOutputTokens,
      };

      return this.cachedModelInfo;
    } catch (error) {
      logDebug(`Failed to get model info for ${this.model}: ${safeErrorMessage(error)}`);
      return null;
    }
  }
}